<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- MathLive for LaTeX editing -->
    <script src="https://unpkg.com/@nagwa-limited/mathlive" defer></script>
    <script>
        // CRITICAL FIX: Ensure MathLive loads properly
        function ensureMathLiveLoaded() {
            return new Promise((resolve) => {
                if (typeof window.MathfieldElement !== 'undefined') {
                    console.log('âœ… [MathLive] MathfieldElement already loaded');
                    resolve();
                } else {
                    console.log('ğŸ”¢ [MathLive] Waiting for MathfieldElement to load...');
                    const checkInterval = setInterval(() => {
                        if (typeof window.MathfieldElement !== 'undefined') {
                            console.log('âœ… [MathLive] MathfieldElement loaded successfully');
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                }
            });
        }
        
        // CRITICAL FIX: Global function to rescan math elements
        window.rescanMathElements = function() {
            if (window.MathfieldElement && typeof window.MathfieldElement.scan === 'function') {
                console.log('ğŸ”¢ [MathLive] Rescanning all math-field elements...');
                window.MathfieldElement.scan(document.body);
            }
        };
        
        window.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸ”¢ [MathLive] DOM loaded, checking MathLive...');
            
            ensureMathLiveLoaded().then(() => {
                // Force initialization of all math-field elements
                setTimeout(() => {
                    const mathFields = document.querySelectorAll('math-field');
                    console.log(`ğŸ”¢ [MathLive] Found ${mathFields.length} math-field elements to initialize`);
                    
                    mathFields.forEach((mf, index) => {
                        try {
                            // Force MathLive to process the element
                            if (mf.value && !mf.innerHTML.includes('math-field')) {
                                mf.setAttribute('value', mf.value);
                                mf.dispatchEvent(new Event('input'));
                                mf.dispatchEvent(new Event('change'));
                            }
                        } catch (err) {
                            console.warn(`MathLive error for math-field ${index}:`, err);
                        }
                    });
                }, 100);
            });
        });
    </script>
    <!-- Fabric.js for simple image annotation/editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <!-- DOMPurify for security -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <!-- Diff Match Patch for comparing text -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f3f4f6;
            --text-color: #1f2937;
            --card-bg: #ffffff;
            --card-border: #e5e7eb;
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --primary-color: #4f46e5;
            --primary-hover: #4338ca;
            --secondary-text: #6b7280;
            --success-color: #10b981;
            --error-color: #ef4444;
            --warning-color: #f59e0b; /* âš ï¸ Ø£Ø¶Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± */
            --highlight-bg: #fef9c3;
            --diff-ins-bg: #ddfbe9;
            --diff-del-bg: #fce8e9;
        }

        [data-theme="dark"] {
            --bg-color: #111827;
            --text-color: #f9fafb;
            --card-bg: #1f2937;
            --card-border: #374151;
            --input-bg: #374151;
            --input-border: #4b5563;
            --primary-color: #6366f1;
            --primary-hover: #818cf8;
            --secondary-text: #9ca3af;
            --error-color: #ef4444; /* (Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„) */
            --warning-color: #f59e0b; /* âš ï¸ Ø£Ø¶Ù Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± */
            --highlight-bg: #4d4318;
            --diff-ins-bg: #133825;
            --diff-del-bg: #411a1d;
        }

        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .main-card,
        .preview-card {
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        input,
        select,
        textarea {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
        }

        .dragover {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--bg-color));
        }

        .api-selector input[type="radio"]:checked+label {
            border-color: var(--primary-color);
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
            color: var(--primary-color);
        }

        .alert {
            transition: all 0.5s ease-in-out;
            opacity: 1;
            transform: translateX(0);
        }

        .alert.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }

        .search-highlight,
        mark.search-highlight {
            background-color: var(--highlight-bg);
            color: var(--text-color);
            border-radius: 3px;
            padding: 0 2px;
        }

        #saveIndicator {
            font-size: 0.85rem;
            color: var(--secondary-text);
        }

        #saveIndicator.saved {
            color: var(--success-color);
        }

        #saveIndicator.error {
            color: var(--error-color);
        }

        /* Accordion Styles */
        .accordion-header {
            width: 100%;
            padding: 1rem 1.5rem;
            text-align: right;
            font-weight: 700;
            font-size: 1.125rem;
            border-radius: 0.75rem;
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
            transition: background-color 0.2s;
            cursor: pointer;
        }

        .accordion-header:hover {
            background-color: color-mix(in srgb, var(--primary-color) 15%, var(--card-bg));
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
            background-color: var(--card-bg);
            border-top: 1px solid var(--card-border);
        }

        .accordion-content.open {
            padding: 1.5rem;
        }

        /* Diff View Styles */
        .diff-view {
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: var(--bg-color);
            border: 1px solid var(--card-border);
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .diff-view ins {
            background-color: var(--diff-ins-bg);
            text-decoration: none;
        }

        .diff-view del {
            background-color: var(--diff-del-bg);
            text-decoration: line-through;
        }

        /* Status Indicator */
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }

        .status-translated {
            background-color: var(--success-color);
        }
        
        /* Field State Colors */
        .field-warning {
            border-right: 4px solid var(--warning-color) !important;
        }
        
        .field-error {
            border-right: 4px solid var(--error-color) !important;
        }
        
        .field-success {
            border-right: 4px solid var(--success-color) !important;
        }
        
        .field-edited {
            background-color: color-mix(in srgb, var(--warning-color) 5%, var(--card-bg)) !important;
        }
        
        /* Quality Badges */
        .quality-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            opacity: 0.3;
            cursor: help;
            transition: all 0.2s;
        }
        
        .quality-badge.valid {
            opacity: 1;
            background-color: #10b981;
            color: white;
        }
        
        .quality-badge.invalid {
            opacity: 1;
            background-color: #ef4444;
            color: white;
        }
        
        /* Action Buttons */
        .action-btn {
            padding: 4px 8px;
            border: 1px solid var(--card-border);
            border-radius: 6px;
            background: var(--card-bg);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .action-btn:hover {
            background-color: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }
        
        /* Progress Bars */
        .file-progress-bar {
            width: 100%;
            background-color: #e5e7eb;
            border-radius: 9999px;
            height: 0.5rem;
            margin-top: 0.5rem;
            overflow: hidden;
        }
        
        .file-progress-fill {
            background-color: #10b981;
            height: 100%;
            border-radius: 9999px;
            transition: width 0.3s ease;
        }
        
        /* Review Mode */
        .review-mode .translated-content {
            filter: blur(8px);
            transition: filter 0.3s;
        }
        
        .review-mode .translated-content:hover {
            filter: blur(0px);
        }

        .status-edited {
            background-color: #f59e0b;
        }

        /* Amber 500 */

        /* Styles for MathLive Fields */
        .editable-preview-field {
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 0.5rem;
            padding: 0.75rem;
            min-height: 80px;
        }

        math-field {
            position: relative;
        }

        /* CRITICAL FIX: Ensure math-field renders properly */
        math-field[read-only] {
            background-color: transparent;
            border: none;
            padding: 0;
            cursor: default;
        }
        
        /* Force MathLive rendering - DISABLED */
        /* math-field:not([data-mathlive-initialized]) {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        math-field[data-mathlive-initialized] {
            opacity: 1;
        } */
        
        /* CRITICAL FIX: Ensure proper MathLive display */
        math-field {
            display: inline-block;
            min-width: 20px;
            min-height: 20px;
        }
        
        /* Fix for broken HTML entities in math-field - DISABLED */
        /* math-field[value*="&am"] {
            opacity: 0.8;
        } */
        
        /* Ensure MathLive renders properly - DISABLED */
        /* math-field:not(:defined) {
            opacity: 0;
        }
        
        math-field:defined {
            opacity: 1;
        } */
        
        /* CRITICAL FIX: Force MathLive rendering for all math-field elements - DISABLED */
        /* math-field {
            display: inline-block !important;
            min-width: 20px !important;
            min-height: 20px !important;
            background: transparent !important;
            border: none !important;
            padding: 2px !important;
            margin: 0 !important;
        } */
        
        /* Hide raw LaTeX content and show rendered math - DISABLED */
        /* math-field[value] {
            color: inherit !important;
            font-family: inherit !important;
        } */
        
        /* Ensure MathLive takes over the rendering - DISABLED */
        /* math-field:not([data-mathlive-initialized]) {
            visibility: hidden;
        }
        
        math-field[data-mathlive-initialized] {
            visibility: visible;
        } */

        /* Math field buttons - DISABLED */
        /* .math-field-delete-btn {
            position: absolute;
            top: -10px;
            left: -10px;
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10;
        }
        
        .math-field-copy-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 10;
        }
        
        math-field:hover .math-field-delete-btn,
        math-field:focus-within .math-field-delete-btn,
        math-field:hover .math-field-copy-btn,
        math-field:focus-within .math-field-copy-btn {
            opacity: 1;
            visibility: visible;
        }
        
        .math-field-delete-btn:hover {
            background-color: #dc2626;
            transform: scale(1.1);
        }
        
        .math-field-copy-btn:hover {
            background-color: var(--success-color);
            transform: scale(1.1);
        } */
        /* MathLive default look (editable) */
        math-field {
            border: 1px solid var(--input-border);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 1.1em;
            display: inline-block;
            background: var(--input-bg);
            min-width: 20px;
            margin: 2px;
            max-width: 100%;
            white-space: nowrap;
            /* Force LTR for all math content - critical for equations */
            direction: ltr; /* ØªÙ… Ø¥Ø²Ø§Ù„Ø© !important */
            unicode-bidi: embed;
        }

        /* Higher-fidelity preview to match source system: make formulas look inline and unboxed inside preview */
        .editable-preview-field math-field {
            border: 0;
            background: transparent;
            padding: 0 2px;
            box-shadow: none;
        }

        .editable-preview-field .content-root {
            line-height: 1.8;
        }

        .editable-preview-field .content-root p {
            margin: .25rem 0;
        }

        /* Approximate Lexical theme blocks so content spacing matches original */
        .LexicalTheme__paragraph {
            white-space: pre-wrap;
            margin: .25rem 0;
        }

        .LexicalTheme__image img {
            max-width: 100%;
            height: auto;
        }

        math-field:focus-within {
            background-color: color-mix(in srgb, var(--primary-color) 10%, var(--input-bg));
            box-shadow: 0 0 0 2px var(--primary-color);
            outline: none;
        }

        /* Enhanced MathLive keyboard styling for Arabic support */
        math-field {
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Arabic text in math fields */
        math-field[dir="rtl"] {
            text-align: right;
            direction: rtl;
        }

        /* English text in math fields */
        math-field[dir="ltr"] {
            text-align: left;
            direction: ltr;
        }

        /* Mixed content in math fields */
        math-field[dir="auto"] {
            text-align: start;
            direction: auto;
        }

        /* Virtual keyboard styling */
        .ML__keyboard {
            font-family: 'Cairo', 'Arial', sans-serif !important;
        }

        /* Arabic keys in keyboard */
        .ML__keyboard .ML__key[data-key*="\u0600"] {
            font-family: 'Cairo', 'Arial', sans-serif !important;
            font-size: 1.1em;
        }

        /* Language indicator */
        .ML__keyboard::before {
            content: attr(data-language);
            position: absolute;
            top: -25px;
            left: 10px;
            font-size: 12px;
            color: var(--secondary-text);
            font-family: 'Cairo', 'Arial', sans-serif;
        }

        /* Enhanced keyboard theme for Arabic */
        .ML__keyboard[data-language="ar"] {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        /* Arabic key styling */
        .ML__keyboard[data-language="ar"] .ML__key {
            border-radius: 6px;
            border: 1px solid #dee2e6;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .ML__keyboard[data-language="ar"] .ML__key:hover {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .ML__keyboard[data-language="ar"] .ML__key:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Visual blank for underscores in preview (does not persist to JSON) */
        .blank-slot {
            display: inline-block;
            min-width: 1.8em;
            border-bottom: 2px solid currentColor;
            vertical-align: baseline;
            line-height: 1.2;
            margin: 0 0.15em;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 2px;
            padding: 1px 2px;
        }

        /* Ensure blanks are visible in both original and translated text */
        .original-text-readonly .blank-slot,
        .editable-preview-field .blank-slot {
            border-bottom: 2px solid #666;
            background-color: rgba(0, 0, 0, 0.08);
        }

        /* Make blanks more prominent in original text */
        .original-text-readonly .blank-slot {
            border-bottom: 3px solid #333;
            background-color: rgba(0, 0, 0, 0.12);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are visible in read-only fields */
        .p-3.rounded-lg.text-sm .blank-slot {
            border-bottom: 2px solid #555;
            background-color: rgba(0, 0, 0, 0.1);
            min-width: 2em;
        }

        /* Make blanks more visible in different contexts */
        .blank-slot {
            position: relative;
            cursor: default;
        }

        .blank-slot::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 1px;
            background-color: rgba(0, 0, 0, 0.2);
        }

        /* Add hover effect to make blanks more interactive */
        .blank-slot:hover {
            background-color: rgba(0, 0, 0, 0.15) !important;
            border-bottom-color: #333 !important;
        }

        /* Ensure blanks are visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot {
                background-color: rgba(255, 255, 255, 0.1) !important;
                border-bottom-color: #ccc !important;
            }

            .blank-slot:hover {
                background-color: rgba(255, 255, 255, 0.2) !important;
                border-bottom-color: #fff !important;
            }
        }

        /* Add tooltip to show blank length on hover */
        .blank-slot[data-blank]:hover::before {
            content: attr(data-blank);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Ensure tooltip is visible in dark mode */
        @media (prefers-color-scheme: dark) {
            .blank-slot[data-blank]:hover::before {
                background-color: #fff;
                color: #333;
            }
        }

        /* Add animation for better visual feedback */
        .blank-slot {
            transition: all 0.2s ease-in-out;
        }

        .blank-slot:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Ensure blanks are accessible */
        .blank-slot[data-blank] {
            aria-label: "ÙØ±Ø§Øº: " attr(data-blank);
        }

        /* Add focus styles for keyboard navigation */
        .blank-slot:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Ensure blanks are visible in print */
        @media print {
            .blank-slot {
                border-bottom: 2px solid #000 !important;
                background-color: transparent !important;
                box-shadow: none !important;
            }
        }

        /* Add support for high contrast mode */
        @media (prefers-contrast: high) {
            .blank-slot {
                border-bottom: 3px solid #000 !important;
                background-color: #fff !important;
            }
        }

        /* Add support for reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                transition: none !important;
            }

            .blank-slot:hover {
                transform: none !important;
            }
        }

        /* Advanced text direction support for mixed content */
        .text-mixed {
            direction: auto;
            text-align: start;
            unicode-bidi: embed;
        }

        /* Enhanced text direction for Arabic-English mixed content */
        .rtl-auto {
            direction: rtl;
            text-align: right;
            unicode-bidi: embed;
        }

        .ltr-auto {
            direction: ltr;
            text-align: left;
            unicode-bidi: embed;
        }

        /* Support for inline mixed text */
        .mixed-content {
            direction: auto;
            unicode-bidi: plaintext;
        }

        /* Improved support for numbers in Arabic text */
        .arabic-numerals {
            font-family: 'Arial Unicode MS', Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        .english-numerals {
            font-family: Arial, sans-serif;
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Enhanced preview content direction */
        .original-text-readonly,
        .editable-preview-field {
            direction: auto;
            text-align: start;
            unicode-bidi: plaintext;
        }

        /* Special handling for mixed content in preview */
        .content-root {
            unicode-bidi: plaintext;
        }

        .content-root * {
            unicode-bidi: embed;
        }
        
        /* Ensure proper RTL direction for Arabic content */
        .editable-preview-field .content-root[dir="rtl"],
        .original-text-readonly .content-root[dir="rtl"] {
            direction: rtl;
            text-align: right;
        }
        
        /* Ensure proper LTR direction for English content */
        .editable-preview-field .content-root[dir="ltr"],
        .original-text-readonly .content-root[dir="ltr"] {
            direction: ltr;
            text-align: left;
        }

        /* Handle English phrases within Arabic text */
        .english-phrase {
            direction: ltr;
            unicode-bidi: embed;
            display: inline;
        }

        /* Handle Arabic phrases within English text */
        .arabic-phrase {
            direction: rtl;
            unicode-bidi: embed;
            display: inline;
        }

        /* Math and chemical formulas should always be LTR */
        math-field,
        .math-content,
        .chemical-formula {
            direction: ltr; /* ØªÙ… Ø¥Ø²Ø§Ù„Ø© !important */
            unicode-bidi: embed;
            text-align: left;
        }

        /* Improved blank slots for mixed content */
        .blank-slot {
            direction: inherit;
            unicode-bidi: embed;
        }

        /* Add support for large text */
        @media (prefers-reduced-motion: reduce) {
            .blank-slot {
                min-width: 2.5em;
                font-size: 1.1em;
            }
        }

        /* Tables inside editable preview */
        .editable-preview-field table {
            width: 100%;
            border-collapse: collapse;
            direction: rtl;
        }

        .editable-preview-field th,
        .editable-preview-field td {
            border: 1px solid var(--card-border);
            padding: 6px 8px;
            vertical-align: top;
        }

        .editable-preview-field thead {
            background-color: color-mix(in srgb, var(--primary-color) 8%, var(--card-bg));
        }

        /* Make table cells editable */
        .editable-preview-field td,
        .editable-preview-field th {
            position: relative;
            min-height: 1.5em;
            cursor: text;
        }

        .editable-preview-field td:focus,
        .editable-preview-field th:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: color-mix(in srgb, var(--primary-color) 5%, var(--input-bg));
        }
    </style>
</head>

<body class="text-gray-800">
    <div id="alertContainer" class="fixed top-0 right-0 p-4 w-full max-w-md z-50 space-y-3"></div>

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-4xl md:text-5xl font-bold" style="color: var(--primary-color);">ğŸŒ Ù…ØªØ±Ø¬Ù… Ø§Ù„Ø£Ø³Ø¦Ù„Ø© 
            </h1>
            <div class="flex items-center gap-4">
                <span id="saveIndicator" aria-live="polite">â€”</span>
                <button id="theme-toggle" class="text-2xl">â˜€ï¸</button>
                <button id="newSessionBtn"
                    class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-600 transition">Ø¨Ø¯Ø¡
                    Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            </div>
        </div>
        <p class="mt-2 mb-8 text-center text-lg" style="color: var(--secondary-text);">ØªØ±Ø¬Ù…Ø© Ù…Ù„ÙØ§Øª JSONØŒ Ù…Ø¹ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
            ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„ØŒ ÙˆØ¯Ø¹Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©.</p>

        <div id="setupSection" class="main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4 border-b-2 pb-2"
                style="color: var(--primary-color); border-color: var(--primary-color-light);">Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ±ÙØ¹
                Ø§Ù„Ù…Ù„ÙØ§Øª</h3>
            <div class="grid md:grid-cols-2 gap-6">
                <div>
                    <div class="mb-6">
                        <label class="block mb-2 font-semibold">Ø§Ø®ØªØ± Ù…ÙØ²ÙˆÙ‘Ø¯ Ø§Ù„Ø®Ø¯Ù…Ø©:</label>
                        <div class="api-selector grid grid-cols-3 gap-4">
                            <div>
                                <input type="radio" id="geminiProvider" name="apiProvider" value="gemini" class="hidden"
                                    checked>
                                <label for="geminiProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">ğŸ¤– Gemini</span></label>
                            </div>
                            <div>
                                <input type="radio" id="chatgptProvider" name="apiProvider" value="chatgpt"
                                    class="hidden">
                                <label for="chatgptProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">ğŸ’¬ ChatGPT</span></label>
                            </div>
                            <div>
                                <input type="radio" id="localModelProvider" name="apiProvider" value="local"
                                    class="hidden">
                                <label for="localModelProvider"
                                    class="block text-center p-4 border-2 rounded-lg cursor-pointer transition"><span
                                        class="font-bold">ğŸ–¥ï¸ Ù†Ù…ÙˆØ°Ø¬ Ù…Ø­Ù„ÙŠ</span></label>
                            </div>
                        </div>
                    </div>

                    <div id="geminiKeyGroup" class="mb-6">
                        <label for="geminiKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ Gemini API:</label>
                        <input type="password" id="geminiKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ AIza..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="chatgptKeyGroup" class="mb-6 hidden">
                        <label for="chatgptKey" class="block mb-2 font-semibold">Ù…ÙØªØ§Ø­ OpenAI API:</label>
                        <input type="password" id="chatgptKey" placeholder="ÙŠØ¨Ø¯Ø£ Ø¨Ù€ sk-..."
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>
                    <div id="localModelGroup" class="mb-6 hidden">
                        <label for="localModelUrl" class="block mb-2 font-semibold">Ø¹Ù†ÙˆØ§Ù† URL Ù„Ø®Ø§Ø¯Ù… Ollama:</label>
                        <input type="text" id="localModelUrl" placeholder="http://localhost:11434/api/generate"
                            class="w-full p-3 rounded-lg focus:ring-2 transition mb-2"
                            style="border-color: var(--input-border);">
                        <label for="localModelName" class="block mb-2 font-semibold">Ø§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (Ù…Ø«Ø§Ù„:
                            gemma:7b):</label>
                        <input type="text" id="localModelName" placeholder="gemma:7b"
                            class="w-full p-3 rounded-lg focus:ring-2 transition"
                            style="border-color: var(--input-border);">
                    </div>

                    <div class="mb-6">
                      <label for="translatorSelect" class="block mb-2 font-semibold">Ø§Ø³Ù… Ø§Ù„Ù…ØªØ±Ø¬Ù…:</label>
                      <select id="translatorSelect" class="w-full p-3 rounded-lg focus:ring-2 transition" style="border-color: var(--input-border);">
                        <option value="">Ø§Ø®ØªØ± Ù…ØªØ±Ø¬Ù…Ø§Ù‹</option>
                        <option value="Fatema Samy">Fatema Samy</option>
                        <option value="Samar Bahaaeldin">Samar Bahaaeldin</option>
                        <option value="Lobna Adel">Lobna Adel</option>
                        <option value="Shady Donia">Shady Donia</option>
                        <option value="Zeina Elsheikh">Zeina Elsheikh</option>
                        <option value="Aiat Saied">Aiat Saied</option>
                        <option value="Monica Sidhom">Monica Sidhom</option>
                        <option value="Yara Sobhy">Yara Sobhy</option>
                        <option value="Mariam Ghonaim">Mariam Ghonaim</option>
                        <option value="Hussein Mahmoud">Hussein Mahmoud</option>
                        <option value="Ahmed Sabra">Ahmed Sabra</option>
                        <option value="Ahmed Alhefny">Ahmed Alhefny</option>
                        <option value="Aya Abulmagd">Aya Abulmagd</option>
                        <option value="Gehan Khaled">Gehan Khaled</option>
                        <option value="Salma Hafez">Salma Hafez</option>
                        <option value="Hend El Husseiny">Hend El Husseiny</option>
                        <option value="Salma Zaki">Salma Zaki</option>
                        <option value="Esraa Shahien">Esraa Shahien</option>
                      </select>
                    </div>

                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="ephemeralKeysCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">Ø¹Ø¯Ù… Ø­ÙØ¸ Ù…ÙØ§ØªÙŠØ­ API Ù…Ø­Ù„ÙŠÙ‹Ø§ (Ø¬Ù„Ø³Ø© Ù…Ø¤Ù‚ØªØ© ÙÙ‚Ø·)</span>
                        </label>
                    </div>
                    <div class="mb-3">
                        <label class="inline-flex items-center gap-2">
                            <input id="useTmCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2" checked
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© (TM)</span>
                        </label>
                        <div class="mt-1 mr-6 flex items-center gap-2">
                            <span id="tmStats" class="text-xs" style="color: var(--secondary-text);">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</span>
                            <button id="clearTmBtn" type="button" class="text-xs px-2 py-1 rounded hover:opacity-75" style="background-color: var(--error-color); color: white;">Ù…Ø³Ø­ Ø§Ù„Ø°Ø§ÙƒØ±Ø©</button>
                        </div>
                    </div>
                    <div class="mb-6">
                        <label class="inline-flex items-center gap-2">
                            <input id="useProofreadCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                                style="color: var(--primary-color);">
                            <span class="text-sm font-medium">ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚ Ø§Ù„Ù„ØºÙˆÙŠ Ø§Ù„Ø¢Ù„ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø©</span>
                        </label>
                    </div>

                    <div class="flex items-center justify-between mb-6 p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageSubjectsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">ğŸ“š Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„ØµÙÙˆÙ</button>
                    </div>

                    <div class="flex items-center justify-between p-3 rounded-lg"
                        style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                        <button id="manageIdsBtn" type="button" class="font-semibold"
                            style="color: var(--primary-color);">ğŸ†” Ø¥Ø¯Ø§Ø±Ø© Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (mapped_id)</button>
                    </div>
                </div>

                <div>
                    <div class="mb-4">
                        <label class="block mb-2 font-semibold">Ù…Ù„ÙØ§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (JSON):</label>
                        <div id="fileUpload"
                            class="border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition"
                            style="border-color: var(--input-border);">
                            <div style="color: var(--primary-color);" class="text-4xl mb-2">ğŸ“¤</div>
                            <p class="font-semibold">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                            <p class="text-sm mt-1" style="color: var(--secondary-text);">ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨ØµÙŠØºØ© JSON
                            </p>
                            <input type="file" id="fileInput" multiple accept=".json" class="hidden">
                        </div>
                    </div>
                    <div id="fileList" class="space-y-2 max-h-40 overflow-y-auto"></div>
                </div>
            </div>

            <button id="translateBtn"
                class="w-full text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none mt-8"
                style="background-color: var(--primary-color);">
                ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª (Ctrl + Enter)
            </button>
        </div>

        <div id="progressContainer" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6 text-center">
            <div class="w-16 h-16 border-4 border-dashed rounded-full animate-spin mx-auto"
                style="border-color: var (--primary-color); border-top-color: transparent;"></div>
            <p id="progressText" class="mt-4 text-lg font-semibold">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©...</p>
            <div class="mt-3">
                <button id="cancelTranslationBtn"
                    class="px-4 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600">Ø¥Ù„ØºØ§Ø¡</button>
            </div>
        </div>

        <div id="analyticsSection" class="hidden main-card p-6 rounded-2xl shadow-lg mb-6">
            <h3 class="text-2xl font-bold mb-4" style="color: var(--primary-color);">ğŸ“Š ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
            <div id="statsContainer" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center"></div>
        </div>

        <div id="previewSection" class="hidden">
            <div class="main-card p-4 rounded-2xl shadow-lg mb-6">
                <div class="flex flex-wrap gap-4 items-center justify-between">
                    <div>
                        <h3 class="text-2xl font-bold" style="color: var(--success-color);">Ø§Ù„Ø®Ø·ÙˆØ© 2: Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØªØ¹Ø¯ÙŠÙ„
                            Ø§Ù„ØªØ±Ø¬Ù…Ø©</h3>
                        <p class="mt-1" style="color: var(--secondary-text);">Ø±Ø§Ø¬Ø¹ Ø§Ù„ØªØ±Ø§Ø¬Ù…ØŒ Ø¹Ø¯Ù‘Ù„Ù‡Ø§ØŒ ÙˆÙ‚Ø§Ø±Ù†Ù‡Ø§ Ø¨Ø§Ù„Ù†Øµ
                            Ø§Ù„Ø£ØµÙ„ÙŠ.</p>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="undoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
                        <button id="redoBtn" disabled class="px-3 py-2 rounded-lg disabled:opacity-50">â†ªï¸ Ø¥Ø¹Ø§Ø¯Ø©</button>
                        <button id="openAnnotatorBtn" class="px-3 py-2 rounded-lg"
                            title="ØªØ­Ø±ÙŠØ± Ø§Ù„Ù†Øµ ÙÙˆÙ‚ Ø§Ù„ØµÙˆØ± (Ø£Ø±Ù‚Ø§Ù…/Ø±Ù…ÙˆØ²)">ğŸ–Šï¸ Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±</button>
                    </div>
                </div>
                <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© -->
                <div class="grid grid-cols-2 md:grid-cols-5 gap-3 my-4">
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--primary-color);" id="totalFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø­Ù‚ÙˆÙ„</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--success-color);" id="completedFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ù…ÙƒØªÙ…Ù„Ø©</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--warning-color);" id="editedFieldsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ù…Ø¹Ø¯Ù‘Ù„Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--error-color);" id="warningsCount">0</div>
                        <div class="text-xs" style="color: var(--secondary-text);">ØªØ­Ø°ÙŠØ±Ø§Øª</div>
                    </div>
                    <div class="p-3 rounded-lg text-center" style="background-color: var(--bg-color); border: 1px solid var(--card-border);">
                        <div class="text-2xl font-bold" style="color: var(--primary-color);" id="progressPercentage">0%</div>
                        <div class="text-xs" style="color: var(--secondary-text);">Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²</div>
                    </div>
                </div>

                <div class="preview-controls my-4 p-4 rounded-lg"
                    style="background-color: color-mix(in srgb, var(--primary-color) 5%, var(--card-bg));">
                    <!-- Ø§Ù„Ø¨Ø­Ø« -->
                    <div class="flex flex-wrap gap-4 items-center mb-3">
                        <div class="flex-grow">
                            <input type="text" id="searchPreview" placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ Ø£Ùˆ Ø§Ù„ØªØ±Ø¬Ù…Ø©..."
                                class="w-full p-2 border rounded-lg">
                        </div>
                    </div>
                    
                    <!-- Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3">
                        <select id="filterByType" class="p-2 border rounded-lg text-sm">
                            <option value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹</option>
                            <option value="mcq">Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ù…ØªØ¹Ø¯Ø¯</option>
                            <option value="input_box">ØµÙ†Ø¯ÙˆÙ‚ Ø¥Ø¯Ø®Ø§Ù„</option>
                            <option value="gap_match">Ù…Ù„Ø¡ Ø§Ù„ÙØ±Ø§ØºØ§Øª</option>
                            <option value="true_false">ØµØ­/Ø®Ø·Ø£</option>
                        </select>
                        
                        <select id="filterByStatus" class="p-2 border rounded-lg text-sm">
                            <option value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª</option>
                            <option value="translated">Ù…ØªØ±Ø¬Ù…Ø© Ø¢Ù„ÙŠØ§Ù‹</option>
                            <option value="edited">Ù…Ø¹Ø¯Ù‘Ù„Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹</option>
                            <option value="warnings">Ø¨Ù‡Ø§ ØªØ­Ø°ÙŠØ±Ø§Øª</option>
                        </select>
                        
                        <select id="sortBy" class="p-2 border rounded-lg text-sm">
                            <option value="default">Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ</option>
                            <option value="warnings">Ø§Ù„Ø£ÙƒØ«Ø± ØªØ­Ø°ÙŠØ±Ø§Øª</option>
                            <option value="longest">Ø§Ù„Ø£Ø·ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹</option>
                            <option value="shortest">Ø§Ù„Ø£Ù‚ØµØ± Ø£ÙˆÙ„Ø§Ù‹</option>
                        </select>
                        
                        <button id="clearFiltersBtn" class="p-2 border rounded-lg text-sm hover:bg-gray-100">
                            ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†
                        </button>
                    </div>
                    
                    <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© -->
                    <div class="flex flex-wrap gap-2">
                        <button id="validateAllBtn" class="text-xs px-3 py-2 rounded-lg" 
                                style="background-color: var(--primary-color); color: white;">
                            âœ“ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„
                        </button>
                        
                        <button id="expandAllBtn" class="text-xs px-3 py-2 rounded-lg border">
                            ğŸ“‚ ÙØªØ­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
                        </button>
                        
                        <button id="collapseAllBtn" class="text-xs px-3 py-2 rounded-lg border">
                            ğŸ“ Ø¥ØºÙ„Ø§Ù‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
                        </button>
                        
                        <button id="jumpToWarningsBtn" class="text-xs px-3 py-2 rounded-lg" 
                                style="background-color: var(--error-color); color: white;">
                            âš ï¸ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„ØªØ­Ø°ÙŠØ±Ø§Øª
                        </button>
                        
                        <button id="reviewModeBtn" class="text-xs px-3 py-2 rounded-lg border">
                            ğŸ‘ï¸ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©
                        </button>
                    </div>
                </div>
            </div>

            <div id="previewContainer" class="space-y-4"></div>

            <div class="main-card mt-8 p-4 rounded-2xl shadow-lg">
                <div class="flex items-center justify-center gap-4 mb-4">
                    <div class="text-center">
                        <p class="font-semibold mb-2">ØªØµØ¯ÙŠØ± Ø¨ØµÙŠØºØ© JSON</p>
                        <p class="text-sm" style="color: var(--secondary-text);">ÙŠØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®ØµØ§Ø¦Øµ ÙˆØ§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª</p>
                    </div>
                    <button id="exportBtn"
                        class="text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105"
                        style="background-color: var(--success-color);">
                        ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ±Ø¬Ù…Ø©
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals (Glossary, Mapped IDs, Subjects) -->
    <!-- Image Annotator Modal -->
    <div id="imageAnnotatorModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-4 w-full max-w-4xl">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-xl font-bold" style="color: var(--primary-color);">ØªØ­Ø±ÙŠØ± Ù†Øµ ÙÙˆÙ‚ Ø§Ù„ØµÙˆØ±Ø©</h3>
                <button id="imageAnnotatorClose" class="text-2xl">&times;</button>
            </div>
            <div class="w-full overflow-auto" style="max-height:70vh">
                <canvas id="imageAnnotatorCanvas" class="w-full border"
                    style="border-color: var(--card-border);"></canvas>
            </div>
            <div class="flex justify-end gap-2 mt-3">
                <button id="imageAnnotatorSave" class="px-4 py-2 rounded-lg text-white"
                    style="background-color: var(--success-color);">Ø­ÙØ¸</button>
            </div>
        </div>
    </div>
    <div id="mappedIdsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-2xl transform transition-all" role="dialog"
            aria-labelledby="mappedIdsTitle">
            <div class="flex justify-between items-center">
                <h3 id="mappedIdsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">Ø¥Ø¯Ø§Ø±Ø© Ù…Ø¹Ø±ÙØ§Øª
                    Ø§Ù„Ø£Ø³Ø¦Ù„Ø© (mapped_id)</h3>
                <button id="closeMappedIdsModalBtn" class="text-2xl hover:opacity-75"
                    aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø£Ø¯Ø®Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰
                Ø§Ù„Ø²Ø± Ù„Ø¬Ù„Ø¨Ù‡Ø§ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ØŒ Ø£Ùˆ Ø£Ù„ØµÙ‚Ù‡Ø§ ÙŠØ¯ÙˆÙŠØ§Ù‹.</p>
            <div class="flex gap-2 mb-4">
                <input type="number" id="mappedIdsCount" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¹Ø¯Ø¯"
                    class="p-2 border rounded-lg w-1/3 text-center">
                <button id="fetchMappedIdsBtn" class="flex-1 px-4 py-2 text-sm text-white rounded-lg"
                    style="background-color: var(--primary-color);">Ø¬Ù„Ø¨ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ù…Ù† Nagwa</button>
            </div>
            <textarea id="mappedIdsInput" rows="5" class="w-full p-2 rounded-lg mb-4"
                placeholder='["...","..."]'></textarea>
            <div class="flex items-center">
                <input id="useMappedIdsCheckbox" type="checkbox" class="h-4 w-4 rounded focus:ring-2"
                    style="color: var(--primary-color);">
                <label for="useMappedIdsCheckbox" class="mr-2 text-sm font-medium">ØªÙØ¹ÙŠÙ„ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ø¹Ù†Ø¯
                    Ø§Ù„ØªØµØ¯ÙŠØ±</label>
            </div>
        </div>
    </div>

    <div id="subjectsModal"
        class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-3xl transform transition-all" role="dialog"
            aria-labelledby="subjectsTitle">
            <div class="flex justify-between items-center">
                <h3 id="subjectsTitle" class="text-2xl font-bold" style="color: var(--primary-color);">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯
                    ÙˆØ§Ù„ØµÙÙˆÙ</h3>
                <button id="closeSubjectsModalBtn" class="text-2xl hover:opacity-75" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>
            </div>
            <p class="text-sm mt-1 mb-4" style="color: var(--secondary-text);">Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„ØµÙ Ù„ØªØ·Ø¨ÙŠÙ‚ ØªØ¹Ù„ÙŠÙ…Ø§Øª ØªØ±Ø¬Ù…Ø© Ù…Ø®ØµØµØ© ÙˆØ¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <select id="subjectSelect" class="p-2 border rounded-lg w-full"></select>
                <select id="gradeSelect" class="p-2 border rounded-lg w-full"></select>
            </div>
            <!-- âš ï¸ Math Grade Warning -->
            <div id="mathGradeWarning" style="display: none; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                <div style="display: flex; align-items: start; gap: 8px;">
                    <span style="font-size: 20px;">âš ï¸</span>
                    <div style="flex: 1;">
                        <strong style="color: #856404;">ØªÙ†Ø¨ÙŠÙ‡ Ù‡Ø§Ù… Ù„Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª:</strong>
                        <p style="margin: 4px 0 0 0; font-size: 14px; color: #856404;" id="mathGradeWarningText"></p>
                    </div>
                </div>
            </div>
            <h4 class="text-lg font-semibold mb-2">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª (Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª)</h4>
            <textarea id="promptPreview" rows="8" class="w-full p-2 rounded-lg mb-4" readonly></textarea>
            <button id="applyPromptBtn" class="w-full text-white font-bold py-2 px-4 rounded-lg"
                style="background-color: var(--success-color);">ØªØ·Ø¨ÙŠÙ‚ ÙˆØ­ÙØ¸</button>
        </div>
    </div>

    <script>

        const GOOGLE_SHEET_ID = '16-ant77j9ckFE7y48mOaqmMvUQrx8ZzM-ksWHaFNSUU';

        const TranslatorApp = {
            constants: {
                BATCH_SEPARATOR: "\\n|||---|||\\n",
                CONTEXT_SEPARATOR: "\\n<SEP>\\n",
                HISTORY_MAX: 20,
                CHUNK_SIZE: 40
            },

            state: {
                selectedFilesInfo: [],
                originalJsonData: [],
                translatedJsonData: [],
                initialTranslatedJsonData: [],
                activeScreen: 'setup',
                translationCache: new Map(),
                startTime: null,
                hasUnsavedChanges: false,
                selectedSubject: 'None',
                selectedGrade: 'None',
                fileStore: new Map(),
                isTranslating: false,
                translators: {
                  "Aya Abulmagd": "643164068106",
                  "Salma Hafez": "927169194769",
                  "Hend El Husseiny": "805189370751",
                  "Salma Zaki": "698106520137",
                  "Esraa Shahien": "937145789737",
                  "Fatema Samy": "719130548578",
                  "Samar Bahaaeldin": "694164363692",
                  "Lobna Adel": "925171517156",
                  "Shady Donia": "963163430437",
                  "Zeina Elsheikh": "154106968213",
                  "Aiat Saied": "942130798452",
                  "Monica Sidhom": "819178319024",
                  "Yara Sobhy": "618146184254",
                  "Mariam Ghonaim": "182136230818",
                  "Hussein Mahmoud": "676130390838",
                  "Gehan Khaled": "475149294140",
                  "Ahmed Sabra": "175196786128",
                  "Ahmed Alhefny": "120171982460"
                    },
                selectedTranslator: "",
            },

            dom: {},

            init() {
                try {
                    this.cacheDomElements();
                    this.bindEvents();
                    this.theme.init();
                    this.history.init();
                    this.subjects.init();
                    this.translationMemory.init();
                    this.session.load();
                    this.shortcuts.init();
                    this.autoSave.init();
                    this.addBeforeUnloadGuard();
                    // --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Phase 1, Task 4 & 5) ---
                    
                    // Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¥Ø¶Ø§ÙØ© Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ù„Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø§Ù„Ù„ØºØ©
                    try {
                        const keyboardObserver = new MutationObserver((mutations, observer) => {
                            for (const mutation of mutations) {
                                if (mutation.addedNodes.length > 0) {
                                    const keyboard = document.querySelector('.ML__keyboard');
                                    if (keyboard && !keyboard.querySelector('.lang-toggle-btn')) {
                                        console.log('âŒ¨ï¸ [Keyboard] Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø¸Ù‡Ø±ØªØŒ Ø¬Ø§Ø±ÙŠ Ø¥Ø¶Ø§ÙØ© Ø²Ø± Ø§Ù„Ù„ØºØ©...');
                                        const btn = document.createElement('button');
                                        btn.textContent = 'Ø¹Ø±Ø¨ÙŠ / EN';
                                        btn.className = 'lang-toggle-btn';
                                        btn.style.cssText = `
                                            position: absolute; top: 5px; right: 170px; padding: 5px 10px;
                                            font-size: 14px; font-weight: bold; background-color: #555;
                                            color: white; border: 1px solid #777; border-radius: 6px;
                                            cursor: pointer; z-index: 100;
                                        `;
                                        btn.onclick = () => TranslatorApp.utils.mathLive.toggleLanguage();
                                        keyboard.appendChild(btn);
                                    }
                                }
                            }
                        });
                        keyboardObserver.observe(document.body, { childList: true, subtree: true });
                    } catch (e) {
                        console.error("ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ù…Ø±Ø§Ù‚Ø¨ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­:", e);
                    }
                    
                    // Ù…Ø±Ø§Ù‚Ø¨Ø© Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ù„ØªÙ‡ÙŠØ¦Ø© MathLive
                    try {
                        const previewObserver = new MutationObserver((mutations) => {
                            let needsRescan = false;
                            for (const mutation of mutations) {
                                if (mutation.addedNodes.length > 0) {
                                    // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ù…Ø¶Ø§ÙØ© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ math-field
                                    mutation.addedNodes.forEach(node => {
                                        if (node.nodeType === 1 && (node.tagName === 'MATH-FIELD' || node.querySelector('math-field'))) {
                                            needsRescan = true;
                                        }
                                    });
                                }
                            }
                            if (needsRescan) {
                                console.log('ğŸ”„ [MutationObserver] ØªÙ… Ø§ÙƒØªØ´Ø§Ù ÙˆØ³ÙˆÙ… math-field Ø¬Ø¯ÙŠØ¯Ø©ØŒ Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø³Ø­...');
                                if (window.rescanMathElements) {
                                    window.rescanMathElements();
                                } else {
                                    console.warn('window.rescanMathElements ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø¨Ø¹Ø¯.');
                                }
                            }
                        });
                        // Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¹Ù„Ù‰ Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙ… Ù‡Ø°Ø§ Ø¨Ø¹Ø¯ cacheDomElements)
                        if (this.dom.previewContainer) {
                            previewObserver.observe(this.dom.previewContainer, { childList: true, subtree: true });
                        } else {
                            console.error("Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (previewContainer) ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¹Ù†Ø¯ ØªÙ‡ÙŠØ¦Ø© Observer.");
                        }
                    } catch (e) {
                        console.error("ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©:", e);
                    }
                    
                    // --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                    
                    // Initialize shared MathLive virtual keyboard if available
                    try {
                        if (window.MathfieldElement) {
                            // Configure MathLive defaults
                            if (window.MathfieldElement.defaultConfig) {
                                window.MathfieldElement.defaultConfig = {
                                    ...window.MathfieldElement.defaultConfig,
                                    virtualKeyboardMode: 'onfocus',
                                    virtualKeyboardTheme: 'material',
                                    virtualKeyboards: 'numeric symbols greek',
                                    inlineShortcuts: true,
                                    smartMode: true,
                                    smartFence: true,
                                    smartSuperscript: true,
                                    keypressVibration: true,
                                };
                            }
                            
                            // Create shared virtual keyboard
                            if (typeof MathfieldElement.makeSharedVirtualKeyboard === 'function') {
                                MathfieldElement.makeSharedVirtualKeyboard();
                            }
                        }
                    } catch (mathError) {
                        console.warn('MathLive initialization error:', mathError);
                    }
                    
                    // Validate translation requirements on init (disable translate button initially)
                    setTimeout(() => {
                        this.validateTranslationRequirements();
                    }, 100);
                } catch (error) {
                    console.error('Application initialization error:', error);
                    TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©.', 'error');
                }
            },

            cacheDomElements() {
                try {
                    const ids = {
                        alertContainer: 'alertContainer', newSessionBtn: 'newSessionBtn',
                        fileUpload: 'fileUpload', fileInput: 'fileInput', fileList: 'fileList',
                        translateBtn: 'translateBtn', geminiKeyInput: 'geminiKey', chatgptKeyInput: 'chatgptKey',
                        geminiKeyGroup: 'geminiKeyGroup', chatgptKeyGroup: 'chatgptKeyGroup',
                        localModelGroup: 'localModelGroup', localModelUrl: 'localModelUrl', localModelName: 'localModelName',
                        setupSection: 'setupSection', progressContainer: 'progressContainer', progressText: 'progressText',
                        previewSection: 'previewSection', previewContainer: 'previewContainer', exportBtn: 'exportBtn',
                        themeToggle: 'theme-toggle', analyticsSection: 'analyticsSection',
                        statsContainer: 'statsContainer',
                        searchPreview: 'searchPreview', undoBtn: 'undoBtn', redoBtn: 'redoBtn',
                        imageAnnotatorModal: 'imageAnnotatorModal',
                        imageAnnotatorCanvas: 'imageAnnotatorCanvas',
                        imageAnnotatorClose: 'imageAnnotatorClose',
                        imageAnnotatorSave: 'imageAnnotatorSave',
                        mappedIdsInput: 'mappedIdsInput', useMappedIdsCheckbox: 'useMappedIdsCheckbox',
                        manageIdsBtn: 'manageIdsBtn', mappedIdsModal: 'mappedIdsModal',
                        closeMappedIdsModalBtn: 'closeMappedIdsModalBtn',
                        mappedIdsCount: 'mappedIdsCount', fetchMappedIdsBtn: 'fetchMappedIdsBtn',
                        manageSubjectsBtn: 'manageSubjectsBtn', subjectsModal: 'subjectsModal',
                        closeSubjectsModalBtn: 'closeSubjectsModalBtn', subjectSelect: 'subjectSelect',
                        gradeSelect: 'gradeSelect', promptPreview: 'promptPreview', applyPromptBtn: 'applyPromptBtn',
                        cancelTranslationBtn: 'cancelTranslationBtn', saveIndicator: 'saveIndicator',
                        ephemeralKeysCheckbox: 'ephemeralKeysCheckbox',
                        useTmCheckbox: 'useTmCheckbox', useProofreadCheckbox: 'useProofreadCheckbox', translatorSelect: 'translatorSelect',
                        tmStats: 'tmStats', clearTmBtn: 'clearTmBtn',
                        totalFieldsCount: 'totalFieldsCount', completedFieldsCount: 'completedFieldsCount',
                        editedFieldsCount: 'editedFieldsCount', warningsCount: 'warningsCount', progressPercentage: 'progressPercentage',
                        filterByType: 'filterByType', filterByStatus: 'filterByStatus', sortBy: 'sortBy', clearFiltersBtn: 'clearFiltersBtn',
                        validateAllBtn: 'validateAllBtn', expandAllBtn: 'expandAllBtn', collapseAllBtn: 'collapseAllBtn',
                        jumpToWarningsBtn: 'jumpToWarningsBtn', reviewModeBtn: 'reviewModeBtn'
                    };
                    for (const k in ids) {
                        try {
                            this.dom[k] = document.getElementById(ids[k]);
                            if (!this.dom[k] && k !== 'glossaryCategory') {
                                console.warn(`DOM element not found: ${k}`);
                            }
                        } catch (elementError) {
                            console.warn(`Error caching DOM element ${k}:`, elementError);
                        }
                    }
                    this.dom.apiProviderRadios = document.querySelectorAll('input[name="apiProvider"]');
                } catch (error) {
                    console.error('Cache DOM elements error:', error);
                    throw new Error('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
                }
            },

            bindEvents() {
                try {
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            if (e.target.classList.contains('editable-unit')) {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handleUnitUpdate(fieldContainer, e.target.textContent);
                                }
                            } else {
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    this.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                            }
                        } catch (error) {
                            console.error('Preview input event error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        // Protect math-fields from accidental deletion
                        if (e.key === 'Backspace' || e.key === 'Delete') {
                            const selection = window.getSelection();
                            if (!selection.rangeCount) return;

                            const range = selection.getRangeAt(0);
                            const focusNode = range.startContainer;
                            
                            // Check if we're inside a math-field
                            const parentMathField = focusNode.parentNode?.closest('math-field');
                            
                            // Only delete math-field if it's empty AND user is inside it
                            if (parentMathField && parentMathField.value.trim() === '') {
                                e.preventDefault();
                                const fieldContainer = parentMathField.closest('.editable-preview-field');
                                parentMathField.remove();
                                if (fieldContainer) {
                                    TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                                return;
                            }
                            
                            // Prevent deletion of math-field when deleting adjacent text
                            const editableField = focusNode.parentNode?.closest('.editable-preview-field');
                            if (!editableField) return;
                            
                            // Enhanced protection: Check all possible sibling scenarios
                            if (e.key === 'Backspace') {
                                // Check direct previous sibling
                                const prevSibling = range.startContainer.previousSibling;
                                // Check if parent's previous sibling is math-field
                                const parentPrevSibling = range.startContainer.parentNode?.previousSibling;
                                
                                if ((prevSibling?.tagName === 'MATH-FIELD' && range.startOffset === 0) ||
                                    (parentPrevSibling?.tagName === 'MATH-FIELD' && range.startOffset === 0)) {
                                    // Place cursor before math-field instead of deleting it
                                    e.preventDefault();
                                    const mathField = prevSibling?.tagName === 'MATH-FIELD' ? prevSibling : parentPrevSibling;
                                    const newRange = document.createRange();
                                    newRange.setStartBefore(mathField);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                    return;
                                }
                            } else if (e.key === 'Delete') {
                                // Check direct next sibling
                                const nextSibling = range.startContainer.nextSibling;
                                // Check if parent's next sibling is math-field
                                const parentNextSibling = range.startContainer.parentNode?.nextSibling;
                                
                                if (nextSibling?.tagName === 'MATH-FIELD' || parentNextSibling?.tagName === 'MATH-FIELD') {
                                    // Place cursor after math-field instead of deleting it
                                    e.preventDefault();
                                    const mathField = nextSibling?.tagName === 'MATH-FIELD' ? nextSibling : parentNextSibling;
                                    const newRange = document.createRange();
                                    newRange.setStartAfter(mathField);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                    return;
                                }
                            }
                        }
                    }, true);
                    
                    this.dom.newSessionBtn.addEventListener('click', (e) => {
                        try {
                            this.session.clear.bind(this.session)();
                        } catch (error) {
                            console.error('New session error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©.', 'error');
                        }
                    });
                    this.dom.apiProviderRadios.forEach(radio => radio.addEventListener('change', (e) => {
                        try {
                            this.events.onApiProviderChange.bind(this)(e);
                        } catch (error) {
                            console.error('API provider radio change error:', error);
                        }
                    }));
                    this.dom.fileUpload.addEventListener('click', (e) => {
                        try {
                            this.dom.fileInput.click();
                        } catch (error) {
                            console.error('File upload click error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('dragover', (e) => {
                        try {
                            this.events.onDragOver(e);
                        } catch (error) {
                            console.error('Drag over error:', error);
                        }
                    });
                    this.dom.previewContainer.addEventListener('keydown', (e) => {
                        try {
                            const isEditable = e.target.closest('.editable-preview-field');
                            if (!isEditable) return;
                    
                            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm') {
                                e.preventDefault();
                                const selection = window.getSelection();
                                if (!selection.rangeCount) return;
                                const range = selection.getRangeAt(0);
                                
                                // Create a new math-field element
                                const newMathField = document.createElement('math-field');
                                newMathField.setAttribute('default-mode', 'inline-math');
                                newMathField.setAttribute('value', '');
                                newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                newMathField.setAttribute('dir', 'ltr');
                                newMathField.setAttribute('locale', 'ar');
                                
                                // Insert the new math field
                                range.insertNode(newMathField);
                                
                                // Focus the cursor inside the new math field
                                newMathField.focus();
                    
                                TranslatorApp.preview.handlePreviewFieldUpdate(isEditable);
                            }
                        } catch (error) {
                            console.error('Math field shortcut error:', error);
                        }
                    }, true); // Use `true` for capture phase to ensure it runs before other handlers
                    
                    this.dom.fileUpload.addEventListener('dragleave', (e) => {
                        try {
                            this.events.onDragLeave(e);
                        } catch (error) {
                            console.error('Drag leave error:', error);
                        }
                    });
                    this.dom.fileUpload.addEventListener('drop', (e) => {
                        try {
                            this.events.onFileDrop.bind(this)(e);
                        } catch (error) {
                            console.error('File drop error:', error);
                        }
                    });
                    this.dom.fileInput.addEventListener('change', (e) => {
                        try {
                            this.events.onFileSelect.bind(this)(e);
                        } catch (error) {
                            console.error('File input change error:', error);
                        }
                    });
                    this.dom.translateBtn.addEventListener('click', (e) => {
                        try {
                            this.startTranslationProcess.bind(this)();
                        } catch (error) {
                            console.error('Start translation error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø©.', 'error');
                        }
                    });
                    this.dom.cancelTranslationBtn.addEventListener('click', (e) => {
                        try {
                            this.api.cancel.bind(this.api)();
                        } catch (error) {
                            console.error('Cancel translation error:', error);
                        }
                    });
                    this.dom.exportBtn.addEventListener('click', (e) => {
                        try {
                            this.export.exportAs('json');
                        } catch (error) {
                            console.error('Export error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                        }
                    });
                    
                    // New feature: Expand/Collapse All
                    this.dom.expandAllBtn?.addEventListener('click', () => {
                        try {
                            document.querySelectorAll('.accordion-content').forEach(content => {
                                content.style.maxHeight = content.scrollHeight + "px";
                                const parent = content.closest('.preview-card');
                                if (parent) parent.classList.add('open');
                            });
                        } catch (error) {
                            console.error('Expand all error:', error);
                        }
                    });
                    
                    this.dom.collapseAllBtn?.addEventListener('click', () => {
                        try {
                            document.querySelectorAll('.accordion-content').forEach(content => {
                                content.style.maxHeight = null;
                                const parent = content.closest('.preview-card');
                                if (parent) parent.classList.remove('open');
                            });
                        } catch (error) {
                            console.error('Collapse all error:', error);
                        }
                    });
                    
                    // Jump to warnings
                    this.dom.jumpToWarningsBtn?.addEventListener('click', () => {
                        try {
                            const firstWarning = document.querySelector('.field-error, .field-warning');
                            if (firstWarning) {
                                firstWarning.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                firstWarning.style.animation = 'pulse 1s ease-in-out 3';
                            } else {
                                TranslatorApp.ui.showAlert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø°ÙŠØ±Ø§Øª', 'success', 2000);
                            }
                        } catch (error) {
                            console.error('Jump to warnings error:', error);
                        }
                    });
                    
                    // Validate all fields
                    this.dom.validateAllBtn?.addEventListener('click', () => {
                        try {
                            TranslatorApp.preview.validateAllFields();
                        } catch (error) {
                            console.error('Validate all error:', error);
                        }
                    });
                    
                    // Review mode toggle
                    this.dom.reviewModeBtn?.addEventListener('click', () => {
                        try {
                            const previewSection = document.getElementById('previewSection');
                            previewSection?.classList.toggle('review-mode');
                            const isReviewMode = previewSection?.classList.contains('review-mode');
                            this.dom.reviewModeBtn.textContent = isReviewMode ? 'âœ“ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©' : 'ğŸ‘ï¸ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©';
                        } catch (error) {
                            console.error('Review mode toggle error:', error);
                        }
                    });
                    
                    // Filters
                    this.dom.filterByType?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Filter by type error:', error);
                        }
                    });
                    
                    this.dom.filterByStatus?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Filter by status error:', error);
                        }
                    });
                    
                    this.dom.sortBy?.addEventListener('change', () => {
                        try {
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Sort by error:', error);
                        }
                    });
                    
                    this.dom.clearFiltersBtn?.addEventListener('click', () => {
                        try {
                            if (this.dom.filterByType) this.dom.filterByType.value = 'all';
                            if (this.dom.filterByStatus) this.dom.filterByStatus.value = 'all';
                            if (this.dom.sortBy) this.dom.sortBy.value = 'default';
                            TranslatorApp.preview.applyFilters();
                        } catch (error) {
                            console.error('Clear filters error:', error);
                        }
                    });
                    this.dom.geminiKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Gemini key input error:', error);
                        }
                    });
                    this.dom.chatgptKeyInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('ChatGPT key input error:', error);
                        }
                    });
                    this.dom.localModelUrl.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model URL input error:', error);
                        }
                    });
                    this.dom.localModelName.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Local model name input error:', error);
                        }
                    });
                    this.dom.themeToggle.addEventListener('click', (e) => {
                        try {
                            this.theme.toggle.bind(this.theme)();
                        } catch (error) {
                            console.error('Theme toggle error:', error);
                        }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                    this.dom.ephemeralKeysCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Ephemeral keys checkbox error:', error);
                        }
                    });
                    this.dom.useTmCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            this.translationMemory.updateUI();
                        } catch (error) {
                            console.error('Use TM checkbox error:', error);
                        }
                    });
                    this.dom.useProofreadCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                        } catch (error) {
                            console.error('Use proofread checkbox error:', error);
                        }
                    });
                    
                    this.dom.clearTmBtn.addEventListener('click', (e) => {
                        try {
                            this.ui.showConfirmModal(
                                'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©ØŸ Ù„Ù† ØªØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ¹Ø§Ø¯ØªÙ‡Ø§ Ø¨Ø¹Ø¯ Ø§Ù„Ø­Ø°Ù.',
                                () => { // Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø³ØªÙÙ†ÙØ° ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ "ØªØ£ÙƒÙŠØ¯"
                                this.translationMemory.clear();
                                this.translationMemory.updateUI();
                                this.ui.showAlert('ØªÙ… Ù…Ø³Ø­ Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
                            }
                            );
                        } catch (error) {
                            console.error('Clear TM error:', error);
                        }
                    });

                    this.dom.searchPreview.addEventListener('input', (e) => {
                        try {
                            this.preview.applyFilters.bind(this.preview)(); // âœ… Ø§Ø³Ù… Ø¬Ø¯ÙŠØ¯
                        } catch (error) {
                            console.error('Search preview error:', error);
                        }
                    });
                    this.dom.undoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.undo.bind(this.history)();
                        } catch (error) {
                            console.error('Undo error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªØ±Ø§Ø¬Ø¹.', 'error');
                        }
                    });
                    this.dom.redoBtn.addEventListener('click', (e) => {
                        try {
                            this.history.redo.bind(this.history)();
                        } catch (error) {
                            console.error('Redo error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø©.', 'error');
                        }
                    });

                    this.dom.manageIdsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(true);
                        } catch (error) {
                            console.error('Show mapped IDs modal error:', error);
                        }
                    });
                    this.dom.closeMappedIdsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showMappedIdsModal(false);
                        } catch (error) {
                            console.error('Close mapped IDs modal error:', error);
                        }
                    });
                    this.dom.fetchMappedIdsBtn.addEventListener('click', (e) => {
                        try {
                            this.mappedIds.fetch.bind(this.mappedIds)();
                        } catch (error) {
                            console.error('Fetch mapped IDs error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª.', 'error');
                        }
                    });

                    this.dom.manageSubjectsBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(true);
                        } catch (error) {
                            console.error('Show subjects modal error:', error);
                        }
                    });
                    this.dom.closeSubjectsModalBtn.addEventListener('click', () => {
                        try {
                            this.ui.showSubjectsModal(false);
                        } catch (error) {
                            console.error('Close subjects modal error:', error);
                        }
                    });
                    this.dom.subjectSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onSubjectChange.bind(this.subjects)();
                            // Check if all required fields are selected
                            TranslatorApp.validateTranslationRequirements();
                        } catch (error) {
                            console.error('Subject change error:', error);
                        }
                    });
                    this.dom.gradeSelect.addEventListener('change', (e) => {
                        try {
                            this.subjects.onGradeChange.bind(this.subjects)();
                            // Check if all required fields are selected
                            TranslatorApp.validateTranslationRequirements();
                        } catch (error) {
                            console.error('Grade change error:', error);
                        }
                    });
                    this.dom.applyPromptBtn.addEventListener('click', (e) => {
                        try {
                            this.subjects.apply.bind(this.subjects)();
                        } catch (error) {
                            console.error('Apply prompt error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.', 'error');
                        }
                    });

                    // Image annotator events
                    const openAnnotatorBtn = document.getElementById('openAnnotatorBtn');
                    if (openAnnotatorBtn) {
                        openAnnotatorBtn.addEventListener('click', (e) => {
                            try {
                                this.annotator.open.bind(this.annotator)();
                            } catch (error) {
                                console.error('Open annotator error:', error);
                                TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ÙØªØ­ Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±.', 'error');
                            }
                        });
                    }
                    this.dom.imageAnnotatorClose.addEventListener('click', (e) => {
                        try {
                            this.annotator.close.bind(this.annotator)();
                        } catch (error) {
                            console.error('Close annotator error:', error);
                        }
                    });
                    this.dom.imageAnnotatorSave.addEventListener('click', (e) => {
                        try {
                            this.annotator.save.bind(this.annotator)();
                        } catch (error) {
                            console.error('Save annotator error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©.', 'error');
                        }
                    });

                    // Event delegation for all preview field updates
                    this.dom.previewContainer.addEventListener('input', (e) => {
                        try {
                            const fieldContainer = e.target.closest('.editable-preview-field');
                            if (fieldContainer) {
                                this.preview.handlePreviewFieldUpdate(fieldContainer);
                            }
                        } catch (error) {
                            console.error('Preview field update error:', error);
                        }
                    });

                    // --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (MathField Change Event) ---
                    // Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ø­Ø¯Ø« change Ø¹Ù„Ù‰ Ø¹Ù†Ø§ØµØ± math-field Ù„Ø¶Ù…Ø§Ù† Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
                    this.dom.previewContainer.addEventListener('change', (e) => {
                        try {
                            // ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø­Ø¯Ø« Ø¬Ø§Ø¡ Ù…Ù† Ø¹Ù†ØµØ± math-field
                            if (e.target.tagName === 'MATH-FIELD') {
                                // Ø§Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù€ div Ø§Ù„Ø£Ø¨ Ø§Ù„Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„
                                const fieldContainer = e.target.closest('.editable-preview-field');
                                if (fieldContainer) {
                                    console.log('ğŸ”„ [MathField Change Event] ØªÙ… Ø§ÙƒØªØ´Ø§Ù ØªØºÙŠÙŠØ± ÙÙŠ math-fieldØŒ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ù‚Ù„:', fieldContainer.dataset.path);
                                    // Ø´ØºÙ„ Ù†ÙØ³ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù„ÙŠ ÙƒØ§Ù†Øª Ø¨ØªØ´ØªØºÙ„ Ù…Ø¹ Ø­Ø¯Ø« input
                                    this.preview.handlePreviewFieldUpdate(fieldContainer);
                                }
                            }
                        } catch (error) {
                            console.error('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø« change Ù„Ø¹Ù†ØµØ± math-field:', error);
                        }
                    });
                    // --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                    this.dom.previewContainer.addEventListener('copy', (e) => {
                        try {
                            this.preview.handleCopyEvent(e);
                        } catch (error) {
                            console.error('Copy event error:', error);
                        }
                    });

                    this.dom.previewContainer.addEventListener('paste', (e) => {
                        try {
                            this.preview.handlePasteEvent(e);
                        } catch (error) {
                            console.error('Paste event error:', error);
                        }
                    });
                    
                    // Ensure MathLive keyboard opens for inline chemistry/math on focus
                    this.dom.previewContainer.addEventListener('pointerdown', (e) => {
                        try {
                            const mf = e.target && e.target.closest && e.target.closest('math-field');
                            if (mf) {
                                try {
                                    mf.removeAttribute('read-only');
                                    mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                    mf.setAttribute('use-shared-virtual-keyboard', '');
                                    if (typeof mf.executeCommand === 'function') {
                                        setTimeout(() => {
                                            try {
                                                mf.executeCommand('showVirtualKeyboard');
                                                mf.focus();
                                            } catch (err) {
                                                console.warn('MathLive keyboard error:', err);
                                            }
                                        }, 100);
                                    }
                                    e.stopPropagation();
                                } catch (err) {
                                    console.warn('MathLive setup error:', err);
                                }
                            }
                        } catch (error) {
                            console.error('MathLive pointerdown error:', error);
                        }
                    });
                    this.dom.translatorSelect.addEventListener('change', (e) => {
                      try {
                        const selectedName = e.target.value;
                        // Update the global state with the selected translator's name
                        TranslatorApp.state.selectedTranslator = selectedName;
                        TranslatorApp.state.hasUnsavedChanges = true;
                        
                        // Check if all required fields are selected
                        TranslatorApp.validateTranslationRequirements();
                        
                        if (selectedName) {
                          const sourceId = TranslatorApp.state.translators[selectedName];
                          TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØªØ±Ø¬Ù…: ${selectedName} (ID: ${sourceId}).`, 'info', 3000);
                        } else {
                          TranslatorApp.ui.showAlert('Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…ØªØ±Ø¬Ù…. Ù„Ù† ØªØªÙ… Ø¥Ø¶Ø§ÙØ© source_id.', 'warning', 3000);
                        }
                      } catch (error) {
                          console.error('Translator select change error:', error);
                          TranslatorApp.ui.showAlert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØªØ±Ø¬Ù….', 'error');
                      }
                    });
                    this.dom.mappedIdsInput.addEventListener('input', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show the new mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Mapped IDs input error:', error);
                        }
                    });
                    this.dom.useMappedIdsCheckbox.addEventListener('change', (e) => {
                        try {
                            this.state.hasUnsavedChanges = true;
                            // Re-render the preview to show/hide the mapped ID
                            this.preview.render();
                        } catch (error) {
                            console.error('Use mapped IDs checkbox error:', error);
                        }
                    });
                } catch (error) {
                    console.error('bindEvents error:', error);
                    try { TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø±Ø¨Ø· Ø§Ù„Ø£Ø­Ø¯Ø§Ø«.', 'error'); } catch { }
                }
            },

            events: {
                onApiProviderChange(e) {
                    try {
                        const provider = e.target.value;
                        TranslatorApp.dom.geminiKeyGroup.classList.toggle('hidden', provider !== 'gemini');
                        TranslatorApp.dom.chatgptKeyGroup.classList.toggle('hidden', provider !== 'chatgpt');
                        TranslatorApp.dom.localModelGroup.classList.toggle('hidden', provider !== 'local');
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('API provider change error:', error);
                    }
                },
                onDragOver(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.add('dragover');
                    } catch (error) {
                        console.error('Drag over error:', error);
                    }
                },
                onDragLeave(e) {
                    try {
                        e.preventDefault();
                        e.currentTarget.classList.remove('dragover');
                    } catch (error) {
                        console.error('Drag leave error:', error);
                    }
                },
                onFileDrop(e) {
                    try {
                        e.preventDefault();
                        TranslatorApp.dom.fileUpload.classList.remove('dragover');
                        TranslatorApp.fileHandler.addFiles(e.dataTransfer.files);
                    } catch (error) {
                        console.error('File drop error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                    }
                },
                onFileSelect(e) {
                    try {
                        TranslatorApp.fileHandler.addFiles(e.target.files);
                    } catch (error) {
                        console.error('File select error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                    }
                }
            },

            theme: {
                init() {
                    const savedTheme = localStorage.getItem('translatorTheme') || 'light';
                    this.set(savedTheme);
                },
                toggle() {
                    const current = document.documentElement.getAttribute('data-theme');
                    this.set(current === 'dark' ? 'light' : 'dark');
                },
                set(themeName) {
                    document.documentElement.setAttribute('data-theme', themeName);
                    localStorage.setItem('translatorTheme', themeName);
                    TranslatorApp.dom.themeToggle.textContent = themeName === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
                }
            },

            shortcuts: {
                init() {
                    document.addEventListener('keydown', (e) => {
                        try {
                            if (e.ctrlKey || e.metaKey) {
                                const isEditable = e.target.closest('[contenteditable="true"]');
                                const isMathField = e.target.closest('math-field');
                                if (isEditable || isMathField) {
                                    return; // Exit and let the browser's native undo handle it.
                                }
                                switch (e.key.toLowerCase()) {
                                    case 's':
                                        e.preventDefault();
                                        TranslatorApp.session.save();
                                        TranslatorApp.ui.setSaveIndicator('saved');
                                        break;
                                    case 'o':
                                        e.preventDefault();
                                        TranslatorApp.dom.fileInput.click();
                                        break;
                                    case 'enter':
                                        if (TranslatorApp.state.activeScreen === 'setup') {
                                            e.preventDefault();
                                            TranslatorApp.dom.translateBtn.click();
                                        }
                                        break;
                                    case 'z':
                                        e.preventDefault();
                                        TranslatorApp.history.undo();
                                        break;
                                    case 'y':
                                        e.preventDefault();
                                        TranslatorApp.history.redo();
                                        break;
                                    case 'm':
                                    case 'M': // Support both lowercase and uppercase
                                        if (isEditable) {
                                            e.preventDefault();
                                            const selection = window.getSelection();
                                            if (!selection.rangeCount) return;
                                            const range = selection.getRangeAt(0);
                                    
                                            // Create and configure a new math-field element
                                            const newMathField = document.createElement('math-field');
                                            newMathField.setAttribute('default-mode', 'inline-math');
                                            newMathField.setAttribute('value', '');
                                            newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                            newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                            newMathField.setAttribute('dir', 'ltr');
                                            newMathField.setAttribute('locale', 'ar');
                                            
                                            // Insert math field
                                            range.insertNode(newMathField);
                                            
                                            // Add a zero-width space after the math field to allow cursor placement
                                            const zwsp = document.createTextNode('\u200B');
                                            newMathField.parentNode.insertBefore(zwsp, newMathField.nextSibling);
                                            
                                            // Place cursor inside the new math field
                                            newMathField.focus();
                                    
                                            TranslatorApp.preview.handlePreviewFieldUpdate(isEditable.closest('.editable-preview-field'));
                                        }
                                        break;
                                }
                            }

                            // MathLive language toggle shortcut (Alt + L)
                            if (e.ctrlKey && e.altKey && e.key === 'k') {
                                e.preventDefault();
                                TranslatorApp.utils.mathLive.toggleLanguage();
                            }

                            // Alt+M as alternative for inserting math field (for keyboards where Ctrl+M doesn't work)
                            if (e.altKey && !e.ctrlKey && (e.key === 'm' || e.key === 'M')) {
                                const isEditable = e.target.closest('.editable-preview-field');
                                if (isEditable && isEditable.isContentEditable) {
                                    e.preventDefault();
                                    const selection = window.getSelection();
                                    if (!selection.rangeCount) return;
                                    const range = selection.getRangeAt(0);
                            
                                    // Create and configure a new math-field element
                                    const newMathField = document.createElement('math-field');
                                    newMathField.setAttribute('default-mode', 'inline-math');
                                    newMathField.setAttribute('value', '');
                                    newMathField.setAttribute('virtual-keyboard-mode', 'onfocus');
                                    newMathField.setAttribute('use-shared-virtual-keyboard', '');
                                    newMathField.setAttribute('dir', 'ltr');
                                    newMathField.setAttribute('locale', 'ar');
                                    
                                    // Insert math field
                                    range.insertNode(newMathField);
                                    
                                    // Add a zero-width space after the math field to allow cursor placement
                                    const zwsp = document.createTextNode('\u200B');
                                    newMathField.parentNode.insertBefore(zwsp, newMathField.nextSibling);
                                    
                                    // Place cursor inside the new math field
                                    newMathField.focus();
                            
                                    TranslatorApp.preview.handlePreviewFieldUpdate(isEditable.closest('.editable-preview-field'));
                                }
                            }

                        } catch (error) {
                            console.error('Shortcut error:', error);
                        }
                    });
                }
            },

            addBeforeUnloadGuard() {
                window.addEventListener('beforeunload', (e) => {
                    try {
                        if (TranslatorApp.state.hasUnsavedChanges) {
                            e.preventDefault();
                            e.returnValue = '';
                        }
                    } catch (error) {
                        console.error('Before unload error:', error);
                    }
                });
            },

            utils: {
                collectAllTextsFromFiles(filesArr) {
                    const bag = new Set();
                    const toPlain = (html) => {
                        if (typeof html !== 'string') return '';
                        const div = document.createElement('div');
                        div.innerHTML = html;
                        return (div.textContent || div.innerText || '').trim();
                    };

                    const traverse = (obj) => {
                        if (!obj) return;
                        if (Array.isArray(obj)) {
                            obj.forEach(item => traverse(item));
                        } else if (typeof obj === 'object') {
                            Object.keys(obj).forEach(key => {
                                const value = obj[key];
                                // **IMPROVEMENT**: More specific keys to check for translatable content
                                const translatableKeys = ['stem', 'html_content', 'answer', 'statement', 'student_answer', 'comment'];
                                if (translatableKeys.includes(key) && typeof value === 'string') {
                                    const plain = toPlain(value);
                                    if (plain) bag.add(plain);
                                } else if (key === 'gap_text_keys' && Array.isArray(value)) {
                                    value.forEach(item => {
                                        if (item && typeof item.value === 'string') {
                                            const plain = toPlain(item.value);
                                            if (plain) bag.add(plain);
                                        }
                                    });
                                }
                                else {
                                    traverse(value);
                                }
                            });
                        }
                    };

                    filesArr.forEach(f => {
                        if (f.data) traverse(f.data);
                    });

                    return Array.from(bag);
                },
                escapeRegex(str) { return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); },

                // MathLive language utilities
                mathLive: {
                    // Toggle language for all math fields
                    toggleLanguage() {
                        try {
                            const mathFields = document.querySelectorAll('math-field');
                            mathFields.forEach(mf => {
                                const currentLang = mf.getAttribute('virtual-keyboard-default-language') || 'ar';
                                const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                mf.setAttribute('virtual-keyboard-default-language', newLang);
                                mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');
                            });

                            const langText = newLang === 'ar' ? 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' : 'English';
                            TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ${langText} Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©`, 'info', 2000);
                        } catch (error) {
                            console.error('Toggle language error:', error);
                        }
                    },

                    // Set language for specific math field
                    setLanguage(mathField, language) {
                        try {
                            if (!mathField || !language) return;

                            mathField.setAttribute('virtual-keyboard-default-language', language);
                            mathField.setAttribute('dir', language === 'ar' ? 'rtl' : 'ltr');

                            const langText = language === 'ar' ? 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' : 'English';
                            TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ${langText}`, 'info', 1500);
                        } catch (error) {
                            console.error('Set language error:', error);
                        }
                    },

                    // Get current language of math field
                    getLanguage(mathField) {
                        try {
                            if (!mathField) return 'ar';
                            return mathField.getAttribute('virtual-keyboard-default-language') || 'ar';
                        } catch (error) {
                            console.error('Get language error:', error);
                            return 'ar';
                        }
                    },

                    // Detect language from text content
                    detectLanguage(text) {
                        try {
                            if (!text || typeof text !== 'string') return 'ar';

                            const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(text);
                            const hasEnglish = /[a-zA-Z]/.test(text);

                            if (hasArabic && !hasEnglish) return 'ar';
                            if (hasEnglish && !hasArabic) return 'en';
                            return 'ar'; // Default to Arabic
                        } catch (error) {
                            console.error('Detect language error:', error);
                            return 'ar';
                        }
                    }
                },

                // Advanced text direction detection and processing
                textDirection: {
                    // Detect if text is primarily Arabic
                    isArabic(text) {
                        if (!text || typeof text !== 'string') return false;
                        const arabicRegex = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
                        return arabicRegex.test(text);
                    },

                    // Detect if text is primarily English/Latin
                    isLatin(text) {
                        if (!text || typeof text !== 'string') return false;
                        const latinRegex = /[a-zA-Z]/;
                        return latinRegex.test(text);
                    },

                    // Detect if text contains numbers
                    hasNumbers(text) {
                        if (!text || typeof text !== 'string') return false;
                        return /[\dÙ -Ù©]/.test(text);
                    },

                    // Detect if text is mixed (Arabic + Latin)
                    isMixed(text) {
                        if (!text || typeof text !== 'string') return false;
                        return this.isArabic(text) && this.isLatin(text);
                    },

                    // Get dominant text direction
                    getDominantDirection(text) {
                        if (!text || typeof text !== 'string') return 'rtl';

                        const arabicChars = (text.match(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/g) || []).length;
                        const latinChars = (text.match(/[a-zA-Z]/g) || []).length;

                        if (arabicChars > latinChars) return 'rtl';
                        if (latinChars > arabicChars) return 'ltr';
                        return 'rtl'; // Default to RTL for Arabic interface
                    },

                    // Process mixed content and add appropriate markup
                    processMixedContent(text) {
                        if (!text || typeof text !== 'string') return text;

                        try {
                            let processed = text;

                            // Handle Arabic numerals (Ù -Ù©)
                            

                            // Handle English numerals in Arabic context
                            

                            // Handle English words/phrases in Arabic text
                            if (this.isArabic(text) && this.isLatin(text)) {
                                processed = processed.replace(/([a-zA-Z][a-zA-Z0-9\s\-_]*[a-zA-Z0-9]|[a-zA-Z])/g, (match) => {
                                    // Don't wrap if it's already wrapped
                                    if (match.includes('<span')) return match;
                                    return `<span class="english-phrase" dir="ltr">${match}</span>`;
                                });
                            }

                            return processed;
                        } catch (error) {
                            console.error('Process mixed content error:', error);
                            return text;
                        }
                    },

                    // Apply smart direction classes to element
                    applySmartDirection(element, text) {
                        if (!element || !text) return;

                        try {
                            const direction = this.getDominantDirection(text);
                            const isMixed = this.isMixed(text);

                            // Remove existing direction classes
                            element.classList.remove('rtl-auto', 'ltr-auto', 'text-mixed', 'mixed-content');

                            if (isMixed) {
                                element.classList.add('mixed-content');
                                element.setAttribute('dir', 'auto');
                            } else if (direction === 'rtl') {
                                element.classList.add('rtl-auto');
                                element.setAttribute('dir', 'rtl');
                            } else {
                                element.classList.add('ltr-auto');
                                element.setAttribute('dir', 'ltr');
                            }

                            // Add unicode-bidi for better rendering
                            if (isMixed) {
                                element.style.unicodeBidi = 'plaintext';
                            } else {
                                element.style.unicodeBidi = 'embed';
                            }
                        } catch (error) {
                            console.error('Apply smart direction error:', error);
                        }
                    },

                    // Enhanced content processing for preview
                    enhancePreviewContent(htmlString) {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;

                        try {
                            // Create a temporary container to work with DOM
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = htmlString;

                            // Process all text nodes
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            textNodes.forEach(textNode => {
                                const text = textNode.textContent;
                                if (text && text.trim()) {
                                    const processedText = this.processMixedContent(text);
                                    if (processedText !== text) {
                                        const wrapper = document.createElement('span');
                                        wrapper.innerHTML = processedText;
                                        this.applySmartDirection(wrapper, text);
                                        textNode.parentNode.replaceChild(wrapper, textNode);
                                    }
                                }
                            });

                            // Apply direction to container elements
                            const elements = tempDiv.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6');
                            elements.forEach(el => {
                                const text = el.textContent;
                                if (text && text.trim()) {
                                    this.applySmartDirection(el, text);
                                }
                            });

                            return tempDiv.innerHTML;
                        } catch (error) {
                            console.error('Enhance preview content error:', error);
                            return htmlString;
                        }
                    }
                },
                /**
                 * Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ù†Øµ HTMLØŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ±Ø¬Ù…Ø©ØŒ ÙˆØªÙˆÙ„ÙŠØ¯ Ù‡ÙŠÙƒÙ„ HTML Ù…Ø¹ Ù†ØµÙˆØµ Ù†Ø§Ø¦Ø¨Ø©.
                 * @param {string} htmlString - ÙƒÙˆØ¯ HTML Ø§Ù„Ù…Ø±Ø§Ø¯ ØªØ­Ù„ÙŠÙ„Ù‡.
                 * @param {object} basePointer - Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù„ØªØ­Ø¯ÙŠØ¯ Ù…ØµØ¯Ø± Ø§Ù„Ù†Øµ (Ø±Ù‚Ù… Ø§Ù„Ù…Ù„ÙØŒ Ø§Ù„Ø¬Ø²Ø¡ØŒ Ø¥Ù„Ø®).
                 * @returns {{jobs: Array, parsedBody: HTMLElement}} - ÙƒØ§Ø¦Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ù…Ù‡Ø§Ù… Ø§Ù„ØªØ±Ø¬Ù…Ø© ÙˆØ§Ù„Ù‡ÙŠÙƒÙ„.
                 */
                /**
                 * âœ¨ IMPROVED VERSION - Hybrid Approach (Regex + DOMParser)
                 * ØªÙ†Ø¸ÙŠÙ ÙˆØ¥ØµÙ„Ø§Ø­ math-field tags Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø© ÙˆØ§Ù„Ù…ÙƒØ³ÙˆØ±Ø©
                 * 
                 * Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª:
                 * - ÙŠØ­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ attributes (id, class, data-*, Ø¥Ù„Ø®)
                 * - regex Ù…Ø­Ø³Ù‘Ù† Ù„Ø¥ØµÙ„Ø§Ø­ broken value attributes
                 * - Ø§Ø³ØªØ®Ø¯Ø§Ù… DOMParser Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¢Ù…Ù†Ø©
                 * - fallback Ø¢Ù…Ù† ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ DOMParser
                 * 
                 * @param {string} htmlString - ÙƒÙˆØ¯ HTML Ø§Ù„Ù…Ø±Ø§Ø¯ ØªÙ†Ø¸ÙŠÙÙ‡
                 * @returns {string} - HTML Ù†Ø¸ÙŠÙ
                 */
                /* // <--- ØªØ¹Ø·ÙŠÙ„ Ø¯Ø§Ù„Ø© cleanMathFieldTags
                cleanMathFieldTags(htmlString) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    
                    let cleaned = htmlString;
                    
                    // PHASE 1: Pre-normalization - Fix broken tag names
                    // Ø¥ØµÙ„Ø§Ø­ Ø£Ø³Ù…Ø§Ø¡ tags Ø§Ù„Ù…ÙƒØ³ÙˆØ±Ø© Ù…Ø«Ù„ <math-fieldvalue= â†’ <math-field value=
                    try {
                        const dash = '[\\-\u2212\u2013\u2014]'; // Support different dash types
                        cleaned = cleaned
                            .replace(new RegExp(`<\\s*math\\s*${dash}\\s*fieldvalue\\s*=`, 'gi'), '<math-field value=')
                            .replace(new RegExp(`<\\s*math\\s*${dash}\\s*field\\s*value\\s*=`, 'gi'), '<math-field value=')
                            .replace(new RegExp(`<\\s*math\\s*${dash}\\s*fielddefault-mode\\s*=`, 'gi'), '<math-field default-mode=')
                            .replace(new RegExp(`<\\s*math\\s*${dash}\\s*field`, 'gi'), '<math-field');
                    } catch (e) {
                        console.warn('âœ— Pre-normalization failed:', e);
                    }
                    
                    // PHASE 2: Fix broken value attributes using IMPROVED regex
                    // Ø¥ØµÙ„Ø§Ø­ value attributes Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ HTML tags
                    try {
                        // âœ¨ Better pattern - looks for < inside value attribute more accurately
                        cleaned = cleaned.replace(
                            /<math-field([^>]*?)value\s*=\s*"([^"]*<[^"]*?)"([^>]*?)>/gi,
                            (fullMatch, beforeValue, brokenValue, afterValue) => {
                                // Clean value from all tags
                                let cleanValue = brokenValue
                                    .replace(/<\/?math-field[^>]*>/gi, '') // Remove math-field tags
                                    .replace(/<math-fieldvalue=/gi, '')     // Remove broken patterns
                                    .replace(/<[^>]+>/g, '');                // Remove any other HTML tags
                                
                                return `<math-field${beforeValue}value="${cleanValue}"${afterValue}>`;
                            }
                        );
                    } catch (e) {
                        console.warn('âœ— Value attribute cleaning failed:', e);
                    }
                    
                    // PHASE 3: Remove nested tags from content using DOMParser
                    // Ù…Ø¹Ø§Ù„Ø¬Ø© DOM tree Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ ÙˆØ¢Ù…Ù†
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(`<div>${cleaned}</div>`, 'text/html');
                        const container = doc.body.firstChild;
                        
                        if (!container) return cleaned; // Safety check
                        
                        const mathFields = container.querySelectorAll('math-field');
                        
                        mathFields.forEach(field => {
                            // Remove nested math-fields from content
                            const nested = field.querySelectorAll('math-field');
                            nested.forEach(n => n.remove());
                            
                            // Clean value attribute one more time (for safety)
                            let value = field.getAttribute('value') || '';
                            if (value) {
                                value = value
                                    .replace(/<math-field[^>]*>/gi, '')
                                    .replace(/<\/math-field>/gi, '')
                                    .replace(/<math-fieldvalue=/gi, '');
                                field.setAttribute('value', value);
                            }
                            
                            // âœ¨ CRITICAL FIX: KEEP virtual-keyboard-mode and use-shared-virtual-keyboard!
                            // ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ attributes Ù…Ù‡Ù…Ø© Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„ØµØ­ÙŠØ­
                            
                            // Ø­Ø°Ù ÙÙ‚Ø· attributes Ø¨Ù‚ÙŠÙ… Ø³ÙŠØ¦Ø© (undefined, -1)
                            const attrsToCheck = Array.from(field.attributes);
                            attrsToCheck.forEach(attr => {
                                const name = attr.name;
                                const value = attr.value;
                                
                                // KEEP these critical attributes - NEVER remove them!
                                const keepAlways = [
                                    'value', 
                                    'default-mode',
                                    'dir',
                                    'locale',
                                    'virtual-keyboard-mode',      // âœ… CRITICAL
                                    'use-shared-virtual-keyboard', // âœ… CRITICAL
                                    'id',
                                    'class',
                                    'contenteditable'
                                ];
                                
                                if (keepAlways.includes(name)) return; // Don't remove
                                
                                // Remove only if value is undefined, -1, empty, or null
                                if (value === 'undefined' || value === '-1' || value === '' || value === null) {
                                    field.removeAttribute(name);
                                }
                            });
                            
                            // âœ¨ Remove ONLY style="padding: 0" or style="padding:0"
                            const style = field.getAttribute('style');
                            if (style && (style.trim() === 'padding: 0' || style.trim() === 'padding:0')) {
                                field.removeAttribute('style');
                            }
                            
                            // âœ… ENSURE critical attributes exist
                            if (!field.hasAttribute('virtual-keyboard-mode')) {
                                field.setAttribute('virtual-keyboard-mode', 'onfocus');
                            }
                            if (!field.hasAttribute('use-shared-virtual-keyboard')) {
                                field.setAttribute('use-shared-virtual-keyboard', '');
                            }
                        });
                        
                        cleaned = container.innerHTML;
                        
                    } catch (e) {
                        console.warn('âœ— DOMParser phase failed, using regex fallback:', e);
                        
                        // Fallback: Use regex if DOMParser fails
                        cleaned = cleaned.replace(
                            /<math-field([^>]*)>(.*?)<\/math-field>/gs,
                            (fullMatch, attributes, content) => {
                                // Remove nested math-field tags from content
                                let cleanContent = content.replace(/<\/?math-field[^>]*>/g, '');
                                return `<math-field${attributes}>${cleanContent}</math-field>`;
                            }
                        );
                    }
                    
                    return cleaned;
                },
                */ // <--- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¹Ø·ÙŠÙ„
                
                // CRITICAL FIX: Clean math-field attributes from DOM element
                cleanMathFieldAttributes(mathFieldElement) {
                    try {
                        const attrs = {};
                        
                        // Extract value
                        attrs.value = mathFieldElement.getAttribute('value') || '';
                        
                        // Extract default-mode (avoid duplicates)
                        const defaultMode = mathFieldElement.getAttribute('default-mode');
                        attrs.defaultMode = defaultMode || 'inline-math';
                        
                        // Extract dir
                        const dir = mathFieldElement.getAttribute('dir');
                        attrs.dir = dir || 'ltr';
                        
                        // Extract locale
                        const locale = mathFieldElement.getAttribute('locale');
                        attrs.locale = locale || 'en';
                        
                        return attrs;
                    } catch (error) {
                        console.warn('Error cleaning math-field attributes:', error);
                        return {
                            value: mathFieldElement.value || '',
                            defaultMode: 'inline-math',
                            dir: 'ltr',
                            locale: 'en'
                        };
                    }
                },

                parseHtmlAndCreateJobs(htmlString, basePointer) {
                    // First clean the math-field tags before processing
                    // const cleanedHtml = this.cleanMathFieldTags(htmlString); // <--- Ø¹Ø·Ù‘Ù„ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø±
                    const cleanedHtml = htmlString; // <--- ØªØ£ÙƒØ¯ Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± ØºÙŠØ± Ù…Ø¹Ø·Ù„
                    
                    const jobs = [];
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(`<!DOCTYPE html><body>${cleanedHtml}</body>`, 'text/html');
                    const body = doc.body;

                    function traverse(node) {
                        if (!node) return;
                        if (node.nodeType === 3) { // Text node
                            const text = (node.nodeValue || '').trim();
                            if (text) {
                                jobs.push({
                                    type: 'text_node',
                                    originalText: text,
                                    pointer: { ...(basePointer || {}) },
                                    domNode: node
                                });
                            }
                            return;
                        }
                        if (node.nodeType === 1) { // Element
                            const tag = (node.tagName || '').toUpperCase();
                            if (tag === 'SCRIPT' || tag === 'STYLE') return;
                            for (const child of Array.from(node.childNodes || [])) traverse(child);
                        }
                    }

                    traverse(body);
                    return { jobs, parsedBody: body };
                }
            },

            translationMemory: {
                storage: new Map(),
                maxEntries: 10000, // Maximum number of translations to store
                
                init() {
                    this.load();
                    // Update UI after a short delay to ensure DOM is ready
                    setTimeout(() => this.updateUI(), 100);
                },
                
                load() {
                    try {
                        const saved = localStorage.getItem('translationMemoryCache');
                        if (saved) {
                            const data = JSON.parse(saved);
                            this.storage = new Map(data);
                            console.log(`TM loaded: ${this.storage.size} entries`);
                        }
                    } catch (error) {
                        console.warn('Failed to load TM:', error);
                        this.storage = new Map();
                    }
                },
                
                save() {
                    try {
                        // Convert Map to array for JSON serialization
                        const data = Array.from(this.storage.entries());
                        
                        // If too many entries, keep only the most recent ones
                        if (data.length > this.maxEntries) {
                            const trimmed = data.slice(-this.maxEntries);
                            this.storage = new Map(trimmed);
                        }
                        
                        localStorage.setItem('translationMemoryCache', JSON.stringify(Array.from(this.storage.entries())));
                        console.log(`TM saved: ${this.storage.size} entries`);
                    } catch (error) {
                        console.warn('Failed to save TM:', error);
                    }
                },
                
                get(originalText) {
                    if (!TranslatorApp.dom.useTmCheckbox.checked) return null;
                    const key = this.createKey(originalText);
                    return this.storage.get(key) || null;
                },
                
                set(originalText, translatedText) {
                    if (!TranslatorApp.dom.useTmCheckbox.checked) return;
                    const key = this.createKey(originalText);
                    this.storage.set(key, {
                        translation: translatedText,
                        timestamp: Date.now(),
                        subject: TranslatorApp.state.selectedSubject,
                        grade: TranslatorApp.state.selectedGrade
                    });
                },
                
                createKey(text) {
                    // Normalize text for consistent matching
                    return (text || '').trim().toLowerCase();
                },
                
                clear() {
                    this.storage.clear();
                    localStorage.removeItem('translationMemoryCache');
                    console.log('TM cleared');
                },
                
                getStats() {
                    return {
                        totalEntries: this.storage.size,
                        maxEntries: this.maxEntries,
                        enabled: TranslatorApp.dom.useTmCheckbox.checked
                    };
                },
                
                updateUI() {
                    try {
                        const stats = this.getStats();
                        if (TranslatorApp.dom.tmStats) {
                            const statusText = stats.enabled ? 'âœ“ Ù…ÙØ¹Ù‘Ù„' : 'âœ— Ù…Ø¹Ø·Ù‘Ù„';
                            TranslatorApp.dom.tmStats.textContent = `${statusText} | Ø¹Ø¯Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©: ${stats.totalEntries.toLocaleString('ar-EG')} / ${stats.maxEntries.toLocaleString('ar-EG')}`;
                        }
                    } catch (error) {
                        console.warn('TM UI update error:', error);
                    }
                }
            },

            remoteGlossary: {
                map: {},
                async fetchApproved(subject, grade, texts) {
                    this.map = {};
                    if (!subject || subject === 'None') return this.map;
                    
                    try {
                        // Extract grid number from grade (e.g., "Grade 5" -> "5")
                        const gradeNumber = grade.replace(/[^0-9]/g, '');
                        
                        console.log(`Fetching termbase for Subject: ${subject}, Grade: ${gradeNumber}`);
                        
                        // Query based on new structure: Subject (Column A), grid (Column B), English Term (Column D), Arabic Term (Column E)
                        // Filter by Subject and grid
                        let tq = `select D,E where A = '${(subject || '').replace(/'/g, "\\'")}' and B = '${gradeNumber}'`;
                        let url = `https://docs.google.com/spreadsheets/d/${GOOGLE_SHEET_ID}/gviz/tq?tqx=out:json&headers=1&tq=${encodeURIComponent(tq)}`;
                        
                        let res = await fetch(url, { cache: 'no-cache' });
                        
                        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        
                        const raw = await res.text();
                        const match = raw.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/);
                        if (!match) throw new Error('ØªØ¹Ø°Ù‘Ø± Ù‚Ø±Ø§Ø¡Ø© Ø§Ø³ØªØ¬Ø§Ø¨Ø© gviz.');
                        
                        const data = JSON.parse(match[1]);
                        const rows = data.table?.rows || [];
                        
                        // Column D (index 0) = English Term, Column E (index 1) = Arabic Term
                        const allPairs = rows.map(r => ({
                            term: (r.c?.[0]?.v || '').toString().trim(),
                            translation: (r.c?.[1]?.v || '').toString().trim()
                        })).filter(x => x.term && x.translation);

                        console.log(`Fetched ${allPairs.length} terms for ${subject} - Grade ${gradeNumber}`);

                        const loweredTexts = Array.isArray(texts) ? texts.map(t => (t || '').toString().toLowerCase()) : [];
                        const map = {};
                        if (loweredTexts.length > 0) {
                            allPairs.forEach(({ term, translation }) => {
                                const tl = term.toLowerCase();
                                if (loweredTexts.some(tx => tx.includes(tl))) map[term] = translation;
                            });
                        } else {
                            allPairs.forEach(({ term, translation }) => { map[term] = translation; });
                        }
                        this.map = map;
                        
                        console.log(`Applied ${Object.keys(map).length} terms from termbase`);
                        return this.map;
                    } catch (e) {
                        console.warn('GVIZ fetch failed:', e);
                        TranslatorApp.ui.showAlert('ØªØ¹Ø°Ù‘Ø± Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø© (Ø³ÙŠØªÙ… Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø¨Ø¯ÙˆÙ†Ù‡Ø§).', 'info', 4000);
                        this.map = {};
                        return this.map;
                    }
                },
                applyWithPlaceholders(text) {
                    if (!text || !this.map || Object.keys(this.map).length === 0) {
                        return { modifiedText: text, placeholders: {} };
                    }
                    let modifiedText = text;
                    const placeholders = {};
                    let i = 0;
                    const terms = Object.keys(this.map).filter(Boolean).sort((a, b) => b.length - a.length);
                    for (const term of terms) {
                        const translation = this.map[term];
                        if (!translation) continue;
                        const esc = TranslatorApp.utils.escapeRegex(term.trim());
                        const useWordBoundary = /^[A-Za-z0-9 _-]+$/.test(term);
                        const re = new RegExp(useWordBoundary ? `\\b${esc}\\b` : esc, 'gi');
                        if (re.test(modifiedText)) {
                            const ph = `__GLOSSARY_${i++}__`;
                            placeholders[ph] = translation;
                            modifiedText = modifiedText.replace(re, ph);
                        }
                    }
                    return { modifiedText, placeholders };
                },
                revertPlaceholders(text, placeholders) {
                    if (!placeholders || !text) return text;
                    let out = text;
                    for (const [ph, tr] of Object.entries(placeholders)) out = out.split(ph).join(tr);
                    return out;
                }
            },

            security: {
                SALT: "a-secure-static-salt-for-obfuscation",
                encrypt(key) {
                    try {
                        if (!key || typeof key !== 'string') return '';
                        return btoa(key + this.SALT);
                    } catch (error) {
                        console.warn('Encryption error:', error);
                        return '';
                    }
                },
                decrypt(encryptedKey) {
                    try {
                        if (!encryptedKey || typeof encryptedKey !== 'string') return '';
                        const decoded = atob(encryptedKey);
                        return decoded.endsWith(this.SALT) ? decoded.slice(0, -this.SALT.length) : '';
                    } catch (error) {
                        console.warn('Decryption error:', error);
                        return '';
                    }
                },
                escapeHtml(text) {
                    if (typeof text !== 'string') return text;
                    const map = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#039;'
                    };
                    return text.replace(/[&<>"']/g, m => map[m]);
                },
                unescapeHtml(text) {
                    if (typeof text !== 'string') return text;
                    const map = {
                        '&amp;': '&',
                        '&lt;': '<',
                        '&gt;': '>',
                        '&quot;': '"',
                        '&#039;': "'",
                        '&#39;': "'",
                        '&am;': '&',  // Fix for broken entities like &am;
                        '&amØ¹;': '&', // Fix for broken entities with Arabic chars
                        '&amØ¹': '&'   // Fix for incomplete entities
                    };
                    
                    // CRITICAL FIX: Handle multiple passes for complex entities
                    let result = text;
                    for (const [entity, replacement] of Object.entries(map)) {
                        result = result.replace(new RegExp(entity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replacement);
                    }
                    
                    // Additional fix for malformed entities that might appear
                    result = result.replace(/&am[^;]*;/g, '&');
                    result = result.replace(/&[^;]*Ø¹[^;]*;/g, '&');
                    
                    // CRITICAL FIX: Handle specific broken entities from LaTeX processing
                    result = result.replace(/&amØ¹;/g, '&');
                    result = result.replace(/&amØ¹/g, '&');
                    result = result.replace(/&am;/g, '&');
                    
                    // Fix for double-encoded entities
                    result = result.replace(/&amp;amp;/g, '&');
                    result = result.replace(/&amp;lt;/g, '<');
                    result = result.replace(/&amp;gt;/g, '>');
                    
                    return result;
                },
                sanitize(html) {
                    if (typeof html !== 'string') return html;
                    try {
                        if (window.DOMPurify) {
                            return DOMPurify.sanitize(html, {
                                ALLOWED_TAGS: ['b', 'i', 'u', 'em', 'strong', 'sub', 'sup', 'br', 'span', 'p', 'ul', 'ol', 'li', 'img', 'a', 'code', 'pre', 'table', 'tr', 'td', 'th', 'thead', 'tbody', 'math', 'div', 'math-field', 'audio'],
                                ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'style', 'dir', 'value', 'default-mode', 'data-path', 'data-file-index', 'data-blank', 'read-only', 'controls', 'virtual-keyboard-mode', 'use-shared-virtual-keyboard', 'data-node-type', 'data-node-variation', 'locale', 'data-question-id', 'data-part-index', 'data-field-type', 'data-choice-index', 'data-math-index', 'white-space']
                            });
                        }
                        // Fallback sanitization
                        return html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
                    } catch (error) {
                        console.warn('HTML sanitization error:', error);
                        // Return a safe fallback
                        return html ? html.replace(/<[^>]*>/g, '') : '';
                    }
                }
            },

            quality: {
                unitsMap: {
                    'pounds': 'Ø¬Ù†ÙŠÙ‡',
                    'pound': 'Ø¬Ù†ÙŠÙ‡',
                    'cm': 'Ø³Ù…',
                    'mm': 'Ù…Ù…',
                    'km': 'ÙƒÙ…',
                    'm': 'Ù…',
                    'kg': 'ÙƒØ¬Ù…',
                    'g': 'Ø¬Ù…',
                    'l': 'Ù„',
                    'L': 'Ù„',
                    'ml': 'Ù…Ù„',
                    's': 'Ø«',
                    'min': 'Ø¯',
                    'h': 'Ø³'
                },
                wantsArabicIndicDigits(subject, grade) {
                    // Mathematics: Grades 1-3 and 9-12 should use Arabic digits
                    // Grades 4-8 should use English digits
                    if (subject === 'Mathematics') {
                        const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                        return arabicGrades.includes(grade);
                    }
                    
                    // Science: All grades should use Arabic digits  
                    if (subject === 'Science') return true;
                    
                    // Physics: All grades should use Arabic digits
                    if (subject === 'Physics') return true;
                    
                    // Chemistry: All grades should use Arabic digits
                    if (subject === 'Chemistry') return true;
                    
                    // Biology: All grades should use Arabic digits
                    if (subject === 'Biology') return true;
                    
                    return false;
                },

                fixStandaloneEnglishDigits(htmlString, ctx = { subject: 'None', grade: 'None' }) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                
                    // Check if conversion is required for this subject/grade
                    const shouldConvert = this.wantsArabicIndicDigits(ctx.subject, ctx.grade);
                    if (!shouldConvert) return htmlString;
                    
                    // 1. Temporarily protect MathLive fields
                    const protectedMath = [];
                    let processed = htmlString.replace(/<math-field[\s\S]*?<\/math-field>/gi, (match) => {
                        const placeholder = `__TMP_MATH_${protectedMath.length}__`;
                        protectedMath.push(match);
                        return placeholder;
                    });
                
                    // 2. Convert digits in the remaining text
                    processed = processed.replace(/[0-9]/g, ch => 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'[+ch]);
                
                    // 3. Restore MathLive fields
                    protectedMath.forEach((match, index) => {
                        const placeholder = `__TMP_MATH_${index}__`;
                        processed = processed.replace(placeholder, match);
                    });
                
                    return processed;
                },
                
                shouldConvertDigitsToArabic(subject, grade) {
                    // Use the same logic as wantsArabicIndicDigits
                    return this.wantsArabicIndicDigits(subject, grade);
                },
                
                shouldConvertSymbolsToArabic(subject, grade) {
                    // Convert symbols only for Mathematics and specific grades (1-3, 9-12)
                    // Grades 4-8 should keep English symbols
                    const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    return subject === 'Mathematics' && arabicGrades.includes(grade);
                },
                
                // Special function to handle specific mathematical terms and symbols
                fixSpecificMathTerms(str) {
                    if (!str || typeof str !== 'string') return str;
                    
                    let result = str;
                    
                    // Fix definite integral and ln issues
                    // Change "Ù‡Ù€" to "\hehi" in LaTeX context
                    result = result.replace(/Ù‡Ù€/g, '\\hehi');
                    
                    // Fix ln to \text{Ù„Ùˆ}_{\hehi}
                    result = result.replace(/\\ln\b/g, '\\text{Ù„Ùˆ}_{\\hehi}');
                    result = result.replace(/\bln\b/g, '\\text{Ù„Ùˆ}_{\\hehi}');
                    
                    // Fix "Ø¯" to "\dal" in specific contexts
                    result = result.replace(/(?<=\\text\{[^}]*\})Ø¯(?=\s|$|\\|})/g, '\\dal');
                    
                    // Fix det() to "Ù…Ø­Ø¯Ø¯"
                    result = result.replace(/\\det\b/g, 'Ù…Ø­Ø¯Ø¯');
                    result = result.replace(/\bdet\b/g, 'Ù…Ø­Ø¯Ø¯');
                    
                    // Fix lim to "Ù†Ù‡Ø§"
                    result = result.replace(/\\lim\b/g, 'Ù†Ù‡Ø§');
                    result = result.replace(/\blim\b/g, 'Ù†Ù‡Ø§');
                    
                    // Fix transpose T to "Ù…Ø¯"
                    result = result.replace(/\^T\b/g, '^Ù…Ø¯');
                    result = result.replace(/T\^T\b/g, 'Ù…Ø¯^Ù…Ø¯');
                    
                    // Fix English commas to Arabic commas in mathematical expressions
                    result = result.replace(/(?<=[0-9Ù -Ù©a-zA-Z])\s*,\s*(?=[0-9Ù -Ù©a-zA-Z])/g, 'ØŒ ');
                    
                    // Fix "Ø£ÙˆØ¬Ø¯" to "ÙØ£ÙˆØ¬Ø¯" after conditional statements
                    result = result.replace(/(?<=Ø¥Ø°Ø§ ÙƒØ§Ù†[^.]*\.)\s*Ø£ÙˆØ¬Ø¯/g, ' ÙØ£ÙˆØ¬Ø¯');
                    
                    return result;
                },
                
                // Function to fix arrows and expression ordering for RTL
                fixArrowsAndOrdering(str, ctx = { subject: 'None', grade: 'None' }) {
                    if (!str || typeof str !== 'string') return str;
                    
                    // Only apply to Mathematics grades that use Arabic symbols
                    const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    if (ctx.subject !== 'Mathematics' || !arabicGrades.includes(ctx.grade)) {
                        return str;
                    }
                    
                    let result = str;
                    
                    // Reverse arrows for RTL
                    result = result.replace(/â†’/g, 'â†');
                    result = result.replace(/â†/g, 'â†’');
                    result = result.replace(/\\rightarrow/g, '\\leftarrow');
                    result = result.replace(/\\leftarrow/g, '\\rightarrow');
                    
                    // Fix repeated commas (from "and" translation)
                    result = result.replace(/ØŒ\s*ØŒ/g, 'ØŒ');
                    result = result.replace(/,\s*ØŒ/g, 'ØŒ');
                    result = result.replace(/ØŒ\s*,/g, 'ØŒ');
                    
                    return result;
                },
                
                // Function to fix factorial alignment and bracket issues
                fixFactorialIssues(str) {
                    if (!str || typeof str !== 'string') return str;
                    
                    let result = str;
                    
                    // Fix factorial alignment - ensure 0 is properly positioned
                    result = result.replace(/(\d+)!/g, '$1!');
                    
                    // Fix factorial with brackets alignment
                    result = result.replace(/\((\d+)\)!/g, '($1)!');
                    
                    return result;
                },
                
                cleanLatexArabic(text) {
                    if (typeof text !== 'string') return text;
                    // CRITICAL FIX: Remove problematic LaTeX commands that appear in Arabic text
                    return text.replace(/\\alt{\\alef}\\prime/g, '')  // Remove \alt{\alef}\prime
                               .replace(/\\lam/g, 'ÙˆØ§Ù„Ø¨Ø§Ù‚ÙŠ ')        // Replace \lam with Arabic text
                               .replace(/\\alt{\\alef}/g, '')         // Remove \alt{\alef}
                               .replace(/\\prime/g, '')              // Remove \prime
                               .replace(/\\alef/g, '')               // Remove \alef
                               .replace(/\\alt/g, '');               // Remove \alt
                },
                
                protectSegments(text) {
                    // --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Ù…Ù†Ø·Ù‚ Ø§Ù„ØªÙ†Ø¸ÙŠÙ) ---
                    // ØªÙ†Ø¸ÙŠÙ ÙˆØ³ÙˆÙ… LexicalTheme Ùˆ merge *Ù‚Ø¨Ù„* Ø­Ù…Ø§ÙŠØ© math-field
                    try {
                        let originalHtml = String(text || '');
                        let cleanedHtml = originalHtml;

                        // Ø¥Ø²Ø§Ù„Ø© LexicalTheme__math (ÙˆØ¶Ø¹ block)
                        cleanedHtml = cleanedHtml.replace(
                            /<span\s+class=["']LexicalTheme__math["'][^>]*>(<math-field[\s\S]*?<\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        // Ø¥Ø²Ø§Ù„Ø© LexicalTheme__math--inline (ÙˆØ¶Ø¹ inline)
                        cleanedHtml = cleanedHtml.replace(
                            /<span\s+class=["']LexicalTheme__math--inline["'][^>]*>(<math-field[\s\S]*?<\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        // Ø¥Ø²Ø§Ù„Ø© ÙˆØ³ÙˆÙ… <span class="merge">
                        cleanedHtml = cleanedHtml.replace(
                            /<span\s+class=["']merge["'][^>]*>(<math-field[\s\S]*?<\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        // Ø¥Ø²Ø§Ù„Ø© ÙˆØ³ÙˆÙ… data-node-type="math"
                        cleanedHtml = cleanedHtml.replace(
                            /<span[^>]*data-node-type=["']math["'][^>]*>(<math-field[\s\S]*?<\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        // Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ <p> (Ù…Ø«Ù„ LexicalTheme__paragraph) ØªØ­ÙŠØ· Ø¨Ù€ math-field
                        cleanedHtml = cleanedHtml.replace(
                            /<p[^>]*>(<math-field[\s\S]*?<\/math-field>)<\/p>/gi,
                            '$1'
                        );

                        if (originalHtml !== cleanedHtml) {
                            console.log('ğŸ§¼ [Cleaner] ØªÙ… ØªÙ†Ø¸ÙŠÙ ÙˆØ³ÙˆÙ… <span> Ø§Ù„Ù…Ø­ÙŠØ·Ø© Ø¨Ù€ math-field.');
                        }
                        text = cleanedHtml; // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªÙ†Ø¸ÙŠÙ Ù‚Ø¨Ù„ Ø§Ù„Ø­Ù…Ø§ÙŠØ©

                    } catch (e) {
                        console.warn("Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†Ø¸ÙŠÙ ÙˆØ³ÙˆÙ… <span> ÙÙŠ protectSegments:", e);
                    }
                    // --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---

                    const placeholders = {};
                    let idx = 0;
                    const patterns = [
                        // âœ… CRITICAL: Protect math-field tags - DO NOT send to AI
                        // The AI should NOT translate mathematical content inside math-field
                        // Our post-processing functions will handle math conversion
                        /<math-field[\s\S]*?<\/math-field>/g,
                        // Protect blank/gap tags - these are special input fields
                        /<span[^>]*data-node-type=["']blank-line["'][^>]*>[\s\S]*?<\/span>/g,
                        /<span[^>]*data-blank[^>]*>[\s\S]*?<\/span>/g,
                        /<audio[\s\S]*?<\/audio>/g,
                        /<img[^>]*>/g,
                        // Don't protect tables - let their content be translated
                        // /<table[\s\S]*?<\/table>/g,
                        /_{3,}/g,
                        /```[\s\S]*?```/g,
                        /`[^`]*`/g,
                        // Protect all LaTeX expressions
                        /\$\$[\s\S]*?\$\$/g,
                        /\$[^$]*\$/g,
                        /\\\[[\s\S]*?\\]/g,
                        /\\\([\s\S]*?\\\)/g,
                        // Protect LaTeX commands
                        /\\displaystyle\{[^}]*\}/g,
                        /\\begin\{[^}]+\}[\s\S]*?\\end\{[^}]+\}/g,
                        /\\left[\[\(\{][\s\S]*?\\right[\]\)\}]/g,
                        /https?:\/\/\S+/g,
                        // Protect Lexical theme elements that might interfere with translation
                        /<span[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/span>/g,
                        /<p[^>]*class="[^"]*LexicalTheme[^"]*"[^>]*>[\s\S]*?<\/p>/g
                    ];
                    let protectedText = String(text || '');
                    let protectionCount = 0;
                    for (const re of patterns) {
                        protectedText = protectedText.replace(re, (m) => { 
                            const ph = `__LOCK_${idx++}__`; 
                            placeholders[ph] = m; 
                            protectionCount++;
                            return ph; 
                        });
                    }
                    
                    // Debug logging
                    if (protectionCount > 0) {
                        console.log(`ğŸ”’ [Protection] Protected ${protectionCount} segments from AI`);
                        console.log(`ğŸ“ [Before Protection] ${(text || '').substring(0, 150)}...`);
                        console.log(`ğŸ” [After Protection] ${protectedText.substring(0, 150)}...`);
                    }
                    
                    return { protectedText, placeholders };
                },
                restoreSegments(text, placeholders) {
                    if (!placeholders) return text;
                    let out = text || '';
                    const restoredCount = Object.keys(placeholders).length;
                    for (const [ph, val] of Object.entries(placeholders)) out = out.split(ph).join(val);
                    
                    // Debug logging
                    if (restoredCount > 0) {
                        console.log(`ğŸ”“ [Restoration] Restored ${restoredCount} protected segments`);
                        console.log(`ğŸ“¤ [After Restoration] ${out.substring(0, 150)}...`);
                    }
                    
                    return out;
                },
                convertDigits(str, toArabicIndic) {
                    const en = '0123456789'.split(''); const ar = 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'.split('');
                    if (toArabicIndic) return (str || '').replace(/[0-9]/g, ch => ar[+ch]);
                    return (str || '').replace(/[Ù -Ù©]/g, ch => en[ar.indexOf(ch)]);
                },
                
                /**
                 * Process all math-field tags in HTML and convert their content based on grade
                 * This function runs AFTER translation to ensure consistent math content
                 */
                processMathFieldsForGrade(htmlString, ctx = { subject: 'None', grade: 'None' }) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    
                    console.log('ğŸ“ [Math Field Processing - START]', {
                        subject: ctx.subject,
                        grade: ctx.grade,
                        htmlLength: htmlString.length,
                        firstChars: htmlString.substring(0, 200)
                    });
                    
                    // Only process for Mathematics subject
                    if (ctx.subject !== 'Mathematics') {
                        console.log('â­ï¸ [Skipping - Not Mathematics]');
                        return htmlString;
                    }
                    
                    // Determine if we should convert based on grade
                    const shouldConvertDigits = this.shouldConvertDigitsToArabic(ctx.subject, ctx.grade);
                    const shouldConvertSymbols = this.shouldConvertSymbolsToArabic(ctx.subject, ctx.grade);
                    
                    console.log('ğŸ“ [Math Field Processing - Rules]', {
                        subject: ctx.subject,
                        grade: ctx.grade,
                        convertDigits: shouldConvertDigits,
                        convertSymbols: shouldConvertSymbols
                    });
                    
                    // Count math-field tags for debugging
                    const mathFieldMatches = htmlString.match(/<math-field[^>]*>/gi);
                    console.log('ğŸ”¢ [Found math-field tags]:', mathFieldMatches ? mathFieldMatches.length : 0);
                    if (mathFieldMatches && mathFieldMatches.length > 0) {
                        console.log('ğŸ“‹ [First math-field tag]:', mathFieldMatches[0].substring(0, 300));
                    }
                    
                    // Process all math-field tags
                    return htmlString.replace(
                        /<math-field([^>]*)>([\s\S]*?)<\/math-field>/gi,
                        (match, allAttrs, innerContent) => {
                            // Extract value attribute more reliably
                            const valueMatch = allAttrs.match(/value=["']([^"']*)["']/i);
                            
                            if (!valueMatch) {
                                console.log('âš ï¸ [No value attribute found in]:', match.substring(0, 100));
                                return match; // Return unchanged if no value found
                            }
                            
                            let processedValue = valueMatch[1];
                            let processedInner = innerContent || '';
                            
                            console.log('ğŸ” [Original math-field value]:', processedValue.substring(0, 150));
                            console.log('ğŸ” [Original math-field inner]:', processedInner.substring(0, 150));
                            
                            // Convert digits if needed
                            if (shouldConvertDigits) {
                                processedValue = this.convertDigits(processedValue, true);
                                processedInner = this.convertDigits(processedInner, true);
                                console.log('ğŸ”¢ [After digit conversion]:', processedValue.substring(0, 150));
                            }
                            
                            // Convert symbols if needed
                            if (shouldConvertSymbols) {
                                processedValue = this.convertSymbolsToArabic(processedValue);
                                processedInner = this.convertSymbolsToArabic(processedInner);
                                console.log('âœ… [After symbol conversion]:', processedValue.substring(0, 150));
                                
                                // Apply specific mathematical term fixes
                                processedValue = this.fixSpecificMathTerms(processedValue);
                                processedInner = this.fixSpecificMathTerms(processedInner);
                                
                                // Fix arrows and ordering for RTL
                                processedValue = this.fixArrowsAndOrdering(processedValue, ctx);
                                processedInner = this.fixArrowsAndOrdering(processedInner, ctx);
                                
                                // Fix factorial issues
                                processedValue = this.fixFactorialIssues(processedValue);
                                processedInner = this.fixFactorialIssues(processedInner);
                            }
                            
                            // Fix commas in both value and inner content
                            processedValue = processedValue.replace(/,/g, 'ØŒ');
                            processedInner = processedInner.replace(/,/g, 'ØŒ');
                            
                            // Rebuild the math-field tag with processed value and inner content
                            const newAttrs = allAttrs.replace(/value=["'][^"']*["']/i, `value="${processedValue}"`);
                            const result = `<math-field${newAttrs}>${processedInner}</math-field>`;
                            console.log('ğŸ“¦ [Final math-field]:', result.substring(0, 200));
                            return result;
                        }
                    );
                },
                
                /**
                 * Determine if digits should be converted to Arabic-Indic based on subject and grade
                 */

                /**
                 * Convert Latin mathematical symbols to Arabic equivalents
                 * For Math Grades 1-3, 9-12
                 */
                convertSymbolsToArabic(str) {
                    if (!str || typeof str !== 'string') return str;
                    
                    console.log('ğŸ” [convertSymbolsToArabic] Input:', str.substring(0, 200));
                    
                    // Map of common mathematical symbols (Latin â†’ Arabic)
                    const symbolMap = {
                        'x': 'Ø³',
                        'y': 'Øµ', 
                        'z': 'Ø¹',
                        'a': 'Ø£',
                        'b': 'Ø¨',
                        'c': 'Ø¬Ù€',
                        'd': 'Ø¯',
                        'e': 'Ù‡Ù€',
                        'f': 'Ùˆ',
                        'g': 'Ø­Ù€',
                        'h': 'Ø±',
                        'k': 'Ùƒ',
                        'l': 'Ù„',
                        'm': 'Ù…',
                        'n': 'Ù†',
                        'p': 'Ø¹',
                        'q': 'Ù‚',
                        'r': 'Ø±',
                        's': 'Ø¬Ù€',
                        't': 'Ø·',
                        'u': 'Ø«',
                        'v': 'Ø¸',
                        'w': 'Ùˆ',
                        // Additional symbols for specific contexts
                        'F': 'Ù',  // for vectors & angles context
                        'i': 'ÙŠ',  // for vectors & angles context  
                        'j': 'Ø¬',  // for vectors & angles context
                        'T': 'Øª',  // for Sigma notation context
                        'A': 'Ø£',  // for matrix context
                        'P': 'Ø¨',  // for permutation context
                        'C': 'Ø¬',  // for combination context
                        'R': 'Ø±',  // for vectors & angles context
                        'N': 'Ù†'   // for vectors & angles context
                    };
                    
                    const protectedElements = [];
                    let workingStr = str;
                    
                    // STEP 1: Protect complete LaTeX blocks (everything between $ or $$)
                    workingStr = workingStr.replace(/\$\$[\s\S]*?\$\$|\$[^$]*?\$/g, (match) => {
                        const index = protectedElements.length;
                        protectedElements.push(match);
                        return `__LATEX_BLOCK_${index}__`;
                    });
                    
                    console.log('ğŸ”’ [After protecting LaTeX blocks]:', workingStr.substring(0, 200));
                    
                    // STEP 2: Protect complete <math-field> tags
                    workingStr = workingStr.replace(/<math-field[^>]*>[\s\S]*?<\/math-field>/g, (match) => {
                        const index = protectedElements.length;
                        protectedElements.push(match);
                        return `__MATH_FIELD_${index}__`;
                    });
                    
                    console.log('ğŸ”’ [After protecting math-field tags]:', workingStr.substring(0, 200));
                    
                    // STEP 3: Protect LaTeX commands (e.g., \begin, \end, \textrm, etc.)
                    workingStr = workingStr.replace(/\\[a-zA-Z]+/g, (match) => {
                        const index = protectedElements.length;
                        protectedElements.push(match);
                        return `__LATEX_CMD_${index}__`;
                    });
                    
                    // STEP 4: Protect content inside curly braces ONLY for structural commands
                    // (NOT for \displaystyle, \text, \textrm - those need variable conversion)
                    workingStr = workingStr.replace(/__LATEX_CMD_(\d+)__\s*\{([^}]+)\}/g, (match, cmdIndex, content) => {
                        // Get the actual command
                        const cmd = protectedElements[parseInt(cmdIndex)];
                        
                        // Only protect content for structural commands (begin, end, etc.)
                        const structuralCommands = ['\\begin', '\\end'];
                        
                        if (structuralCommands.includes(cmd)) {
                            const contentIndex = protectedElements.length;
                            protectedElements.push(`{${content}}`);
                            return `__LATEX_CMD_${cmdIndex}____LATEX_CONTENT_${contentIndex}__`;
                        }
                        
                        // For other commands (displaystyle, text, etc.), keep the braces but don't protect the content
                        return `__LATEX_CMD_${cmdIndex}__{${content}}`;
                    });
                    
                    // STEP 5: Protect environment names (e.g., {pmatrix}, {align})
                    workingStr = workingStr.replace(/\{([a-zA-Z]+)\}/g, (match, envName) => {
                        // Check if this is a LaTeX environment name (common ones)
                        const envNames = ['pmatrix', 'bmatrix', 'vmatrix', 'matrix', 'align', 'cases', 'dcases', 
                                         'equation', 'array', 'split', 'gather', 'multline', 'alignat'];
                        if (envNames.includes(envName)) {
                            const index = protectedElements.length;
                            protectedElements.push(match);
                            return `__LATEX_ENV_${index}__`;
                        }
                        return match;
                    });
                    
                    // STEP 6: Protect common mathematical function names
                    const protectedTerms = ['det', 'lim', 'sin', 'cos', 'tan', 'cot', 'sec', 'csc',
                                          'log', 'ln', 'exp', 'sqrt', 'frac', 'sum', 'prod', 'int',
                                          'max', 'min', 'abs', 'gcd', 'lcm', 'mod', 'dim', 'ker',
                                          'arg', 'deg', 'hom', 'inf', 'sup', 'text', 'textrm'];
                    
                    protectedTerms.forEach(term => {
                        const regex = new RegExp(`\\b${term}\\b`, 'g');
                        workingStr = workingStr.replace(regex, (match) => {
                            const index = protectedElements.length;
                            protectedElements.push(match);
                            return `__FUNC_${index}__`;
                        });
                    });
                    
                    console.log('ğŸ”’ [After protecting all LaTeX]:', workingStr.substring(0, 200));
                    console.log('ğŸ“¦ [Protected elements count]:', protectedElements.length);
                    
                    // STEP 7: Now convert ONLY standalone single-letter variables
                    let result = workingStr;
                    
                    for (const [latin, arabic] of Object.entries(symbolMap)) {
                        // Match single letter that is:
                        // - NOT preceded by backslash, letter, or underscore
                        // - NOT followed by letter or underscore
                        // - NOT part of a placeholder
                        const regex = new RegExp(
                            `(?<!\\\\)(?<![a-zA-Z_])(?<!__)${latin}(?![a-zA-Z_])(?!__)`,
                            'g'
                        );
                        result = result.replace(regex, arabic);
                    }
                    
                    console.log('âœï¸ [After symbol conversion]:', result.substring(0, 200));
                    
                    // STEP 8: Restore all protected elements in reverse order
                    for (let i = protectedElements.length - 1; i >= 0; i--) {
                        const placeholderPatterns = [
                            `__LATEX_BLOCK_${i}__`,
                            `__MATH_FIELD_${i}__`,
                            `__LATEX_CMD_${i}__`,
                            `__LATEX_CONTENT_${i}__`,
                            `__LATEX_ENV_${i}__`,
                            `__FUNC_${i}__`
                        ];
                        
                        for (const pattern of placeholderPatterns) {
                            if (result.includes(pattern)) {
                                result = result.replace(new RegExp(pattern, 'g'), protectedElements[i]);
                            }
                        }
                    }
                    
                    console.log('ğŸ”“ [After restoring protected elements]:', result.substring(0, 200));
                    console.log('âœ… [convertSymbolsToArabic] Output:', result.substring(0, 200));
                    
                    return result;
                },
                
                normalizeArabicPunct(str) {
                    return (str || '')
                        .replace(/ ,/g, 'ØŒ')
                        .replace(/, /g, 'ØŒ ')
                        .replace(/,/g, 'ØŒ')
                        .replace(/;/g, 'Ø›')
                        .replace(/\?/g, 'ØŸ')
                        .replace(/["""]/g, 'Â»')
                        .replace(/'/g, 'Ê¼')
                        .replace(/\s+([ØŒØ›ØŸ])/g, '$1')
                        .replace(/([ØŒØ›])(?=[^\s])/g, '$1 ')
                        .replace(/\s+/g, ' ');
                },
                enforceUnits(str, ctx = { subject: 'None', grade: 'None' }) {
                    const map = { cm: 'Ø³Ù…', mm: 'Ù…Ù…', km: 'ÙƒÙ…', m: 'Ù…', kg: 'ÙƒØ¬Ù…', g: 'Ø¬Ù…', l: 'Ù„', L: 'Ù„', ml: 'Ù…Ù„', s: 'Ø«', min: 'Ø¯', h: 'Ø³' };
                    
                    // For Math Grades 4-8, units should be translated but keep English digits
                    // The expression should be written RTL when it contains units
                    const mathEnglishGrades = ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8'];
                    if (ctx.subject === 'Mathematics' && mathEnglishGrades.includes(ctx.grade)) {
                        // Keep English digits, translate units, and ensure RTL direction for unit expressions
                        return (str || '').replace(/([0-9.,]+)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => {
                            const translatedUnit = map[u] || u;
                            // Add RTL direction for expressions with units
                            return `<span dir="rtl">${num}\u00A0${translatedUnit}</span>`;
                        });
                    }
                    
                    // For other grades, work with both English and Arabic digits
                    return (str || '').replace(/(\d[0-9Ù -Ù©.,]*)\s*(cm|mm|km|m|kg|g|l|L|ml|s|min|h)\b/g, (m, num, u) => `${num}\u00A0${map[u] || u}`);
                },
                convertAndToComma(str, ctx = { subject: 'None', grade: 'None' }) {
                    // For Math Grades 1-3 and 9-12, convert "and" between symbols/numbers to Arabic comma
                    // Grades 4-8 should keep "and" as is (English expressions)
                    const mathArabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    if (ctx.subject === 'Mathematics' && mathArabicGrades.includes(ctx.grade)) {
                        // Convert "and" or "Ùˆ" between numbers or symbols to comma
                        let result = str || '';
                        // Match patterns like "x and y" or "3 and 5" and convert to comma
                        result = result.replace(/([0-9Ù -Ù©a-zA-ZØ¡-ÙŠ]+)\s+and\s+([0-9Ù -Ù©a-zA-ZØ¡-ÙŠ]+)/gi, '$1ØŒ $2');
                        // Also handle if "and" was already translated to "Ùˆ" (for both numbers and Arabic letters)
                        result = result.replace(/([0-9Ù -Ù©Ø¡-ÙŠ]+)\s+Ùˆ\s+([0-9Ù -Ù©Ø¡-ÙŠ]+)/g, '$1ØŒ $2');
                        return result;
                    }
                    return str;
                },
                ensureRTLDirection(htmlString, ctx = { subject: 'None', grade: 'None' }) {
                    // Ensure all HTML elements with Arabic text have proper RTL direction
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    
                    // For Math Grades 4-8, only apply RTL to expressions with units
                    const mathEnglishGrades = ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8'];
                    if (ctx.subject === 'Mathematics' && mathEnglishGrades.includes(ctx.grade)) {
                        // For grades 4-8, only ensure RTL for unit expressions (already handled in enforceUnits)
                        return htmlString;
                    }
                    
                    try {
                        // Create a temporary container
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = htmlString;
                        
                        // Function to check if text is primarily Arabic
                        const isArabicText = (text) => {
                            if (!text) return false;
                            const arabicChars = (text.match(/[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/g) || []).length;
                            const totalChars = text.replace(/\s/g, '').length;
                            return arabicChars > totalChars * 0.3; // If more than 30% Arabic, consider it Arabic
                        };
                        
                        // Process all elements that can contain text
                        const elements = tempDiv.querySelectorAll('p, div, span, td, th, li, h1, h2, h3, h4, h5, h6');
                        elements.forEach(el => {
                            // Skip SVG and math elements
                            if (el.closest('svg, math-field')) return;
                            
                            const textContent = el.textContent || '';
                            if (textContent.trim() && isArabicText(textContent)) {
                                // Only add dir if not already set
                                if (!el.hasAttribute('dir')) {
                                    el.setAttribute('dir', 'rtl');
                                }
                            }
                        });
                        
                        return tempDiv.innerHTML;
                    } catch (error) {
                        console.error('Ensure RTL direction error:', error);
                        return htmlString;
                    }
                },
                
                // Enhanced translation quality fixes based on comprehensive testing
                fixTranslationIssues(text, ctx = { subject: 'None', grade: 'None' }) {
                    let out = text || '';
                    
                    // 1. Fix broken HTML entities (3 types)
                    out = out.replace(/&amp;amp;/g, '&amp;');
                    out = out.replace(/&amp;lt;/g, '&lt;');
                    out = out.replace(/&amp;gt;/g, '&gt;');
                    
                    // 2. Fix LaTeX commands consistency
                    out = out.replace(/\\textrm\s*\{([^}]+)\}/g, '\\text{$1}');
                    
                    // 3. Fix mixed numbers in math-field (English/Arabic)
                    if (this.wantsArabicIndicDigits(ctx.subject, ctx.grade)) {
                        out = out.replace(/<math-field([^>]*value="[^"]*)([0-9]+)([^"]*")/g, (match, before, digits, after) => {
                            const arabicDigits = digits.replace(/[0-9]/g, d => 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'[parseInt(d)]);
                            return match.replace(digits, arabicDigits);
                        });
                    }
                    
                    // 4. Fix English variables in Arabic context (in math-field only)
                    if (this.wantsArabicIndicDigits(ctx.subject, ctx.grade)) {
                        const variableMap = {
                            'x': 'Ø³', 'y': 'Øµ', 'z': 'Ø¹', 'a': 'Ø£', 'b': 'Ø¨', 'c': 'Ø¬Ù€',
                            'd': 'Ø¯', 'f': 'Ùˆ', 'g': 'Ø²', 'h': 'Ø­', 'k': 'Ùƒ',
                            'l': 'Ù„', 'm': 'Ù…', 'n': 'Ù†', 'p': 'Ø¹', 'q': 'Ù‚', 'r': 'Ø±',
                            't': 'Øª', 'v': 'Ù', 'w': 'Ùˆ',
                            // Additional symbols for specific contexts
                            'F': 'Ù', 'i': 'ÙŠ', 'j': 'Ø¬', 'T': 'Øª', 'A': 'Ø£', 'P': 'Ø¨', 
                            'C': 'Ø¬', 'R': 'Ø±', 'N': 'Ù†'
                        };
                        
                        out = out.replace(/<math-field([^>]*value=["'])([^"']*)((["'][^>]*)>)([^<]*)<\/math-field>/g, 
                            (match, before, valueAttr, middle, afterValue, innerContent) => {
                                
                                // Fix value attribute
                                let fixedValue = valueAttr;
                                Object.entries(variableMap).forEach(([en, ar]) => {
                                    const regex = new RegExp(`(?<!\\\\[a-zA-Z]*)(?<![a-zA-Z])${en}(?![a-zA-Z])`, 'g');
                                    fixedValue = fixedValue.replace(regex, ar);
                                });
                                
                                // Fix inner content
                                let fixedInner = innerContent;
                                Object.entries(variableMap).forEach(([en, ar]) => {
                                    const regex = new RegExp(`(?<!\\\\[a-zA-Z]*)(?<![a-zA-Z])${en}(?![a-zA-Z])`, 'g');
                                    fixedInner = fixedInner.replace(regex, ar);
                                });
                                
                                return `<math-field${before}${fixedValue}${middle}${fixedInner}</math-field>`;
                            });
                    }
                    
                    // 5. Fix punctuation in plain text (not inside HTML tags)
                    out = out.replace(/(?<!<[^>]*)([.!?])\s*([.!?])/g, '$1$2');
                    out = out.replace(/(?<!<[^>]*)([.!?])\s*([.!?])\s*([.!?])/g, '$1$2$3');
                    
                    // 6. Fix reversed cases/dcases columns
                    out = out.replace(/\\begin\{(cases|dcases)\}([^}]+)\\\\([^}]+)\\end\{(cases|dcases)\}/g, 
                        (match, beginType, col1, col2, endType) => {
                            return `\\begin{${beginType}}${col2}\\\\${col1}\\end{${endType}}`;
                        });
                    
                    return out;
                },
                
                // Sync math-field content with value attribute
                syncMathFieldContent(htmlString) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    
                    return htmlString.replace(/<math-field([^>]*value="([^"]*)"[^>]*)>([^<]*)<\/math-field>/g, 
                        (match, attributes, value, innerContent) => {
                            // Add locale="ar" if not present
                            if (!attributes.includes('locale=')) {
                                attributes = attributes + ' locale="ar"';
                            }
                            
                            // If inner content is different from value, sync them
                            if (value !== innerContent) {
                                return `<math-field${attributes}>${value}</math-field>`;
                            }
                            return `<math-field${attributes}>${innerContent}</math-field>`;
                        });
                },

                // Enhanced HTML cleaning and validation
                cleanHtml(text) {
                    let cleaned = text;

                    // Ø¥ØµÙ„Ø§Ø­ HTML entities
                    cleaned = cleaned.replace(/&amp;/g, '&');
                    cleaned = cleaned.replace(/&lt;/g, '<');
                    cleaned = cleaned.replace(/&gt;/g, '>');

                    // Ø¥ØµÙ„Ø§Ø­ ØªÙˆØ§Ø²Ù† HTML tags
                    cleaned = this.fixHtmlTagBalance(cleaned);

                    return cleaned;
                },

                // Fix HTML tag balance
                fixHtmlTagBalance(text) {
                    const openTags = (text.match(/</g) || []).length;
                    const closeTags = (text.match(/>/g) || []).length;

                    if (openTags !== closeTags) {
                        if (openTags > closeTags) {
                            text += '>'.repeat(openTags - closeTags);
                        } else if (closeTags > openTags) {
                            text = '<'.repeat(closeTags - openTags) + text;
                        }
                    }

                    return text;
                },

                // Fix mixed numbers in math-field content
                fixMixedNumbersInMathFields(text, grade) {
                    if (!/[Ø£-ÙŠ]/.test(text)) return text;
                    
                    const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    if (!arabicGrades.includes(grade)) return text;
                    
                    let fixed = text;
                    
                    // Only fix inside math-field tags
                    fixed = fixed.replace(/<math-field([^>]*value=["'])([^"']*)((["'][^>]*)>)([^<]*)<\/math-field>/g, 
                        (match, before, valueAttr, middle, afterValue, innerContent) => {
                            
                            // Fix value attribute
                            let fixedValue = this.convertDigitsInMathContent(valueAttr);
                            
                            // Fix inner content
                            let fixedInner = this.convertDigitsInMathContent(innerContent);
                            
                            return `<math-field${before}${fixedValue}${middle}${fixedInner}</math-field>`;
                        });
                    
                    return fixed;
                },

                // Convert digits in math content
                convertDigitsInMathContent(content) {
                    const digitMap = {
                        '0': 'Ù ', '1': 'Ù¡', '2': 'Ù¢', '3': 'Ù£', '4': 'Ù¤',
                        '5': 'Ù¥', '6': 'Ù¦', '7': 'Ù§', '8': 'Ù¨', '9': 'Ù©'
                    };
                    
                    let fixed = content;
                    
                    // Convert digits (but be careful not to break LaTeX commands)
                    Object.entries(digitMap).forEach(([en, ar]) => {
                        const regex = new RegExp(`(?<!\\\\[a-zA-Z]*)(?<![a-zA-Z])${en}(?![a-zA-Z])`, 'g');
                        fixed = fixed.replace(regex, ar);
                    });
                    
                    return fixed;
                },

                // Fix English variables in math-field content
                fixEnglishVariablesInMathFields(text, grade) {
                    if (!/[Ø£-ÙŠ]/.test(text)) return text;
                    
                    const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    if (!arabicGrades.includes(grade)) return text;
                    
                    let fixed = text;
                    
                    // Only fix inside math-field tags
                    fixed = fixed.replace(/<math-field([^>]*value=["'])([^"']*)((["'][^>]*)>)([^<]*)<\/math-field>/g, 
                        (match, before, valueAttr, middle, afterValue, innerContent) => {
                            
                            // Fix value attribute
                            let fixedValue = this.convertVariablesInMathContent(valueAttr);
                            
                            // Fix inner content
                            let fixedInner = this.convertVariablesInMathContent(innerContent);
                            
                            return `<math-field${before}${fixedValue}${middle}${fixedInner}</math-field>`;
                        });
                    
                    return fixed;
                },

                // Convert variables in math content
                convertVariablesInMathContent(content) {
                    const variableMap = {
                        'x': 'Ø³', 'y': 'Øµ', 'z': 'Ø¹', 'a': 'Ø£', 'b': 'Ø¨', 'c': 'Ø¬Ù€',
                        'd': 'Ø¯', 'f': 'Ùˆ', 'g': 'Ø²', 'h': 'Ø­', 'k': 'Ùƒ',
                        'l': 'Ù„', 'm': 'Ù…', 'n': 'Ù†', 'p': 'Ø¹', 'q': 'Ù‚', 'r': 'Ø±',
                        't': 'Øª', 'v': 'Ù', 'w': 'Ùˆ',
                        // Additional symbols for specific contexts
                        'F': 'Ù', 'i': 'ÙŠ', 'j': 'Ø¬', 'T': 'Øª', 'A': 'Ø£', 'P': 'Ø¨', 
                        'C': 'Ø¬', 'R': 'Ø±', 'N': 'Ù†'
                    };
                    
                    let fixed = content;
                    
                    // Convert variables (but be careful not to break LaTeX commands)
                    Object.entries(variableMap).forEach(([en, ar]) => {
                        const regex = new RegExp(`(?<!\\\\[a-zA-Z]*)(?<![a-zA-Z])${en}(?![a-zA-Z])`, 'g');
                        fixed = fixed.replace(regex, ar);
                    });
                    
                    return fixed;
                },

                // Fix punctuation in plain text
                fixWrongPunctuation(text) {
                    if (!/[Ø£-ÙŠ]/.test(text)) return text;
                    
                    let fixed = text;
                    
                    // Split by HTML tags to preserve them
                    const parts = fixed.split(/(<[^>]+>)/g);
                    
                    fixed = parts.map((part, index) => {
                        // If it's an HTML tag, don't touch it
                        if (part.startsWith('<')) {
                            return part;
                        }
                        
                        // Otherwise, fix punctuation
                        let fixedPart = part;
                        
                        // Convert punctuation (but preserve HTML entities)
                        fixedPart = fixedPart.replace(/(?<!&[#a-zA-Z0-9]*),/g, 'ØŒ');  // comma
                        fixedPart = fixedPart.replace(/(?<!&[#a-zA-Z0-9]*);/g, 'Ø›');  // semicolon
                        fixedPart = fixedPart.replace(/(?<!&[#a-zA-Z0-9]*)\?/g, 'ØŸ'); // question mark
                        
                        return fixedPart;
                    }).join('');
                    
                    return fixed;
                },

                // Check translation quality
                checkTranslationQuality(originalText, translatedText) {
                    const issues = [];

                    // ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø£Ø±Ù‚Ø§Ù… Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
                    const englishNumbers = /[0-9]/g;
                    if (englishNumbers.test(translatedText)) {
                        issues.push('ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø£Ø±Ù‚Ø§Ù… Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©');
                    }

                    // ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø±Ù…ÙˆØ² Ø±ÙŠØ§Ø¶ÙŠØ© Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
                    const englishSymbols = /[x,y,z]/g;
                    if (englishSymbols.test(translatedText)) {
                        issues.push('ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ù…ÙˆØ² Ø±ÙŠØ§Ø¶ÙŠØ© Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©');
                    }

                    // ÙØ­Øµ Ø·ÙˆÙ„ Ø§Ù„Ù†Øµ
                    const originalLength = originalText.length;
                    const translatedLength = translatedText.length;
                    const lengthRatio = translatedLength / originalLength;

                    if (lengthRatio < 0.5) {
                        issues.push('Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ù‚ØµÙŠØ± Ø¬Ø¯Ø§Ù‹');
                    } else if (lengthRatio > 2) {
                        issues.push('Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹');
                    }

                    return {
                        quality: issues.length === 0 ? 'good' : 'poor',
                        issues: issues,
                        score: Math.max(0, 100 - (issues.length * 20))
                    };
                },

                // Improve translation
                improveTranslation(originalText, translatedText) {
                    let improved = translatedText;

                    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ø¥Ù„Ù‰ Ø¹Ø±Ø¨ÙŠØ©
                    improved = this.convertEnglishNumbersToArabic(improved);

                    // ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
                    improved = this.translateMathSymbols(improved);

                    // ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
                    improved = this.translateMathTerms(improved);

                    return improved;
                },

                // Convert English numbers to Arabic
                convertEnglishNumbersToArabic(text) {
                    const numberMap = {
                        '0': 'Ù ', '1': 'Ù¡', '2': 'Ù¢', '3': 'Ù£', '4': 'Ù¤',
                        '5': 'Ù¥', '6': 'Ù¦', '7': 'Ù§', '8': 'Ù¨', '9': 'Ù©'
                    };

                    let converted = text;
                    Object.entries(numberMap).forEach(([english, arabic]) => {
                        converted = converted.replace(new RegExp(english, 'g'), arabic);
                    });

                    return converted;
                },

                // Translate math symbols
                translateMathSymbols(text) {
                    const symbolMap = {
                        // Variables
                        'x': 'Ø³', 'y': 'Øµ', 'z': 'Ø¹',
                        'a': 'Ø£', 'b': 'Ø¨', 'c': 'Ø¬Ù€',
                        'd': 'Ø¯', 'e': 'Ù‡Ù€', 'f': 'Ùˆ',
                        'g': 'Ø²', 'h': 'Ø­', 'i': 'Ø·',
                        'j': 'ÙŠ', 'k': 'Ùƒ', 'l': 'Ù„',
                        'm': 'Ù…', 'n': 'Ù†', 'p': 'Ø¹',
                        'q': 'Ù‚', 'r': 'Ø±', 's': 'Ø³',
                        't': 'Øª', 'u': 'Ø´', 'v': 'Ø¸',
                        'w': 'Ùˆ',
                        // Additional symbols for specific contexts
                        'F': 'Ù', 'T': 'Øª', 'A': 'Ø£', 'P': 'Ø¨', 'C': 'Ø¬', 'R': 'Ø±', 'N': 'Ù†'
                    };

                    let translated = text;
                    Object.entries(symbolMap).forEach(([english, arabic]) => {
                        // Use word boundaries to avoid replacing inside LaTeX commands
                        translated = translated.replace(new RegExp(`\\b${english}\\b`, 'g'), arabic);
                    });

                    return translated;
                },

                // Translate math terms
                translateMathTerms(text) {
                    const termMap = {
                        // Trigonometric functions
                        'sin': 'Ø¬Ø§', 'cos': 'Ø¬ØªØ§', 'tan': 'Ø¸Ø§',
                        'cot': 'Ø¸ØªØ§', 'sec': 'Ù‚Ø§', 'csc': 'Ù‚ØªØ§',
                        'arcsin': 'Ø¬Ø§â»Â¹', 'arccos': 'Ø¬ØªØ§â»Â¹', 'arctan': 'Ø¸Ø§â»Â¹',
                        'arccot': 'Ø¸ØªØ§â»Â¹', 'arcsec': 'Ù‚Ø§â»Â¹', 'arccsc': 'Ù‚ØªØ§â»Â¹',
                        'sinh': 'Ø¬Ø§Ø²', 'cosh': 'Ø¬ØªØ§Ø²', 'tanh': 'Ø¸Ø§Ø²',
                        'coth': 'Ø¸ØªØ§Ø²', 'sech': 'Ù‚Ø§Ø²', 'csch': 'Ù‚ØªØ§Ø²',
                        
                        // Logarithmic functions
                        'log': 'Ù„Ùˆ', 'ln': 'Ù„Ùˆ', 'lg': 'Ù„Ùˆ',
                        'exp': 'Ù‡Ù€',
                        
                        // Matrix operations
                        'det': 'Ù…Ø­Ø¯Ø¯', 'matrix': 'Ù…ØµÙÙˆÙØ©', 'vector': 'Ù…ØªØ¬Ù‡',
                        'transpose': 'Ù…Ù†Ù‚ÙˆÙ„', 'inverse': 'Ù…Ø¹ÙƒÙˆØ³',
                        'determinant': 'Ø§Ù„Ù…Ø­Ø¯Ø¯', 'trace': 'Ø§Ù„Ø£Ø«Ø±',
                        'rank': 'Ø§Ù„Ø±ØªØ¨Ø©', 'dimension': 'Ø§Ù„Ø¨Ø¹Ø¯',
                        'eigenvalue': 'Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø°Ø§ØªÙŠØ©', 'eigenvector': 'Ø§Ù„Ù…ØªØ¬Ù‡ Ø§Ù„Ø°Ø§ØªÙŠ',
                        'diagonal': 'Ù‚Ø·Ø±ÙŠ', 'identity': 'Ø§Ù„ÙˆØ­Ø¯Ø©',
                        'null space': 'Ø§Ù„ÙØ¶Ø§Ø¡ Ø§Ù„ØµÙØ±ÙŠ', 'row': 'ØµÙ', 'column': 'Ø¹Ù…ÙˆØ¯',
                        'span': 'Ø§Ù…ØªØ¯Ø§Ø¯', 'basis': 'Ø£Ø³Ø§Ø³',
                        
                        // Calculus terms
                        'function': 'Ø¯Ø§Ù„Ø©', 'derivative': 'Ù…Ø´ØªÙ‚', 'integral': 'ØªÙƒØ§Ù…Ù„',
                        'limit': 'Ù†Ù‡Ø§ÙŠØ©', 'sum': 'Ù…Ø¬Ù…ÙˆØ¹', 'product': 'Ø­Ø§ØµÙ„ Ø¶Ø±Ø¨',
                        'differential': 'ØªÙØ§Ø¶Ù„', 'gradient': 'ØªØ¯Ø±Ø¬',
                        'divergence': 'ØªØ¨Ø§Ø¹Ø¯', 'curl': 'Ø¯ÙˆØ±Ø§Ù†',
                        'partial': 'Ø¬Ø²Ø¦ÙŠ', 'total': 'ÙƒÙ„ÙŠ',
                        'definite': 'Ù…Ø­Ø¯Ø¯', 'indefinite': 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
                        'domain': 'Ø§Ù„Ù…Ø¬Ø§Ù„', 'range': 'Ø§Ù„Ù…Ø¯Ù‰', 'codomain': 'Ø§Ù„Ù…Ø¬Ø§Ù„ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„',
                        'image': 'Ø§Ù„ØµÙˆØ±Ø©', 'preimage': 'Ø£ØµÙ„ Ø§Ù„ØµÙˆØ±Ø©',
                        'continuous': 'Ù…ØªØµÙ„', 'discontinuous': 'Ù…Ù†ÙØµÙ„',
                        'differentiable': 'Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø§Ø´ØªÙ‚Ø§Ù‚',
                        
                        // Set theory
                        'set': 'Ù…Ø¬Ù…ÙˆØ¹Ø©', 'subset': 'Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬Ø²Ø¦ÙŠØ©',
                        'union': 'Ø§ØªØ­Ø§Ø¯', 'intersection': 'ØªÙ‚Ø§Ø·Ø¹',
                        'element': 'Ø¹Ù†ØµØ±', 'complement': 'Ù…ØªÙ…Ù…',
                        'empty set': 'Ù…Ø¬Ù…ÙˆØ¹Ø© Ø®Ø§Ù„ÙŠØ©', 'null set': 'Ù…Ø¬Ù…ÙˆØ¹Ø© Ø®Ø§Ù„ÙŠØ©',
                        'proper subset': 'Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬Ø²Ø¦ÙŠØ© Ø­Ù‚ÙŠÙ‚ÙŠØ©',
                        'universal set': 'Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„Ø´Ø§Ù…Ù„Ø©',
                        'disjoint': 'Ù…Ù†ÙØµÙ„ØªØ§Ù†', 'partition': 'ØªØ¬Ø²Ø¦Ø©',
                        
                        // Geometry
                        'angle': 'Ø²Ø§ÙˆÙŠØ©', 'triangle': 'Ù…Ø«Ù„Ø«', 'circle': 'Ø¯Ø§Ø¦Ø±Ø©',
                        'square': 'Ù…Ø±Ø¨Ø¹', 'rectangle': 'Ù…Ø³ØªØ·ÙŠÙ„',
                        'polygon': 'Ù…Ø¶Ù„Ø¹', 'sphere': 'ÙƒØ±Ø©', 'cylinder': 'Ø£Ø³Ø·ÙˆØ§Ù†Ø©',
                        'cone': 'Ù…Ø®Ø±ÙˆØ·', 'pyramid': 'Ù‡Ø±Ù…',
                        'radius': 'Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±', 'diameter': 'Ø§Ù„Ù‚Ø·Ø±',
                        'perimeter': 'Ø§Ù„Ù…Ø­ÙŠØ·', 'area': 'Ø§Ù„Ù…Ø³Ø§Ø­Ø©', 'volume': 'Ø§Ù„Ø­Ø¬Ù…',
                        'circumference': 'Ø§Ù„Ù…Ø­ÙŠØ·', 'chord': 'ÙˆØªØ±',
                        'tangent': 'Ù…Ù…Ø§Ø³', 'secant': 'Ù‚Ø§Ø·Ø¹',
                        'arc': 'Ù‚ÙˆØ³', 'sector': 'Ù‚Ø·Ø§Ø¹',
                        'segment': 'Ù‚Ø·Ø¹Ø©', 'vertex': 'Ø±Ø£Ø³', 'vertices': 'Ø±Ø¤ÙˆØ³',
                        'edge': 'Ø­Ø±Ù', 'face': 'ÙˆØ¬Ù‡',
                        'altitude': 'Ø§Ø±ØªÙØ§Ø¹', 'median': 'Ù…ØªÙˆØ³Ø·',
                        'bisector': 'Ù…Ù†ØµÙ', 'hypotenuse': 'Ø§Ù„ÙˆØªØ±',
                        'adjacent': 'Ù…Ø¬Ø§ÙˆØ±', 'opposite': 'Ù…Ù‚Ø§Ø¨Ù„',
                        'acute': 'Ø­Ø§Ø¯', 'obtuse': 'Ù…Ù†ÙØ±Ø¬', 'right': 'Ù‚Ø§Ø¦Ù…',
                        'isosceles': 'Ù…ØªØ³Ø§ÙˆÙŠ Ø§Ù„Ø³Ø§Ù‚ÙŠÙ†', 'equilateral': 'Ù…ØªØ³Ø§ÙˆÙŠ Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹',
                        'scalene': 'Ù…Ø®ØªÙ„Ù Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹',
                        'parallelogram': 'Ù…ØªÙˆØ§Ø²ÙŠ Ø£Ø¶Ù„Ø§Ø¹', 'trapezoid': 'Ø´Ø¨Ù‡ Ù…Ù†Ø­Ø±Ù',
                        'rhombus': 'Ù…Ø¹ÙŠÙ†', 'kite': 'Ø·Ø§Ø¦Ø±Ø© ÙˆØ±Ù‚ÙŠØ©',
                        'pentagon': 'Ø®Ù…Ø§Ø³ÙŠ', 'hexagon': 'Ø³Ø¯Ø§Ø³ÙŠ',
                        'heptagon': 'Ø³Ø¨Ø§Ø¹ÙŠ', 'octagon': 'Ø«Ù…Ø§Ù†ÙŠ',
                        'ellipse': 'Ù‚Ø·Ø¹ Ù†Ø§Ù‚Øµ', 'parabola': 'Ù‚Ø·Ø¹ Ù…ÙƒØ§ÙØ¦',
                        'hyperbola': 'Ù‚Ø·Ø¹ Ø²Ø§Ø¦Ø¯',
                        
                        // Algebra
                        'equation': 'Ù…Ø¹Ø§Ø¯Ù„Ø©', 'inequality': 'Ù…ØªØ¨Ø§ÙŠÙ†Ø©',
                        'expression': 'Ù…Ù‚Ø¯Ø§Ø±', 'polynomial': 'ÙƒØ«ÙŠØ± Ø­Ø¯ÙˆØ¯',
                        'coefficient': 'Ù…Ø¹Ø§Ù…Ù„', 'constant': 'Ø«Ø§Ø¨Øª',
                        'variable': 'Ù…ØªØºÙŠØ±', 'exponent': 'Ø£Ø³',
                        'root': 'Ø¬Ø°Ø±', 'sqrt': 'Ø¬Ø°Ø±', 'square root': 'Ø§Ù„Ø¬Ø°Ø± Ø§Ù„ØªØ±Ø¨ÙŠØ¹ÙŠ',
                        'cube root': 'Ø§Ù„Ø¬Ø°Ø± Ø§Ù„ØªÙƒØ¹ÙŠØ¨ÙŠ',
                        'quadratic': 'ØªØ±Ø¨ÙŠØ¹ÙŠ', 'cubic': 'ØªÙƒØ¹ÙŠØ¨ÙŠ',
                        'linear': 'Ø®Ø·ÙŠ', 'binomial': 'Ø°Ùˆ Ø­Ø¯ÙŠÙ†',
                        'trinomial': 'Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø­Ø¯ÙˆØ¯', 'monomial': 'ÙˆØ­ÙŠØ¯ Ø§Ù„Ø­Ø¯',
                        'factor': 'Ø¹Ø§Ù…Ù„', 'factorize': 'ØªØ­Ù„ÙŠÙ„',
                        'expand': 'ÙÙƒ', 'simplify': 'ØªØ¨Ø³ÙŠØ·',
                        'solve': 'Ø­Ù„', 'solution': 'Ø§Ù„Ø­Ù„',
                        
                        // Statistics & Probability
                        'mean': 'Ø§Ù„ÙˆØ³Ø·', 'median': 'Ø§Ù„ÙˆØ³ÙŠØ·', 'mode': 'Ø§Ù„Ù…Ù†ÙˆØ§Ù„',
                        'variance': 'Ø§Ù„ØªØ¨Ø§ÙŠÙ†', 'deviation': 'Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù',
                        'probability': 'Ø§Ø­ØªÙ…Ø§Ù„', 'distribution': 'ØªÙˆØ²ÙŠØ¹',
                        'sample': 'Ø¹ÙŠÙ†Ø©', 'population': 'Ù…Ø¬ØªÙ…Ø¹',
                        'standard deviation': 'Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠ',
                        'random': 'Ø¹Ø´ÙˆØ§Ø¦ÙŠ', 'experiment': 'ØªØ¬Ø±Ø¨Ø©',
                        'event': 'Ø­Ø¯Ø«', 'outcome': 'Ù†ØªÙŠØ¬Ø©',
                        'frequency': 'Ø§Ù„ØªÙƒØ±Ø§Ø±', 'relative frequency': 'Ø§Ù„ØªÙƒØ±Ø§Ø± Ø§Ù„Ù†Ø³Ø¨ÙŠ',
                        'percentile': 'Ø§Ù„Ù…Ø¦ÙŠÙ†ÙŠ', 'quartile': 'Ø§Ù„Ø±Ø¨ÙŠØ¹ÙŠ',
                        'correlation': 'Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·', 'regression': 'Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø±',
                        
                        // Combinatorics
                        'nCr': 'Ù†ØªØ±', 'nPr': 'Ù†Ù„Ø±',
                        'combination': 'ØªÙˆØ§ÙÙŠÙ‚', 'permutation': 'ØªØ¨Ø§Ø¯ÙŠÙ„',
                        'C': 'Øª', 'P': 'Ù„',
                        'factorial': 'Ù…Ø¶Ø±ÙˆØ¨', 'choose': 'Ø§Ø®ØªÙŠØ§Ø±',
                        
                        // Greek letters (for reference in text)
                        'alpha': 'Ø£Ù„ÙØ§', 'beta': 'Ø¨ÙŠØªØ§', 'gamma': 'Ø¬Ø§Ù…Ø§', 'delta': 'Ø¯Ù„ØªØ§',
                        'epsilon': 'Ø¥Ø¨Ø³ÙŠÙ„ÙˆÙ†', 'zeta': 'Ø²ÙŠØªØ§', 'eta': 'Ø¥ÙŠØªØ§', 'theta': 'Ø«ÙŠØªØ§',
                        'iota': 'ÙŠÙˆØªØ§', 'kappa': 'ÙƒØ§Ø¨Ø§', 'lambda': 'Ù„Ø§Ù…Ø¯Ø§', 'mu': 'Ù…ÙŠÙˆ',
                        'nu': 'Ù†ÙŠÙˆ', 'xi': 'ÙƒØ³ÙŠ', 'omicron': 'Ø£ÙˆÙ…ÙŠÙƒØ±ÙˆÙ†', 'pi': 'Ø¨Ø§ÙŠ',
                        'rho': 'Ø±Ùˆ', 'sigma': 'Ø³ÙŠØ¬Ù…Ø§', 'tau': 'ØªØ§Ùˆ', 'upsilon': 'Ø£ÙˆØ¨Ø³ÙŠÙ„ÙˆÙ†',
                        'phi': 'ÙØ§ÙŠ', 'chi': 'ÙƒØ§ÙŠ', 'psi': 'Ø¨Ø³Ø§ÙŠ', 'omega': 'Ø£ÙˆÙ…ÙŠØ¬Ø§',
                        
                        // Number theory
                        'prime': 'Ø£ÙˆÙ„ÙŠ', 'composite': 'Ù…Ø±ÙƒØ¨',
                        'even': 'Ø²ÙˆØ¬ÙŠ', 'odd': 'ÙØ±Ø¯ÙŠ',
                        'divisor': 'Ù‚Ø§Ø³Ù…', 'multiple': 'Ù…Ø¶Ø§Ø¹Ù',
                        'gcd': 'Ù‚.Ù….Ø£', 'lcm': 'Ù….Ù….Ø£',
                        'quotient': 'Ø®Ø§Ø±Ø¬ Ø§Ù„Ù‚Ø³Ù…Ø©', 'remainder': 'Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù‚Ø³Ù…Ø©',
                        'modulo': 'Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹Ù„Ù‰', 'mod': 'Ø¨Ø§Ù‚ÙŠ',
                        
                        // Logic & Proofs
                        'theorem': 'Ù†Ø¸Ø±ÙŠØ©', 'lemma': 'Ù…Ø¨Ø±Ù‡Ù†Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©',
                        'corollary': 'Ù†ØªÙŠØ¬Ø©', 'proposition': 'Ù‚Ø¶ÙŠØ©',
                        'axiom': 'Ø¨Ø¯ÙŠÙ‡ÙŠØ©', 'postulate': 'Ù…Ø³Ù„Ù…Ø©',
                        'proof': 'Ø¨Ø±Ù‡Ø§Ù†', 'qed': 'Ù‚.Ø£.Ø¨',
                        'if and only if': 'Ø¥Ø°Ø§ ÙˆÙÙ‚Ø· Ø¥Ø°Ø§', 'iff': 'Ø¥.Ù.Ø¥',
                        'implies': 'ÙŠØ³ØªÙ„Ø²Ù…', 'therefore': 'Ø¥Ø°Ù†',
                        'because': 'Ù„Ø£Ù†', 'such that': 'Ø¨Ø­ÙŠØ«',
                        'for all': 'Ù„ÙƒÙ„', 'there exists': 'ÙŠÙˆØ¬Ø¯',
                        
                        // Relations
                        'equals': 'ÙŠØ³Ø§ÙˆÙŠ', 'not equal': 'Ù„Ø§ ÙŠØ³Ø§ÙˆÙŠ',
                        'greater than': 'Ø£ÙƒØ¨Ø± Ù…Ù†', 'less than': 'Ø£ØµØºØ± Ù…Ù†',
                        'greater than or equal': 'Ø£ÙƒØ¨Ø± Ù…Ù† Ø£Ùˆ ÙŠØ³Ø§ÙˆÙŠ',
                        'less than or equal': 'Ø£ØµØºØ± Ù…Ù† Ø£Ùˆ ÙŠØ³Ø§ÙˆÙŠ',
                        'approximately': 'ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹', 'equivalent': 'Ù…ÙƒØ§ÙØ¦',
                        'congruent': 'Ù…ØªØ·Ø§Ø¨Ù‚', 'similar': 'Ù…ØªØ´Ø§Ø¨Ù‡',
                        'proportional': 'Ù…ØªÙ†Ø§Ø³Ø¨', 'parallel': 'Ù…ÙˆØ§Ø²ÙŠ',
                        'perpendicular': 'Ø¹Ù…ÙˆØ¯ÙŠ',
                        
                        // Physics terms
                        'velocity': 'Ø§Ù„Ø³Ø±Ø¹Ø©', 'acceleration': 'Ø§Ù„ØªØ³Ø§Ø±Ø¹',
                        'force': 'Ø§Ù„Ù‚ÙˆØ©', 'mass': 'Ø§Ù„ÙƒØªÙ„Ø©', 'weight': 'Ø§Ù„ÙˆØ²Ù†',
                        'energy': 'Ø§Ù„Ø·Ø§Ù‚Ø©', 'power': 'Ø§Ù„Ù‚Ø¯Ø±Ø©',
                        'momentum': 'Ø§Ù„Ø²Ø®Ù…', 'impulse': 'Ø§Ù„Ø¯ÙØ¹',
                        'work': 'Ø§Ù„Ø´ØºÙ„', 'pressure': 'Ø§Ù„Ø¶ØºØ·',
                        'density': 'Ø§Ù„ÙƒØ«Ø§ÙØ©', 'temperature': 'Ø¯Ø±Ø¬Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©',
                        'charge': 'Ø§Ù„Ø´Ø­Ù†Ø©', 'current': 'Ø§Ù„ØªÙŠØ§Ø±',
                        'voltage': 'Ø§Ù„Ø¬Ù‡Ø¯', 'resistance': 'Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©',
                        'frequency': 'Ø§Ù„ØªØ±Ø¯Ø¯', 'wavelength': 'Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙŠ',
                        'amplitude': 'Ø§Ù„Ø³Ø¹Ø©', 'period': 'Ø§Ù„Ø¯ÙˆØ±Ø©',
                        'kinetic': 'Ø­Ø±ÙƒÙŠ', 'potential': 'ÙƒØ§Ù…Ù†',
                        'thermal': 'Ø­Ø±Ø§Ø±ÙŠ', 'mechanical': 'Ù…ÙŠÙƒØ§Ù†ÙŠÙƒÙŠ',
                        'electric': 'ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ', 'magnetic': 'Ù…ØºÙ†Ø§Ø·ÙŠØ³ÙŠ',
                        'gravitational': 'Ø¬Ø§Ø°Ø¨ÙŠ',
                        
                        // Advanced operations
                        'absolute value': 'Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„Ù‚Ø©', 'abs': 'Ù‚.Ù…',
                        'floor': 'Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„ØµØ­ÙŠØ­', 'ceiling': 'Ø§Ù„Ø³Ù‚Ù',
                        'round': 'ØªÙ‚Ø±ÙŠØ¨', 'truncate': 'Ø¨ØªØ±',
                        'reciprocal': 'Ø§Ù„Ù…Ù‚Ù„ÙˆØ¨', 'conjugate': 'Ø§Ù„Ù…Ø±Ø§ÙÙ‚',
                        'magnitude': 'Ø§Ù„Ù…Ù‚Ø¯Ø§Ø±', 'argument': 'Ø§Ù„Ø³Ø¹Ø©',
                        'real part': 'Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ', 'imaginary part': 'Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„ØªØ®ÙŠÙ„ÙŠ',
                        
                        // Constants
                        'pi': 'Ï€', 'infinity': 'âˆ', 'euler': 'Ù‡Ù€',
                        
                        // Operations
                        'maximum': 'Ø§Ù„Ø£ÙƒØ¨Ø±', 'minimum': 'Ø§Ù„Ø£ØµØºØ±',
                        'max': 'Ø§Ù„Ø£ÙƒØ¨Ø±', 'min': 'Ø§Ù„Ø£ØµØºØ±',
                        'supremum': 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¹Ù„Ù‰', 'infimum': 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰',
                        'sup': 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¹Ù„Ù‰', 'inf': 'Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰'
                    };

                    let translated = text;
                    
                    // Sort by length (longest first) to avoid partial replacements
                    const sortedTerms = Object.entries(termMap).sort((a, b) => b[0].length - a[0].length);
                    
                    sortedTerms.forEach(([english, arabic]) => {
                        // Special handling for C and P with subscript/superscript numbers
                        if (english === 'C' || english === 'P') {
                            // Match C or P when followed by subscript or superscript numbers
                            const regex = new RegExp(`\\b${english}(?=[â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â°Â¹Â²Â³â´âµâ¶â·â¸â¹])`, 'g');
                            translated = translated.replace(regex, arabic);
                            
                            // Also match when preceded by superscript numbers
                            const regex2 = new RegExp(`(?<=[â°Â¹Â²Â³â´âµâ¶â·â¸â¹])${english}(?=[â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰]|\\s|$)`, 'g');
                            translated = translated.replace(regex2, arabic);
                        } else {
                            // Use word boundaries for better matching
                            const regex = new RegExp(`\\b${english}\\b`, 'gi');
                            translated = translated.replace(regex, arabic);
                        }
                    });

                    return translated;
                },

                // Generate quality report
                generateQualityReport(originalData, translatedData) {
                    const report = {
                        totalParts: 0,
                        qualityIssues: 0,
                        mathFieldIssues: 0,
                        htmlIssues: 0,
                        translationIssues: 0,
                        recommendations: []
                    };

                    if (originalData.parts && translatedData.parts) {
                        report.totalParts = originalData.parts.length;

                        originalData.parts.forEach((originalPart, index) => {
                            const translatedPart = translatedData.parts[index];
                            if (!translatedPart) return;

                            // ÙØ­Øµ stem
                            if (originalPart.stem && translatedPart.stem) {
                                const quality = this.checkTranslationQuality(originalPart.stem, translatedPart.stem);
                                if (quality.quality === 'poor') {
                                    report.qualityIssues++;
                                    report.translationIssues += quality.issues.length;
                                }
                            }

                            // ÙØ­Øµ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª
                            if (originalPart.choices && translatedPart.choices) {
                                originalPart.choices.forEach((originalChoice, choiceIndex) => {
                                    const translatedChoice = translatedPart.choices[choiceIndex];
                                    if (!translatedChoice) return;

                                    if (originalChoice.html_content && translatedChoice.html_content) {
                                        const quality = this.checkTranslationQuality(originalChoice.html_content, translatedChoice.html_content);
                                        if (quality.quality === 'poor') {
                                            report.qualityIssues++;
                                            report.translationIssues += quality.issues.length;
                                        }
                                    }
                                });
                            }
                        });
                    }

                    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆØµÙŠØ§Øª
                    if (report.translationIssues > 0) {
                        report.recommendations.push('ØªØ­Ø³ÙŠÙ† ØªØ±Ø¬Ù…Ø© Ø§Ù„Ù†ØµÙˆØµ');
                    }

                    if (report.mathFieldIssues > 0) {
                        report.recommendations.push('Ø¥ØµÙ„Ø§Ø­ Ù…Ø´Ø§ÙƒÙ„ math-field');
                    }

                    if (report.htmlIssues > 0) {
                        report.recommendations.push('Ø¥ØµÙ„Ø§Ø­ Ù…Ø´Ø§ÙƒÙ„ HTML');
                    }

                    return report;
                },

                // Convert LaTeX symbols to Arabic (Advanced LaTeX Processing)
                convertLatexSymbols(str, toArabic) {
                    if (!str || !toArabic) return str;
                    
                    const symbolMap = {
                        'x': 'Ø³', 'y': 'Øµ', 'z': 'Ø¹', 'a': 'Ø£', 'b': 'Ø¨', 'c': 'Ø¬Ù€', 
                        'd': 'Ø¯', 'f': 'Ùˆ', 'g': 'Ø²', 'h': 'Ø­', 'k': 'Ùƒ',
                        'l': 'Ù„', 'm': 'Ù…', 'n': 'Ù†', 'p': 'Ø¹', 'q': 'Ù‚', 'r': 'Ø±',
                        't': 'Øª', 'v': 'Ù', 'w': 'Ùˆ',
                        // Additional symbols for specific contexts
                        'F': 'Ù', 'i': 'ÙŠ', 'j': 'Ø¬', 'T': 'Øª', 'A': 'Ø£', 'P': 'Ø¨', 
                        'C': 'Ø¬', 'R': 'Ø±', 'N': 'Ù†'
                    };
                    
                    // Process LaTeX blocks ($..$ and $$...$$)
                    return str.replace(/(\$\$?)([\s\S]*?)(\$\$?)/g, (match, open, content, close) => {
                        let converted = this.convertDigits(content, true);
                        
                        // Convert standalone variables (not part of LaTeX commands)
                        converted = converted.replace(/(?<!\\)(?<![a-zA-Z])([a-zA-Z])(?![a-zA-Z])/g, (m, letter) => {
                            const prev = converted.charAt(converted.indexOf(m) - 1);
                            if (prev === '\\') return letter;
                            return symbolMap[letter.toLowerCase()] || letter;
                        });
                        
                        // Reverse columns in cases/dcases for RTL
                        converted = converted.replace(/\\begin\{(d?cases)\}([\s\S]*?)\\end\{\1\}/g, (caseMatch, envType, caseContent) => {
                            const processed = caseContent.replace(/(.*?)(&amp;|&)(.*?)(\\\\|(?=\n)|$)/g, (rowMatch, left, amp, right, ending) => {
                                if (left.trim() || right.trim()) {
                                    return `${right.trim()} ${amp} ${left.trim()}${ending}`;
                                }
                                return rowMatch;
                            });
                            return `\\begin{${envType}}${processed}\\end{${envType}}`;
                        });
                        
                        return open + converted + close;
                    });
                },

                // Reverse cases/dcases columns for RTL (Advanced LaTeX Processing)
                reverseCasesColumns(str, ctx = { subject: 'None', grade: 'None' }) {
                    const mathArabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    if (ctx.subject === 'Mathematics' && mathArabicGrades.includes(ctx.grade)) {
                        let result = str || '';
                        
                        console.log('ğŸ”„ [reverseCasesColumns] Starting column reversal for RTL');
                        
                        // Reverse columns in cases/dcases environment
                        result = result.replace(/\\begin\{(d?cases)\}([\s\S]*?)\\end\{\1\}/g, (match, envType, content) => {
                            console.log('ğŸ“Š [reverseCasesColumns] Found cases environment:', envType);
                            console.log('ğŸ“Š [reverseCasesColumns] Original content:', content);
                            
                            const processed = content.replace(/(.*?)(&amp;|&)(.*?)(\\\\|(?=\n)|$)/g, (rowMatch, left, amp, right, ending) => {
                                if (left.trim() || right.trim()) {
                                    const reversed = `${right.trim()} ${amp} ${left.trim()}${ending}`;
                                    console.log('ğŸ”€ [reverseCasesColumns] Reversed row:', rowMatch, '->', reversed);
                                    return reversed;
                                }
                                return rowMatch;
                            });
                            
                            console.log('ğŸ“Š [reverseCasesColumns] Processed content:', processed);
                            return `\\begin{${envType}}${processed}\\end{${envType}}`;
                        });
                        
                        console.log('âœ… [reverseCasesColumns] Completed column reversal');
                        return result;
                    }
                    return str;
                },

                // NEW: Fix commas in math-field tags to ensure they are Arabic
                fixMathFieldCommas(htmlString, ctx = { subject: 'None', grade: 'None' }) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    if (ctx.subject !== 'Mathematics') return htmlString;
                    
                    console.log('ğŸ”§ [fixMathFieldCommas] Starting comma fix for math-field tags');
                    
                    let result = htmlString;
                    
                    // Fix commas in value attribute and inner content of math-field tags
                    result = result.replace(/<math-field([^>]*?)(?:value=["']([^"']*?)["'])?([^>]*?)>([\s\S]*?)<\/math-field>/gi, 
                        (match, before, valueAttr, after, innerContent) => {
                            console.log('ğŸ” [fixMathFieldCommas] Processing math-field:', { 
                                valueAttr: valueAttr ? valueAttr.substring(0, 50) : 'none',
                                innerContent: innerContent ? innerContent.substring(0, 50) : 'none'
                            });
                            
                            // Process value attribute
                            let processedValue = valueAttr || '';
                            if (processedValue) {
                                // Decode HTML entities
                                let decoded = processedValue
                                    .replace(/&amp;/g, '&')
                                    .replace(/&lt;/g, '<')
                                    .replace(/&gt;/g, '>')
                                    .replace(/&quot;/g, '"');
                                
                                // Replace English commas with Arabic commas
                                decoded = decoded.replace(/,/g, 'ØŒ');
                                
                                // Re-encode HTML entities
                                processedValue = decoded
                                    .replace(/&/g, '&amp;')
                                    .replace(/</g, '&lt;')
                                    .replace(/>/g, '&gt;')
                                    .replace(/"/g, '&quot;');
                                
                                console.log('âœ… [fixMathFieldCommas] Fixed value attribute:', processedValue.substring(0, 50));
                            }
                            
                            // Process inner content
                            let processedInner = innerContent || '';
                            if (processedInner) {
                                // Decode HTML entities
                                let decoded = processedInner
                                    .replace(/&amp;/g, '&')
                                    .replace(/&lt;/g, '<')
                                    .replace(/&gt;/g, '>')
                                    .replace(/&quot;/g, '"');
                                
                                // Replace English commas with Arabic commas
                                decoded = decoded.replace(/,/g, 'ØŒ');
                                
                                // Re-encode HTML entities
                                processedInner = decoded
                                    .replace(/&/g, '&amp;')
                                    .replace(/</g, '&lt;')
                                    .replace(/>/g, '&gt;')
                                    .replace(/"/g, '&quot;');
                                
                                console.log('âœ… [fixMathFieldCommas] Fixed inner content:', processedInner.substring(0, 50));
                            }
                            
                            // Determine direction based on grade
                            const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                            const shouldBeRTL = arabicGrades.includes(ctx.grade);
                            
                            // Ensure proper direction
                            let dirAttr = after;
                            if (!dirAttr.includes('dir=')) {
                                dirAttr = ` dir="${shouldBeRTL ? 'rtl' : 'ltr'}"` + dirAttr;
                            } else {
                                const targetDir = shouldBeRTL ? 'rtl' : 'ltr';
                                dirAttr = dirAttr.replace(/dir=["'][^"']*["']/gi, `dir="${targetDir}"`);
                            }
                            
                            // Reconstruct the tag
                            const valueStr = processedValue ? ` value="${processedValue}"` : '';
                            return `<math-field${before}${valueStr}${dirAttr}>${processedInner}</math-field>`;
                        }
                    );
                    
                    console.log('âœ… [fixMathFieldCommas] Completed comma fix');
                    return result;
                },

                // Convert math field content with LaTeX support (Advanced LaTeX Processing)
                convertMathFieldContent(htmlString, toArabic) {
                    if (!htmlString || typeof htmlString !== 'string' || !toArabic) return htmlString;
                    
                    const symbolMap = {
                        'x': 'Ø³', 'y': 'Øµ', 'z': 'Ø¹', 'a': 'Ø£', 'b': 'Ø¨', 'c': 'Ø¬Ù€',
                        'd': 'Ø¯', 'f': 'Ùˆ', 'g': 'Ø²', 'h': 'Ø­', 'k': 'Ùƒ',
                        'l': 'Ù„', 'm': 'Ù…', 'n': 'Ù†', 'p': 'Ø¹', 'q': 'Ù‚', 'r': 'Ø±',
                        't': 'Øª', 'v': 'Ù', 'w': 'Ùˆ',
                        // Additional symbols for specific contexts
                        'F': 'Ù', 'i': 'ÙŠ', 'j': 'Ø¬', 'T': 'Øª', 'A': 'Ø£', 'P': 'Ø¨', 
                        'C': 'Ø¬', 'R': 'Ø±', 'N': 'Ù†'
                    };
                    
                    const convertLatex = (latex) => {
                        let result = this.convertDigits(latex, true);
                        
                        // Convert variables (not part of LaTeX commands)
                        Object.entries(symbolMap).forEach(([en, ar]) => {
                            const regex = new RegExp(`(?<!\\\\[a-zA-Z]*)(?<![a-zA-Z])${en}(?![a-zA-Z])`, 'g');
                            result = result.replace(regex, ar);
                        });
                        
                        return result;
                    };
                    
                    return htmlString.replace(/<math-field([^>]*value=["'])([^"']*)((["'][^>]*)>)([^<]*)<\/math-field>/g, 
                        (match, before, valueAttr, middle, afterValue, innerContent) => {
                        
                        // Decode, convert, and encode value attribute
                        let decodedValue = valueAttr.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"');
                        decodedValue = convertLatex(decodedValue);
                        const encodedValue = decodedValue.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        
                        // Decode, convert, and encode inner content
                        let decodedInner = innerContent.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"');
                        decodedInner = convertLatex(decodedInner);
                        const encodedInner = decodedInner.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        
                        return `<math-field${before}${encodedValue}${middle}${encodedInner}</math-field>`;
                    });
                },
                
                postProcess(htmlString, ctx = { subject: 'None', grade: 'None' }) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;

                    let out = htmlString;
                    
                    // ğŸ” Debug: Log the current context
                    if (ctx.subject === 'Mathematics') {
                        console.log('ğŸ“Š [Math PostProcess]', {
                            subject: ctx.subject,
                            grade: ctx.grade,
                            willConvertSymbols: this.shouldConvertSymbolsToArabic(ctx.subject, ctx.grade),
                            sampleText: htmlString.substring(0, 150)
                        });
                    }

                    const toArabic = this.wantsArabicIndicDigits(ctx.subject, ctx.grade);
                    const convertSymbols = this.shouldConvertSymbolsToArabic(ctx.subject, ctx.grade);

                    // --- Ø§Ø¨Ø¯Ø£ Ù…Ø¹Ø§Ù„Ø¬Ø© Math-Field ---
                    // Ù‡Ø°Ù‡ Ù‡ÙŠ Ø£Ù‡Ù… Ø®Ø·ÙˆØ© Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ value
                    out = out.replace(
                        /<math-field([^>]*)>([\s\S]*?)<\/math-field>/gi,
                        (match, allAttrs, innerContent) => {

                            // 1. Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                            const valueMatch = allAttrs.match(/value=["']([^"']*)["']/i);
                            let originalValue = valueMatch ? valueMatch[1] : innerContent.trim();

                            let processedValue = originalValue;

                            // 2. ØªØ·Ø¨ÙŠÙ‚ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ…Ø© (Value)
                            if (ctx.subject === 'Mathematics') {
                    if (toArabic) {
                                    processedValue = this.convertDigits(processedValue, true);
                                }
                                if (convertSymbols) {
                                    processedValue = this.convertSymbolsToArabic(processedValue);
                                    processedValue = this.fixSpecificMathTerms(processedValue);
                                    processedValue = this.fixArrowsAndOrdering(processedValue, ctx);
                                    processedValue = this.fixFactorialIssues(processedValue);
                                }
                                // Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ÙÙˆØ§ØµÙ„ Ø¯Ø§Ø¦Ù…Ù‹Ø§ Ù„Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª
                                processedValue = processedValue.replace(/,/g, 'ØŒ');
                            }

                            // 3. Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø³Ù…Ø§Øª (Attributes)

                            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø³Ù…Ø© value Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
                            let newAttrs = allAttrs.replace(/value=["'][^"']*["']/i, '');

                            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø³Ù…Ø© value Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙˆØ§Ù„Ù†Ø¸ÙŠÙØ©
                            newAttrs += ` value="${processedValue.replace(/"/g, '&quot;')}"`;

                            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯
                            const targetDir = convertSymbols ? 'rtl' : 'ltr';

                            // Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ ØªØ­Ø¯ÙŠØ« dir
                            if (!newAttrs.includes('dir=')) {
                                newAttrs += ` dir="${targetDir}"`;
                    } else {
                                newAttrs = newAttrs.replace(/dir=["'](ltr|rtl)["']/i, `dir="${targetDir}"`);
                            }

                            // Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ ØªØ­Ø¯ÙŠØ« locale
                            if (!newAttrs.includes('locale=')) {
                                newAttrs += ` locale="ar"`;
                            } else {
                                newAttrs = newAttrs.replace(/locale=["']en["']/i, 'locale="ar"');
                            }

                            // Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ ØªØ­Ø¯ÙŠØ« lang
                            if (!newAttrs.includes('lang=')) {
                                newAttrs += ` lang="ar"`;
                            } else {
                                newAttrs = newAttrs.replace(/lang=["']en["']/i, 'lang="ar"');
                            }

                            // 4. Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„ÙˆØ³Ù… Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ù…Ø¹ Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ
                            // Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠ (innerHTML) ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ø³Ù…Ø© value Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„ØµØ­ÙŠØ­
                            return `<math-field${newAttrs}>${processedValue}</math-field>`;
                        }
                    );
                    // --- Ø§Ù†ØªÙ‡Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Math-Field ---

                    // --- Ø§Ø¨Ø¯Ø£ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù†Øµ (Ø®Ø§Ø±Ø¬ Math-Field) ---

                    // ØªØ·Ø¨ÙŠÙ‚ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ÙˆØ­Ø¯Ø§Øª (enforceUnits)
                    // Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø­Ø°Ø±Ø© ÙˆÙ„Ø§ ØªØ¹Ø¯Ù„ Ù…Ø§ Ø¨Ø¯Ø§Ø®Ù„ math-field
                    // Ø§Ù„Ø­Ù„ Ø§Ù„Ø£Ø¨Ø³Ø· Ù‡Ùˆ ØªØ´ØºÙŠÙ„Ù‡Ø§ Ù‚Ø¨Ù„ Ù…Ø¹Ø§Ù„Ø¬Ø© math-field
                    // Ù„ÙƒÙ† Ø¨Ù…Ø§ Ø£Ù†Ù†Ø§ Ù†Ø¹Ø§Ù„Ø¬ math-field Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø³Ù†Ø­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø­Ù…Ø§ÙŠØªÙ‡Ø§

                    // (ØªÙ… Ù†Ù‚Ù„ Ù…Ù†Ø·Ù‚ Ø§Ù„ÙˆØ­Ø¯Ø§Øª ÙˆØ§Ù„ÙÙˆØ§ØµÙ„ Ø¥Ù„Ù‰ `processMathFieldContent` Ùˆ `convertSymbolsToArabic` Ù„Ø¶Ù…Ø§Ù† ØªØ·Ø¨ÙŠÙ‚Ù‡Ø§ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª ÙÙ‚Ø·)
                    out = this.fixStandaloneEnglishDigits(out, ctx);

                    // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ù‚ÙˆØ§Ø¹Ø¯ Ø£Ø®Ø±Ù‰ Ù‡Ù†Ø§ Ù„ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚Ù‡Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ø¹Ø§Ø¯ÙŠ *Ø®Ø§Ø±Ø¬* ÙˆØ³ÙˆÙ… math-field
                    // out = this.enforceUnits(out, ctx); // (ØªÙ… Ø¯Ù…Ø¬ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù†Ø·Ù‚)
                    out = this.normalizeArabicPunct(out); // (ØªØ£ÙƒØ¯ Ø£Ù† Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„Ø§ ØªÙƒØ³Ø± HTML)
                    out = out.replace(/Â»([^Â»Â«]+)Â»/g, 'Â«$1Â»');

                    // --- ØªÙ†Ø¸ÙŠÙ ÙˆØ³ÙˆÙ… Span (Ø§Ù„Ù…Ø´ÙƒÙ„Ø© #2 ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„) ---
                    // Ø¥Ø²Ø§Ù„Ø© ÙˆØ³ÙˆÙ… LexicalTheme Ùˆ merge Ø§Ù„Ù…Ø­ÙŠØ·Ø© Ø¨Ù€ math-field
                    out = out.replace(
                        /<span\s+class=["'](LexicalTheme__math--inline|LexicalTheme__math|merge)["'][^>]*>([\s\S]*?<math-field[^>]*>.*?<\/math-field>[\s\S]*?)<\/span>/gi,
                        '$2'
                    );
                    // Ø¥Ø²Ø§Ù„Ø© ÙˆØ³ÙˆÙ… span Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© Ø­ÙˆÙ„ math-field
                    out = out.replace(
                        /<span[^>]*>(<math-field[^>]*>.*?<\/math-field>)<\/span>/gi,
                        '$1'
                    );
                    // --- Ø§Ù†ØªÙ‡Ù‰ ØªÙ†Ø¸ÙŠÙ ÙˆØ³ÙˆÙ… Span ---

                    // (ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ `ensureRTLDirection` Ø§Ù„Ø¢Ù† Ø¹Ø¨Ø± `addRTLToParagraphs` ÙÙŠ `export.toJson` Ùˆ `renderFileContent`)

                    // (ÙŠØªÙ… Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ `fixTranslationIssues` Ùˆ `syncMathFieldContent` Ø§Ù„Ø¢Ù† Ø¶Ù…Ù†ÙŠÙ‹Ø§ Ø¯Ø§Ø®Ù„ Ù‡Ø°Ø§ Ø§Ù„Ù„ÙˆØ¨)
                    
                    return out;
                },                /**
                 * Process math-field tags and convert their value content based on grade rules
                 * For Math G1-3, G9-12: Convert to Arabic digits with RTL direction
                 * For Math G4-8: Keep English digits with LTR direction
                 */
                processMathFieldContent(htmlString, ctx = { subject: 'None', grade: 'None' }) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    if (ctx.subject !== 'Mathematics') return htmlString;
                    
                    const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                    const shouldConvertToArabic = arabicGrades.includes(ctx.grade);
                    
                    return htmlString.replace(/<math-field([^>]*)value="([^"]*)"([^>]*)>([^<]*)<\/math-field>/g, 
                        (match, before, value, after, innerContent) => {
                        if (!value) return match;
                        
                        let processedValue = value;
                        let processedInner = innerContent;
                        
                        if (shouldConvertToArabic) {
                            // Convert English digits (0-9) to Arabic digits (Ù -Ù©)
                            processedValue = this.convertDigits(processedValue, true);
                            processedInner = this.convertDigits(processedInner, true);
                            
                            // Convert Latin symbols (x, y, z) to Arabic (Ø³, Øµ, Ø¹)
                            processedValue = this.convertSymbolsToArabic(processedValue);
                            processedInner = this.convertSymbolsToArabic(processedInner);
                            
                            // âœ¨ NEW: Convert English commas to Arabic commas in math-field
                            processedValue = processedValue.replace(/,/g, 'ØŒ');
                            processedInner = processedInner.replace(/,/g, 'ØŒ');
                            
                            // Ensure dir="rtl" for Arabic grades
                            if (!after.includes('dir=')) {
                                after = ' dir="rtl"' + after;
                            } else {
                                after = after.replace(/dir="ltr"/, 'dir="rtl"');
                            }
                        } else {
                            // Keep English digits for G4-8
                            // âœ¨ NEW: Convert English commas to Arabic commas even for English digit grades
                            processedValue = processedValue.replace(/,/g, 'ØŒ');
                            processedInner = processedInner.replace(/,/g, 'ØŒ');
                            
                            // Ensure dir="ltr" 
                            if (!after.includes('dir=')) {
                                after = ' dir="ltr"' + after;
                            } else {
                                after = after.replace(/dir="rtl"/, 'dir="ltr"');
                            }
                        }
                        
                        return `<math-field${before}value="${processedValue}"${after}>${processedInner}</math-field>`;
                    });
                },
                qa: {
                    extractPlain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim(); },
                    unifyDigits(s) { const ar = 'Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©'; return (s || '').replace(/[Ù -Ù©]/g, d => String(ar.indexOf(d))); },
                    extractNumbers(s) { return Array.from((s || '').matchAll(/[0-9Ù -Ù©]+(?:[.,][0-9Ù -Ù©]+)?/g)).map(m => m[0]); },
                    sameNumberSet(srcArr, dstArr) {
                        const a = srcArr.map(this.unifyDigits).sort().join('|');
                        const b = dstArr.map(this.unifyDigits).sort().join('|');
                        return a === b;
                    },
                    checkNumbers(srcHtml, dstHtml) {
                        const s = this.extractPlain(srcHtml); const d = this.extractPlain(dstHtml);
                        const srcNums = this.extractNumbers(s); const dstNums = this.extractNumbers(d);
                        return this.sameNumberSet(srcNums, dstNums) ? [] : [`ØªØ­Ø°ÙŠØ±: ØªØºÙŠØ±Øª/Ø§Ø®ØªÙØª Ø£Ø±Ù‚Ø§Ù… (${srcNums.join(',')}) â†’ (${dstNums.join(',')}).`];
                    },
                    checkSeparator(dstText, sep) {
                        if (!dstText) return [];
                        const want = (dstText.match(new RegExp(sep.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g')) || []).length;
                        const legacy = (dstText.match(/<SEP>/g) || []).length;
                        if (legacy > 0 && want === 0) return ['ØªØ­Ø°ÙŠØ±: Ù„Ù… ÙŠÙØ­ÙØ¸ Ø§Ù„ÙØ§ØµÙ„ <SEP> ÙƒÙ…Ø§ Ù‡Ùˆ.'];
                        return [];
                    },
                    checkHtmlBalance(dstHtml) {
                        const tags = ['b', 'i', 'u', 'strong', 'em', 'sub', 'sup', 'span', 'p', 'ul', 'ol', 'li'];
                        const errs = [];
                        tags.forEach(t => {
                            const open = (dstHtml.match(new RegExp(`<${t}\\b`, 'gi')) || []).length;
                            const close = (dstHtml.match(new RegExp(`</${t}>`, 'gi')) || []).length;
                            if (open !== close) errs.push(`ØªØ­Ø°ÙŠØ±: Ø§Ù„ÙˆØ³Ù… <${t}> ØºÙŠØ± Ù…ØªÙˆØ§Ø²Ù† (${open}/${close}).`);
                        });
                        return errs;
                    }
                }
            },

            tm: {
                KEY: 'translatorTMv1',
                getStore() { try { return JSON.parse(localStorage.getItem(this.KEY) || '{}'); } catch { return {}; } },
                saveStore(obj) { localStorage.setItem(this.KEY, JSON.stringify(obj)); },
                plain(html) { const div = document.createElement('div'); div.innerHTML = html || ''; return (div.textContent || div.innerText || '').trim().toLowerCase(); },
                key(text, ctx) { return `${ctx.subject}||${ctx.grade}||${this.plain(text)}`; },
                get(text, ctx) { const store = this.getStore(); return store[this.key(text, ctx)] || null; },
                put(text, ctx, translated) {
                    const store = this.getStore();
                    const k = this.key(text, ctx);
                    store[k] = translated;
                    this.saveStore(store);
                }
            },

            session: {
                save() {
                    try {
                        const ephemeral = TranslatorApp.dom.ephemeralKeysCheckbox.checked;
                        const sessionData = {
                            apiKeys: ephemeral ? null : {
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                            },
                            localModelUrl: TranslatorApp.dom.localModelUrl.value,
                            localModelName: TranslatorApp.dom.localModelName.value,
                            selectedProvider: document.querySelector('input[name="apiProvider"]:checked').value,
                            selectedFilesInfo: TranslatorApp.state.selectedFilesInfo,
                            originalJsonData: TranslatorApp.state.originalJsonData,
                            translatedJsonData: TranslatorApp.state.translatedJsonData,
                            initialTranslatedJsonData: TranslatorApp.state.initialTranslatedJsonData,
                            glossary: TranslatorApp.state.glossary,
                            activeScreen: TranslatorApp.state.activeScreen,
                            mappedIds: TranslatorApp.dom.mappedIdsInput.value,
                            useMappedIds: TranslatorApp.dom.useMappedIdsCheckbox.checked,
                            selectedSubject: TranslatorApp.state.selectedSubject,
                            selectedGrade: TranslatorApp.state.selectedGrade,
                            ephemeralKeys: ephemeral,
                            useTM: TranslatorApp.dom.useTmCheckbox.checked,
                            useProofread: TranslatorApp.dom.useProofreadCheckbox.checked
                        };
                        localStorage.setItem('translatorSession', JSON.stringify(sessionData));

                        // Always save API keys to sessionStorage for persistence across browser sessions
                        if (TranslatorApp.dom.geminiKeyInput.value || TranslatorApp.dom.chatgptKeyInput.value) {
                            sessionStorage.setItem('translatorPersistentKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value),
                                provider: document.querySelector('input[name="apiProvider"]:checked').value
                            }));
                        }

                        if (ephemeral) {
                            sessionStorage.setItem('translatorEphemeralKeys', JSON.stringify({
                                gemini: TranslatorApp.security.encrypt(TranslatorApp.dom.geminiKeyInput.value),
                                chatgpt: TranslatorApp.security.encrypt(TranslatorApp.dom.chatgptKeyInput.value)
                            }));
                        } else {
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        }

                        TranslatorApp.state.hasUnsavedChanges = false;
                    } catch (error) {
                        console.error('Session save error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø©.', 'error');
                    }
                },
                load() {
                    const saved = localStorage.getItem('translatorSession');
                    if (!saved) return;
                    try {
                        const s = JSON.parse(saved);
                        TranslatorApp.dom.ephemeralKeysCheckbox.checked = !!s.ephemeralKeys;

                        // Load API keys with fallback to persistent storage
                        let keysLoaded = false;
                        if (s.apiKeys && !s.ephemeralKeys) {
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(s.apiKeys?.chatgpt || '');
                            keysLoaded = true;
                        } else if (s.ephemeralKeys) {
                            const sk = JSON.parse(sessionStorage.getItem('translatorEphemeralKeys') || '{}');
                            TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(sk?.gemini || '');
                            TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(sk?.chatgpt || '');
                            keysLoaded = true;
                        }

                        // Fallback to persistent keys if no keys loaded from session
                        if (!keysLoaded) {
                            const persistentKeys = JSON.parse(sessionStorage.getItem('translatorPersistentKeys') || '{}');
                            if (persistentKeys.gemini || persistentKeys.chatgpt) {
                                TranslatorApp.dom.geminiKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.gemini || '');
                                TranslatorApp.dom.chatgptKeyInput.value = TranslatorApp.security.decrypt(persistentKeys.chatgpt || '');
                                if (persistentKeys.provider) {
                                    const radio = document.querySelector(`input[name="apiProvider"][value="${persistentKeys.provider}"]`);
                                    if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: persistentKeys.provider } }); }
                                }
                            }
                        }

                        TranslatorApp.dom.localModelUrl.value = s.localModelUrl || 'http://localhost:11434/api/generate';
                        TranslatorApp.dom.localModelName.value = s.localModelName || 'gemma:7b';
                        TranslatorApp.state.selectedFilesInfo = s.selectedFilesInfo || [];
                        TranslatorApp.state.originalJsonData = s.originalJsonData || [];
                        TranslatorApp.state.translatedJsonData = s.translatedJsonData || [];
                        TranslatorApp.state.initialTranslatedJsonData = s.initialTranslatedJsonData || [];
                        TranslatorApp.state.glossary = s.glossary || [];
                        TranslatorApp.state.activeScreen = s.activeScreen || 'setup';
                        TranslatorApp.dom.mappedIdsInput.value = s.mappedIds || '[]';
                        TranslatorApp.dom.useMappedIdsCheckbox.checked = s.useMappedIds || false;
                        TranslatorApp.state.selectedSubject = s.selectedSubject || 'None';
                        TranslatorApp.state.selectedGrade = s.selectedGrade || 'None';
                        TranslatorApp.dom.useTmCheckbox.checked = s.useTM ?? true;
                        TranslatorApp.dom.useProofreadCheckbox.checked = s.useProofread ?? false;

                        if (s.selectedProvider && !keysLoaded) {
                            const radio = document.querySelector(`input[name="apiProvider"][value="${s.selectedProvider}"]`);
                            if (radio) { radio.checked = true; TranslatorApp.events.onApiProviderChange({ target: { value: s.selectedProvider } }); }
                        }

                        TranslatorApp.ui.renderFileList();
                        TranslatorApp.subjects.updateUI();
                        
                        // Validate translation requirements after loading session
                        TranslatorApp.validateTranslationRequirements();

                        if (TranslatorApp.state.activeScreen === 'preview' && TranslatorApp.state.translatedJsonData.length > 0) {
                            TranslatorApp.ui.showScreen('preview');
                            TranslatorApp.preview.render();
                            const stats = TranslatorApp.statistics.calculate();
                            TranslatorApp.ui.renderStatistics(stats);
                            TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        } else {
                            TranslatorApp.ui.showScreen('setup');
                        }

                        TranslatorApp.ui.showAlert('ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                    } catch (e) {
                        console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø©:', e);
                        TranslatorApp.ui.showAlert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©. Ø³ÙŠØªÙ… Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©.', 'error');

                        // Clear corrupted session data
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                        } catch (clearError) {
                            console.error('Error clearing corrupted session:', clearError);
                        }
                    }
                },
                clear() {
                    TranslatorApp.ui.showConfirmModal(
                        'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¨Ø¯Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©ØŸ Ø³ÙŠØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© ÙˆØ§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©.',
                        () => { // Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø³ØªÙÙ†ÙØ° ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ "ØªØ£ÙƒÙŠØ¯"
                        try {
                            localStorage.removeItem('translatorSession');
                            sessionStorage.removeItem('translatorEphemeralKeys');
                            location.reload();
                        } catch (error) {
                            console.error('Session clear error:', error);
                            TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ù…Ø³Ø­ Ø§Ù„Ø¬Ù„Ø³Ø©. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© ÙŠØ¯ÙˆÙŠØ§Ù‹.', 'error');
                        }
                        }
                    );
                }
            },

            autoSave: {
                init() {
                    setInterval(() => {
                        try {
                            if (TranslatorApp.state.hasUnsavedChanges) {
                                TranslatorApp.session.save();
                                TranslatorApp.ui.setSaveIndicator('saving');
                                setTimeout(() => TranslatorApp.ui.setSaveIndicator('saved'), 400);
                            }
                        } catch (error) {
                            console.error('Auto-save error:', error);
                            TranslatorApp.ui.setSaveIndicator('error');
                            setTimeout(() => TranslatorApp.ui.setSaveIndicator(''), 2000);
                        }
                    }, 8000);
                }
            },

            validation: {
                validateJsonStructure(data, fileName) {
                    if (typeof data !== 'object' || data === null) {
                        throw new Error(`Ù…Ù„Ù ${fileName} ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ÙƒØ§Ø¦Ù† JSON ØµØ§Ù„Ø­.`);
                    }
                    if (!data.hasOwnProperty('parts')) {
                        throw new Error(`Ù…Ù„Ù ${fileName} ÙŠÙØªÙ‚Ø¯ Ù„Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ (parts).`);
                    }
                    if (!Array.isArray(data.parts)) {
                        throw new Error(`Ø­Ù‚Ù„ parts ÙÙŠ Ù…Ù„Ù ${fileName} ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…ØµÙÙˆÙØ©.`);
                    }
                    return true;
                },
                validateApiKey(key, provider) {
                    if (!key || typeof key !== 'string') return false;
                    const trimmedKey = key.trim();
                    if (trimmedKey.length === 0) return false;

                    if (provider === 'gemini') {
                        return trimmedKey.startsWith('AIza') && trimmedKey.length > 30;
                    }
                    if (provider === 'chatgpt') {
                        return trimmedKey.startsWith('sk-') && trimmedKey.length >= 20;
                    }
                    if (provider === 'local') {
                        // For local models, we validate URL and model name separately
                        return true;
                    }
                    return false;
                },
                validateLocalModelSettings(url, modelName) {
                    if (!url || typeof url !== 'string' || url.trim().length === 0) {
                        return { valid: false, message: 'Ø¹Ù†ÙˆØ§Ù† URL Ù„Ù„Ø®Ø§Ø¯Ù… Ø§Ù„Ù…Ø­Ù„ÙŠ Ù…Ø·Ù„ÙˆØ¨.' };
                    }
                    if (!modelName || typeof modelName !== 'string' || modelName.trim().length === 0) {
                        return { valid: false, message: 'Ø§Ø³Ù… Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø­Ù„ÙŠ Ù…Ø·Ù„ÙˆØ¨.' };
                    }
                    return { valid: true };
                }
            },

            fileHandler: {
                addFiles(files) {
                    const incoming = Array.from(files).filter(f => {
                        if (!f) return false;
                        const isJson = f.type === 'application/json' || f.name.toLowerCase().endsWith('.json');
                        if (!isJson) {
                            TranslatorApp.ui.showAlert(`Ø§Ù„Ù…Ù„Ù ${f.name} Ù„ÙŠØ³ Ù…Ù„Ù JSON ØµØ§Ù„Ø­.`, 'error');
                            return false;
                        }
                        return true;
                    });

                    if (incoming.length === 0) {
                        TranslatorApp.ui.showAlert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„ÙØ§Øª JSON ØµØ§Ù„Ø­Ø©.', 'error');
                        return;
                    }

                    incoming.forEach(file => {
                        TranslatorApp.state.fileStore.set(file.name, file);
                        if (!TranslatorApp.state.selectedFilesInfo.some(f => f.name === file.name)) {
                            TranslatorApp.state.selectedFilesInfo.push({ name: file.name, size: file.size });
                        } else {
                            const idx = TranslatorApp.state.selectedFilesInfo.findIndex(f => f.name === file.name);
                            if (idx > -1) TranslatorApp.state.selectedFilesInfo[idx].size = file.size;
                        }
                    });
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showAlert(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ${incoming.length} Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­.`, 'success');
                },
                removeFile(index) {
                    const info = TranslatorApp.state.selectedFilesInfo[index]; if (!info) return;
                    const name = info.name;
                    TranslatorApp.state.selectedFilesInfo.splice(index, 1);
                    if (TranslatorApp.state.fileStore.has(name)) TranslatorApp.state.fileStore.delete(name);
                    const origIdx = TranslatorApp.state.originalJsonData.findIndex(d => d.name === name);
                    if (origIdx > -1) TranslatorApp.state.originalJsonData.splice(origIdx, 1);
                    const transIdx = TranslatorApp.state.translatedJsonData.findIndex(d => d.name === name);
                    if (transIdx > -1) TranslatorApp.state.translatedJsonData.splice(transIdx, 1);
                    TranslatorApp.ui.renderFileList();
                    TranslatorApp.state.hasUnsavedChanges = true;
                },
                async readFilesFromInput() {
                    if (TranslatorApp.state.selectedFilesInfo.length === 0) throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ù…Ø­Ø¯Ø¯Ø©.");
                    TranslatorApp.state.originalJsonData = [];
                    const inputFiles = Array.from(TranslatorApp.dom.fileInput.files || []);

                    for (const { name } of TranslatorApp.state.selectedFilesInfo) {
                        try {
                            const file = TranslatorApp.state.fileStore.get(name) || inputFiles.find(f => f.name === name);
                            if (!file) throw new Error(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù ${name}. ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ø¯ÙŠØ¯Ù‡.`);

                            const content = await file.text();
                            if (!content || content.trim() === '') {
                                throw new Error(`Ø§Ù„Ù…Ù„Ù ${name} ÙØ§Ø±Øº.`);
                            }

                            let jsonData;
                            try {
                                jsonData = JSON.parse(content);
                            } catch (parseError) {
                                throw new Error(`Ø§Ù„Ù…Ù„Ù ${name} ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ JSON ØºÙŠØ± ØµØ§Ù„Ø­: ${parseError.message}`);
                            }

                            TranslatorApp.validation.validateJsonStructure(jsonData, name);
                            TranslatorApp.state.originalJsonData.push({ name, data: jsonData });

                        } catch (fileError) {
                            console.error(`Error reading file ${name}:`, fileError);
                            throw new Error(`Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù ${name}: ${fileError.message}`);
                        }
                    }
                }
            },

            mappedIds: {
                async fetch() {
                    const count = TranslatorApp.dom.mappedIdsCount.value;
                    if (!count || count <= 0) return TranslatorApp.ui.showAlert('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ ØµØ­ÙŠØ­.', 'error');
                    const url = `https://12digit.nagwa.com/get.bulk.codes/${count}/cps/cps.system/`;
                    TranslatorApp.ui.showAlert(`Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ ${count} ÙƒÙˆØ¯...`, 'info', 3000);
                    try {
                        const response = await fetch(url, {
                            method: 'GET',
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            }
                        });
                        if (!response.ok) throw new Error(`ÙØ´Ù„ Ø§Ù„Ø·Ù„Ø¨. Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø§Ø¯Ù…: ${response.status}`);
                        const data = await response.json();
                        if (Array.isArray(data)) {
                            TranslatorApp.dom.mappedIdsInput.value = JSON.stringify(data, null, 2);
                            TranslatorApp.ui.showAlert('ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ø¨Ù†Ø¬Ø§Ø­.', 'success');
                            TranslatorApp.state.hasUnsavedChanges = true;
                        } else {
                            throw new Error('Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ÙŠØ³Øª Ù…ØµÙÙˆÙØ©.');
                        }
                    } catch (error) {
                        console.error("Fetch Mapped IDs Error:", error);
                        TranslatorApp.ui.showAlert(`ÙØ´Ù„ Ø§Ù„Ø¬Ù„Ø¨ Ø¨Ø³Ø¨Ø¨ Ù‚ÙŠÙˆØ¯ CORS. Ø³ÙŠØªÙ… ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ù„Ù„Ù†Ø³Ø® Ø§Ù„ÙŠØ¯ÙˆÙŠ.`, 'error', 8000);
                        window.open(url, '_blank');
                    }
                }
            },

            subjects: {
                data: {
                    'None': { grades: ['None'], prompt: 'Translate to Arabic accurately. Preserve HTML/LaTeX and special placeholders (e.g., __LOCK_0__, __GLOSSARY_0__). If a text contains the separator \\n<SEP>\\n, translate each segment separately and preserve the separator exactly.' },
                    'Mathematics': {
                        grades: ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'], 
                        prompts: {
                            'Grade 1': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.\n7. Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ø¹Ù…Ø± Ø§Ù„Ø·Ù„Ø§Ø¨.',
                            'Grade 2': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.\n7. Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ø¹Ù…Ø± Ø§Ù„Ø·Ù„Ø§Ø¨.',
                            'Grade 3': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù„Ø« Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.\n7. Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ø¹Ù…Ø± Ø§Ù„Ø·Ù„Ø§Ø¨.',
                            'Grade 4': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø±Ø§Ø¨Ø¹ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 5': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø®Ø§Ù…Ø³ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 6': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø³Ø§Ø¯Ø³ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 7': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 8': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (0123456789) ÙˆØ§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© (x, y, z).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).\n3. **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**\n   - Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© (Ù…Ø«Ù„: cm, m, kg, km):\n     * Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)\n     * Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©\n     * ØªØ±Ø¬Ù… Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (cm â†’ Ø³Ù…ØŒ m â†’ Ù…ØŒ kg â†’ ÙƒØ¬Ù…)\n   - Ù…Ø«Ø§Ù„: "5 cm" â†’ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n   - Ù…Ø«Ø§Ù„: "x meters" â†’ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)\n4. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n5. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø›).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 9': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù„Ø« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 10': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 11': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.',
                            'Grade 12': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù„Ø« Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ.\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¥Ù„Ø²Ø§Ù…ÙŠØ©:**\n1. **Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ²:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ© (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©) ÙˆØªØ±Ø¬Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© (Ù…Ø«Ø§Ù„: x â†’ Ø³ØŒ y â†’ ØµØŒ z â†’ Ø¹).\n2. **Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Øµ:** Ø§ÙƒØªØ¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).\n3. **Ø§Ù„ÙÙˆØ§ØµÙ„:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).\n4. **Ù‚Ø§Ø¹Ø¯Ø© Ù…Ù‡Ù…Ø© Ø¬Ø¯Ø§Ù‹:** Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø£Ø±Ù‚Ø§Ù… Ø£Ùˆ Ø±Ù…ÙˆØ²ØŒ Ø­ÙˆÙ‘Ù„Ù‡Ø§ Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).\n   - Ù…Ø«Ø§Ù„: "x and y" â†’ "Ø³ØŒ Øµ" (ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ")\n   - Ù…Ø«Ø§Ù„: "Ù£ and Ù¥" â†’ "Ù£ØŒ Ù¥" (ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥")\n5. **Ø§Ù„ØªØ³Ù…ÙŠØ§Øª:** Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬ØŒ Ø¯).\n6. Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n ÙƒÙ…Ø§ Ù‡Ùˆ.'
                        }
                    },
                    'Physics': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Physics questions.\nRules:\n1) Use official MoE phrasing.\n2) Use English numerals.\n3) Keep physical formulas (e.g., F=ma), variables, and units (cm, m, kg) in their original LTR format. Do NOT wrap them in any HTML tags.\n4) Keep subscripts and variables exact.\n5) If text contains \\n<SEP>\\n, translate parts separately and preserve separator.'
                        }
                    },
                    'Chemistry': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Chemistry questions.\nRules:\n1) Use English numerals.\n2) Keep chemical formulas, symbols, and equations in their original LTR format. Do NOT wrap them in any HTML tags.\n3) Keep units in English abbreviations.\n4) If text contains \\n<SEP>\\n, preserve separator.'
                        }
                    },
                    'Biology': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Biology questions.\nUse English numerals; Arabic labels (Ø£ØŒ Ø¨ØŒ Ø¬); translate text within figures; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Science': {
                        grades: ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8', 'Grade 9'], 
                        prompts: {
                            'Grade 4': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø±Ø§Ø¨Ø¹.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 5': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø®Ø§Ù…Ø³.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 6': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø³Ø§Ø¯Ø³.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 7': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø³Ø§Ø¨Ø¹.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 8': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„Ø«Ø§Ù…Ù†.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.',
                            'Grade 9': 'ØªØ±Ø¬Ù…Ø© Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„ØµÙ Ø§Ù„ØªØ§Ø³Ø¹.\nØ§Ù„Ù‚ÙˆØ§Ø¹Ø¯:\n1) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯ÙŠØ©.\n2) Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø£ØŒ Ø¨ØŒ Ø¬).\n3) Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n4) Ø§Ø³ØªØ®Ø¯Ù… Ù…ØµØ·Ù„Ø­Ø§Øª Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø¹Ù…Ø±.\n5) Ø§Ø­ØªÙØ¸ Ø¨Ù€ \\n<SEP>\\n.'
                        }
                    },
                    'Integrated Science': {
                        grades: ['Grades 10â€“12'], prompts: {
                            'Grades 10â€“12': 'Translate Integrated Science.\nUse English numerals; Arabic labels; keep units; preserve \\n<SEP>\\n.'
                        }
                    },
                    'ICT': {
                        grades: ['Grade 4', 'Grade 5'], prompts: {
                            'Grade 4': 'Translate ICT (Grade 4).\nUse Arabic-Indic numerals; product names bilingual; preserve \\n<SEP>\\n.',
                            'Grade 5': 'Translate ICT (Grade 5).\nUse English numerals; Arabic labels; preserve \\n<SEP>\\n.'
                        }
                    },
                    'Discover': {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  grades: ['Grades 1â€“3'], prompts: {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'Grades 1â€“3': 'Translate Discover (1-3).\nUse Arabic-Indic numerals; Arabic labels; preserve \\n<SEP>\\n.'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
                },
                init() { this.populateSubjects(); this.updateUI(); },
                populateSubjects() {
                    TranslatorApp.dom.subjectSelect.innerHTML = '';
                    Object.keys(this.data).forEach(subject => {
                        const opt = document.createElement('option'); opt.value = subject; opt.textContent = subject;
                        TranslatorApp.dom.subjectSelect.appendChild(opt);
                    });
                },
                populateGrades(subject) {
                    TranslatorApp.dom.gradeSelect.innerHTML = '';
                    const subjectData = this.data[subject];
                    if (subjectData && subjectData.grades) subjectData.grades.forEach(grade => {
                        const opt = document.createElement('option'); opt.value = grade; opt.textContent = grade;
                        TranslatorApp.dom.gradeSelect.appendChild(opt);
                    });
                },
                onSubjectChange() { 
                    const s = TranslatorApp.dom.subjectSelect.value; 
                    this.populateGrades(s); 
                    this.updatePromptPreview();
                    this.updateMathGradeWarning();
                },
                onGradeChange() { 
                    this.updatePromptPreview();
                    this.updateMathGradeWarning();
                },
                updatePromptPreview() { TranslatorApp.dom.promptPreview.value = this.buildSystemPrompt(); },
                
                /**
                 * Show warning for Mathematics based on selected grade
                 */
                updateMathGradeWarning() {
                    const warningDiv = document.getElementById('mathGradeWarning');
                    const warningText = document.getElementById('mathGradeWarningText');
                    
                    if (!warningDiv || !warningText) return;
                    
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    
                    if (subject === 'Mathematics' && grade && grade !== 'None') {
                        const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                        
                        if (arabicGrades.includes(grade)) {
                            // âœ… Grade will use Arabic conversion
                            warningDiv.style.display = 'block';
                            warningDiv.style.backgroundColor = '#d4edda';
                            warningDiv.style.borderColor = '#28a745';
                            warningText.style.color = '#155724';
                            warningText.innerHTML = `
                                âœ… <strong>${grade}</strong> - Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„:<br>
                                â€¢ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…: 0-9 â†’ Ù -Ù©<br>
                                â€¢ Ø§Ù„Ø±Ù…ÙˆØ²: x,y,z â†’ Ø³,Øµ,Ø¹<br>
                                â€¢ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: RTL (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±)
                            `;
                        } else {
                            // âš ï¸ Grade will keep English
                            warningDiv.style.display = 'block';
                            warningDiv.style.backgroundColor = '#fff3cd';
                            warningDiv.style.borderColor = '#ffc107';
                            warningText.style.color = '#856404';
                            warningText.innerHTML = `
                                â„¹ï¸ <strong>${grade}</strong> - Ø³ÙŠØªÙ… Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰:<br>
                                â€¢ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©: 0-9<br>
                                â€¢ Ø§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©: x,y,z<br>
                                â€¢ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: LTR (Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ†)<br>
                                <small>(Ø¹Ø¯Ø§ Ø§Ù„ÙˆØ­Ø¯Ø§Øª Ù…Ø«Ù„ cm â†’ Ø³Ù…)</small>
                            `;
                        }
                    } else {
                        warningDiv.style.display = 'none';
                    }
                },
                getCurrentPrompt() {
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    if (subject === 'None' || !this.data[subject]) return this.data['None'].prompt;
                    return this.data[subject].prompts?.[grade] || Object.values(this.data[subject].prompts)[0] || '';
                },
                buildSystemPrompt() {
                    const base = this.getCurrentPrompt();
                    const subject = TranslatorApp.dom.subjectSelect.value;
                    const grade = TranslatorApp.dom.gradeSelect.value;
                    
                    // Add subject and grade info to the prompt
                    const subjectInfo = subject !== 'None' && grade !== 'None' 
                        ? `\n\n--- Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ø¬Ø±ÙŠØ¯ ---\nØ§Ù„Ù…Ø§Ø¯Ø©: ${subject}\nØ§Ù„Ø¬Ø±ÙŠØ¯: ${grade}\n--- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ---\n\n`
                        : '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const wantArabic = TranslatorApp.quality.wantsArabicIndicDigits(subject, grade);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const digitsRule = wantArabic ? 'Use Arabic-Indic numerals (Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©).' : 'Use English numerals (0123456789).';
                    
                    // Special rules for Mathematics based on grade
                    let mathRules = '';
                    if (subject === 'Mathematics') {
                        const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                        const englishGrades = ['Grade 4', 'Grade 5', 'Grade 6', 'Grade 7', 'Grade 8'];
                        
                        if (arabicGrades.includes(grade)) {
                            mathRules = `\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø®Ø§ØµØ© Ù„Ù„ØµÙÙˆÙ (${grade}):**
- ÙŠØ¬Ø¨ ØªØ±Ø¬Ù…Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©).
- ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL).
- Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙÙˆØ§ØµÙ„ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (ØŒ Ùˆ Ø› Ùˆ ØŸ).
- **Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹**: Ø¹Ù†Ø¯ ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ù„Ø±Ù…ÙˆØ²ØŒ ÙŠØ¬Ø¨ ØªØ­ÙˆÙŠÙ„ ÙƒÙ„Ù…Ø© "and" Ø§Ù„ØªÙŠ ØªØ£ØªÙŠ Ø¨ÙŠÙ† Ø§Ù„Ø±Ù…ÙˆØ² Ø¥Ù„Ù‰ ÙØ§ØµÙ„Ø© Ø¹Ø±Ø¨ÙŠØ© (ØŒ) ÙˆÙ„ÙŠØ³ Ø¥Ù„Ù‰ ÙˆØ§Ùˆ Ø§Ù„Ø¹Ø·Ù (Ùˆ).
  Ù…Ø«Ø§Ù„: "x and y" ÙŠØ¬Ø¨ Ø£Ù† ØªØµØ¨Ø­ "Ø³ØŒ Øµ" ÙˆÙ„ÙŠØ³ "Ø³ Ùˆ Øµ"
  Ù…Ø«Ø§Ù„: "3 and 5" ÙŠØ¬Ø¨ Ø£Ù† ØªØµØ¨Ø­ "Ù£ØŒ Ù¥" ÙˆÙ„ÙŠØ³ "Ù£ Ùˆ Ù¥"\n`;
                        } else if (englishGrades.includes(grade)) {
                            mathRules = `\n\n**Ù‚ÙˆØ§Ø¹Ø¯ Ø®Ø§ØµØ© Ù„Ù„ØµÙÙˆÙ (${grade}):**
- ÙŠØ¬Ø¨ Ø¹Ø¯Ù… ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø±Ù…ÙˆØ² ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¯ (Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© 0123456789).
- ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§ØªØ¬Ø§Ù‡Ø§Øª Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR).
- **Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù…Ù‡Ù… Ù„Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª Ù‚ÙŠØ§Ø³:**
  * Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¹Ø¨ÙŠØ± ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© Ù‚ÙŠØ§Ø³ (Ù…Ø«Ù„ cm, m, kg)ØŒ ÙŠØ¬Ø¨:
    1. ÙƒØªØ§Ø¨Ø© Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)
    2. Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¯ Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
    3. ØªØ±Ø¬Ù…Ø© Ø§Ù„ÙˆØ­Ø¯Ø© ÙÙ‚Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
  * Ù…Ø«Ø§Ù„: "5 cm" ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒØªØ¨ "5 Ø³Ù…" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±ØŒ Ø±Ù‚Ù… Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ ÙˆÙˆØ­Ø¯Ø© Ø¹Ø±Ø¨ÙŠØ©)
  * Ù…Ø«Ø§Ù„: "x meters" ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒØªØ¨ "x Ù…ØªØ±" (Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø±ØŒ Ø±Ù…Ø² Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ ÙˆÙˆØ­Ø¯Ø© Ø¹Ø±Ø¨ÙŠØ©)
  * Ø§Ù„ØªØ¹Ø¨ÙŠØ±Ø§Øª Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø§Øª ØªØ¨Ù‚Ù‰ LTR Ù…Ø¹ Ø£Ø±Ù‚Ø§Ù… ÙˆØ±Ù…ÙˆØ² Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.\n`;
                        }
                    }
                    
                    const core = [
                        // Move the critical rule to the top for emphasis
                        '**CRITICAL: Do NOT output any LaTeX commands for Arabic text. For example, the word "Ø·Ø§Ù„Ø¨" should be rendered exactly as "Ø·Ø§Ù„Ø¨" and NOT as "\\alt{\\ta}\\prime \\alt{\\alef}\\prime \\alt{\\la}\\prime \\alt{\\ba}\\prime".**',
                        '',
                        '**CRITICAL RULES FOR HTML TAGS:**',
                        '1. NEVER add any HTML tags (including <span>, <div>, <p>, etc.) to the translation.',
                        '2. NEVER wrap variables, units, or formulas in <span dir="ltr"> or any other HTML tags.',
                        '3. Keep all text content plain text without any HTML markup.',
                        '4. If you see <math-field> in the original, keep it exactly as-is with its LaTeX value.',
                        '5. DO NOT add irrelevant LaTeX inside math-field values.',
                        '6. DO NOT add English punctuation marks (?, !, .) inside <math-field> tags unless they are part of the original mathematical expression.',
                        '',
                        'Core rules:',
                        '- Do NOT add or remove content.',
                        '- Translate text content inside of HTML tags. Preserve the HTML tags themselves (e.g., <table>, <b>, <img>) and all LaTeX markup exactly as-is.',
                        '- If a text segment contains no translatable prose (e.g., it is only a table of numbers, a chemical formula, or a URL), you MUST return the original text segment completely unchanged.',
                        '- If present, keep placeholders __LOCK_n__ and __GLOSSARY_n__ unchanged.',
                        `- ${digitsRule}`,
                        `- If text contains the separator ${TranslatorApp.constants.CONTEXT_SEPARATOR}, translate each segment and preserve the separator exactly.`,
                        '- Keep the order of choices unchanged.',
                        '- Output in Arabic (MSA), formal tone.'
                    ].join('\n');
                    return `${subjectInfo}${base}${mathRules}\n\n${core}`;
                },
                async apply() {
                    TranslatorApp.state.selectedSubject = TranslatorApp.dom.subjectSelect.value;
                    TranslatorApp.state.selectedGrade = TranslatorApp.dom.gradeSelect.value;
                    TranslatorApp.state.hasUnsavedChanges = true;
                    TranslatorApp.ui.showSubjectsModal(false);
                    
                    // Show detailed success message
                    const subjectName = TranslatorApp.state.selectedSubject;
                    const gradeName = TranslatorApp.state.selectedGrade;
                    let message = `ØªÙ… ØªØ·Ø¨ÙŠÙ‚: ${subjectName} - ${gradeName}`;
                    
                    if (subjectName !== 'None' && gradeName !== 'None') {
                        message += `\nØ³ÙŠØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø®ØµØµØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø±ÙŠØ¯ Ø¹Ù†Ø¯ Ø§Ù„ØªØ±Ø¬Ù…Ø©.`;
                        
                        // âš ï¸ Special warning for Mathematics with specific grades
                        if (subjectName === 'Mathematics') {
                            const arabicGrades = ['Grade 1', 'Grade 2', 'Grade 3', 'Grade 9', 'Grade 10', 'Grade 11', 'Grade 12'];
                            if (arabicGrades.includes(gradeName)) {
                                message += `\nâœ… Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² (x,y,z) Ù„Ù„Ø¹Ø±Ø¨ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.`;
                            } else {
                                message += `\nâš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø©: ${gradeName} Ø³ÙŠØ¨Ù‚ÙŠ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø¨Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©.`;
                            }
                        }
                    }
                    
                    TranslatorApp.ui.showAlert(message, 'success', 5000);
                },
                updateUI() {
                    TranslatorApp.dom.subjectSelect.value = TranslatorApp.state.selectedSubject;
                    this.populateGrades(TranslatorApp.state.selectedSubject);
                    TranslatorApp.dom.gradeSelect.value = TranslatorApp.state.selectedGrade;
                    this.updatePromptPreview();
                    this.updateMathGradeWarning();
                }
            },

            api: {
                // --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                async fetchWithRetry(url, options, maxRetries = 5, initialDelay = 1000) {
                    let attempt = 0;
                    let delay = initialDelay;

                    while (attempt < maxRetries) {
                        try {
                            // Ø¥Ø±ÙØ§Ù‚ Ø§Ù„Ù€ signal Ø§Ù„Ø®Ø§Øµ Ø¨Ù€ AbortController Ù…Ø¹ ÙƒÙ„ Ø·Ù„Ø¨
                            const response = await fetch(url, { ...options, signal: this.abortController?.signal });

                            if (response.ok) {
                                return response; // Ù†Ø¬Ø­ Ø§Ù„Ø·Ù„Ø¨
                            }

                            // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„ØªÙŠ ÙŠÙ…ÙƒÙ† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙŠÙ‡Ø§ (Ù…Ø«Ù„ Ø¶ØºØ· Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø£Ùˆ Ø®Ø·Ø£ Ø§Ù„Ø®Ø§Ø¯Ù…)
                            if (response.status === 429 || response.status >= 500) {
                                console.warn(`[API Retry] Ù…Ø­Ø§ÙˆÙ„Ø© ${attempt + 1}/${maxRetries} ÙØ´Ù„Øª Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ø®Ø·Ø£ ${response.status}. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ ${delay / 1000} Ø«Ø§Ù†ÙŠØ©...`);
                                attempt++;
                                await new Promise(resolve => setTimeout(resolve, delay));
                                delay *= 2; // Ù…Ø¶Ø§Ø¹ÙØ© ÙˆÙ‚Øª Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
                            } else {
                                // Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¹Ù…ÙŠÙ„ (Ù…Ø«Ù„ 400, 401, 404) Ù„Ø§ ÙŠØ¬Ø¨ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙŠÙ‡Ø§
                                console.error(`[API Error] ÙØ´Ù„ Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø®Ø·Ø£ Ø§Ù„Ø¹Ù…ÙŠÙ„ ${response.status}. Ù„Ù† ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.`);
                                return response; // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„ÙØ§Ø´Ù„Ø© Ù„ÙŠØªÙ… Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§
                            }

                        } catch (error) {
                            if (error.name === 'AbortError') {
                                console.log('[API Abort] ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨.');
                                throw error; // Ø¥ÙŠÙ‚Ø§Ù Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙˆØ±Ø§Ù‹ Ø¥Ø°Ø§ Ø£Ù„ØºÙ‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
                            }

                            console.warn(`[API Retry] Ù…Ø­Ø§ÙˆÙ„Ø© ${attempt + 1}/${maxRetries} ÙØ´Ù„Øª Ø¨Ø³Ø¨Ø¨ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©: ${error.message}. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ ${delay / 1000} Ø«Ø§Ù†ÙŠØ©...`);
                            attempt++;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                        }
                    }

                    throw new Error(`[API Error] ÙØ´Ù„ Ø§Ù„Ø·Ù„Ø¨ Ø¨Ø¹Ø¯ ${maxRetries} Ù…Ø­Ø§ÙˆÙ„Ø§Øª.`);
                },
                // --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---

                abortController: null,
                createAbortController() { if (this.abortController) this.abortController.abort(); this.abortController = new AbortController(); return this.abortController; },
                cancel() { if (this.abortController) { this.abortController.abort(); TranslatorApp.ui.showAlert('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø©.', 'info'); TranslatorApp.state.isTranslating = false; TranslatorApp.ui.showScreen('setup'); } },

                async translateInChunks(jobs, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = jobs.length;
                    let done = 0;
                    jobs.forEach((job, idx) => job.uid = idx);

                    for (let i = 0; i < jobs.length; i += CHUNK_SIZE) {
                        const chunk = jobs.slice(i, i + CHUNK_SIZE);
                        const items = chunk.map(j => ({ id: j.uid, text: j.originalText }));
                        TranslatorApp.ui.updateProgress(`Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ±Ø¬Ù…Ø©... (${Math.min(done + items.length, total)}/${total})`);
                        const outItems = await this.translateItemsBatch(items, apiKeyOrUrl, provider, localModelName, systemPrompt);
                        outItems.forEach(obj => {
                            const job = chunk.find(j => j.uid === obj.id);
                            if (!job) return;

                            // Get the translated text (which might still contain placeholders like __GLOSSARY_0__)
                            let translatedText = (obj.text || '').toString().trim();

                            // Revert the placeholders using the map we stored on the job object
                            if (job.placeholders) {
                                translatedText = TranslatorApp.remoteGlossary.revertPlaceholders(translatedText, job.placeholders);
                            }

                            // Apply post-processing (convert "and" to comma, enforce units, etc.)
                            const ctx = {
                                subject: TranslatorApp.state.selectedSubject,
                                grade: TranslatorApp.state.selectedGrade
                            };
                            translatedText = TranslatorApp.quality.postProcess(translatedText, ctx);

                            // Use the REAL original text as the key for the cache
                            const cacheKey = job.realOriginalText || job.originalText;
                            TranslatorApp.state.translationCache.set(cacheKey, translatedText);
                            
                            // Save to Translation Memory
                            if (TranslatorApp.dom.useTmCheckbox.checked) {
                                TranslatorApp.translationMemory.set(cacheKey, translatedText);
                            }
                        });
                        done += items.length;
                    }
                },

                async translateItemsBatch(items, apiKeyOrUrl, provider, localModelName = '', systemPrompt = '') {
                    const CONTEXT_SEPARATOR = TranslatorApp.constants.CONTEXT_SEPARATOR;
                    const userInstruction = `Translate all provided text to Modern Standard Arabic. Preserve HTML/LaTeX and placeholders.\nYou will receive a JSON object with an array "items": [{"id": number, "text": string}].\n- If "text" contains the exact separator "${CONTEXT_SEPARATOR}", translate each segment to Arabic and preserve the separator unchanged.\n- Preserve any HTML/LaTeX markup exactly.\n- Do NOT modify placeholders of the form __LOCK_n__ or __GLOSSARY_n__.\nReturn ONLY a valid JSON object: {"items":[{"id": number, "text": "translated"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;

                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON(systemPrompt, userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    try {
                        const data = JSON.parse(responseText);
                        if (!data || !Array.isArray(data.items)) throw new Error('Invalid JSON structure from model.');
                        return data.items.map(x => ({ id: x.id, text: x.text }));
                    } catch (e) {
                        console.warn('JSON parse failed, falling back to delimiter mode.', e);
                        const BATCH_SEPARATOR = TranslatorApp.constants.BATCH_SEPARATOR;
                        const flat = items.map(it => `${it.id}:::${it.text}`).join(BATCH_SEPARATOR);
                        const fallbackPrompt = `${userInstruction}\nNow process items separated by "${BATCH_SEPARATOR}". Each starts with "<id>:::". Return ONLY valid JSON as specified.\n\n${flat}`;
                        let resp;
                        if (provider === 'gemini') resp = await this.withGeminiText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else if (provider === 'chatgpt') resp = await this.withChatGPTText(systemPrompt, fallbackPrompt, apiKeyOrUrl, signal);
                        else resp = await this.withLocalModelText(systemPrompt, fallbackPrompt, apiKeyOrUrl, localModelName, signal);
                        const data2 = JSON.parse(resp);
                        if (!data2 || !Array.isArray(data2.items)) throw new Error('Invalid JSON structure from model (fallback).');
                        return data2.items.map(x => ({ id: x.id, text: x.text }));
                    }
                },

                async proofreadInChunks(items, apiKeyOrUrl, provider, localModelName = '') {
                    const CHUNK_SIZE = TranslatorApp.constants.CHUNK_SIZE;
                    const total = items.length;
                    let done = 0;
                    const allOut = [];
                    for (let i = 0; i < items.length; i += CHUNK_SIZE) {
                        const chunk = items.slice(i, i + CHUNK_SIZE);
                        TranslatorApp.ui.updateProgress(`ØªØ¯Ù‚ÙŠÙ‚ Ù„ØºÙˆÙŠ... (${Math.min(done + chunk.length, total)}/${total})`);
                        const out = await this.proofreadItemsBatch(chunk, apiKeyOrUrl, provider, localModelName);
                        allOut.push(...out);
                        done += chunk.length;
                    }
                    return allOut;
                },

                async proofreadItemsBatch(items, apiKeyOrUrl, provider, localModelName = '') {
                    const userInstruction = `You will receive JSON {"items":[{"id":number,"text":string}]}. Proofread Arabic grammar/style only.
- Do not add/remove content.
- Do not change digits, units, HTML, LaTeX, or any placeholders like __LOCK_n__ or __GLOSSARY_n__.
- Return ONLY {"items":[{"id":number,"text":"polished"}]}.`;
                    const payload = { items };
                    const signal = this.abortController?.signal;
                    let responseText;
                    if (provider === 'gemini') responseText = await this.withGeminiJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else if (provider === 'chatgpt') responseText = await this.withChatGPTJSON('', userInstruction, payload, apiKeyOrUrl, signal);
                    else responseText = await this.withLocalModelJSON('', userInstruction, payload, apiKeyOrUrl, localModelName, signal);

                    const data = JSON.parse(responseText);
                    return data.items;
                },

                async withGeminiJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}`;
                    const response = await this.fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }], generationConfig: { response_mime_type: "application/json" } })
                    });
                    if (!response.ok) { let err; try { err = await response.json(); } catch { } throw new Error(`Gemini API Error: ${err?.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTJSON(systemPrompt, userInstruction, payload, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = [];
                    if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: `${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}` });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await this.fetchWithRetry(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2, response_format: { type: "json_object" } })
                            });
                            if (!response.ok) {
                                let err; try { err = await response.json(); } catch { }
                                lastError = new Error(`ChatGPT API Error: ${err?.error?.message || response.statusText}`);
                                continue;
                            }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelJSON(systemPrompt, userInstruction, payload, url, modelName, signal) {
                    const fullPrompt = `${systemPrompt || ''}\n\n${userInstruction}\n\nPayload:\n${JSON.stringify(payload)}\n\nReturn ONLY JSON.`;
                    const response = await this.fetchWithRetry(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: fullPrompt, system: '', stream: false, format: 'json' })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                },
                async withGeminiText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
                    const fullPrompt = systemPrompt ? `${systemPrompt}\n\n---\n\n${userPrompt}` : userPrompt;
                    const response = await this.fetchWithRetry(apiUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(`Gemini API Error: ${err.error?.message || response.statusText}`); }
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                },
                async withChatGPTText(systemPrompt, userPrompt, apiKey, signal) {
                    const apiUrl = 'https://api.openai.com/v1/chat/completions';
                    const messages = []; if (systemPrompt) messages.push({ role: 'system', content: systemPrompt });
                    messages.push({ role: 'user', content: userPrompt });
                    const candidateModels = ['gpt-4.1', 'gpt-4o-mini', 'gpt-4o', 'gpt-4.1-mini'];
                    let lastError = null;
                    for (const model of candidateModels) {
                        try {
                            const response = await this.fetchWithRetry(apiUrl, {
                                method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, signal,
                                body: JSON.stringify({ model, messages, temperature: 0.2 })
                            });
                            if (!response.ok) { const err = await response.json(); lastError = new Error(`ChatGPT API Error: ${err.error?.message || response.statusText}`); continue; }
                            const data = await response.json();
                            return data.choices?.[0]?.message?.content || '';
                        } catch (e) { lastError = e; }
                    }
                    throw lastError || new Error('ChatGPT API Error: Unable to complete request');
                },
                async withLocalModelText(systemPrompt, userPrompt, url, modelName, signal) {
                    const response = await this.fetchWithRetry(url, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, signal,
                        body: JSON.stringify({ model: modelName, prompt: userPrompt, system: systemPrompt, stream: false })
                    });
                    if (!response.ok) throw new Error(`Local server error: ${response.status} ${response.statusText}`);
                    const data = await response.json();
                    return data.response || '';
                }
            },

            history: {
                stack: [],
                currentIndex: -1,
                timeout: null,


                init() {
                    this.updateButtons();
                },

                push(state) {
                    const MAX_HISTORY = TranslatorApp.constants.HISTORY_MAX;
                    if (this.timeout) clearTimeout(this.timeout);

                    this.timeout = setTimeout(() => {
                        try {
                            this.stack = this.stack.slice(0, this.currentIndex + 1);
                            const snapshot = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                            this.stack.push(snapshot);

                            if (this.stack.length > MAX_HISTORY) {
                                this.stack.shift();
                            } else {
                                this.currentIndex++;
                            }

                            this.updateButtons();
                        } catch (error) {
                            console.error('History push error:', error);
                            // Reset history if there's an error
                            this.stack = [];
                            this.currentIndex = -1;
                            this.updateButtons();
                        }
                    }, 400);
                },

                undo() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                redo() {
                    if (this.currentIndex < this.stack.length - 1) {
                        this.currentIndex++;
                        this.restore(this.stack[this.currentIndex]);
                    }
                },

                restore(state) {
                    try {
                        TranslatorApp.state.translatedJsonData = (window.structuredClone ? structuredClone(state) : JSON.parse(JSON.stringify(state)));
                        TranslatorApp.preview.render();
                        this.updateButtons();
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('History restore error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©.', 'error');
                    }
                },

                updateButtons() {
                    TranslatorApp.dom.undoBtn.disabled = this.currentIndex <= 0;
                    TranslatorApp.dom.redoBtn.disabled = this.currentIndex >= this.stack.length - 1;
                },

            },
            // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¯Ø§Ù„Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (ØªØ­Ù„ÙŠÙ„ HTML ÙˆØªÙˆÙ„ÙŠØ¯ Ù…Ù‡Ø§Ù… Ù„Ø¹ÙÙ‚Ø¯ Ø§Ù„Ù†Øµ)
            async startTranslationProcess() {
                const apiProvider = document.querySelector('input[name="apiProvider"]:checked').value;
                let apiKeyOrUrl;
                let localModelName;
            
                try {
                    if (apiProvider === 'gemini') {
                        apiKeyOrUrl = this.dom.geminiKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'gemini')) {
                            return this.ui.showAlert(`Ù…ÙØªØ§Ø­ API Ù„Ù€ Gemini ØºÙŠØ± ØµØ§Ù„Ø­.`, 'error');
                        }
                    } else if (apiProvider === 'chatgpt') {
                        apiKeyOrUrl = this.dom.chatgptKeyInput.value.trim();
                        if (!this.validation.validateApiKey(apiKeyOrUrl, 'chatgpt')) {
                            return this.ui.showAlert(`Ù…ÙØªØ§Ø­ API Ù„Ù€ ChatGPT ØºÙŠØ± ØµØ§Ù„Ø­.`, 'error');
                        }
                    } else if (apiProvider === 'local') {
                        apiKeyOrUrl = this.dom.localModelUrl.value.trim();
                        localModelName = this.dom.localModelName.value.trim();
                        const validation = this.validation.validateLocalModelSettings(apiKeyOrUrl, localModelName);
                        if (!validation.valid) {
                            return this.ui.showAlert(validation.message, 'error');
                        }
                    } else {
                        return this.ui.showAlert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ø²ÙˆØ¯ Ø®Ø¯Ù…Ø© ØµØ§Ù„Ø­.', 'error');
                    }
            
                    if (this.state.selectedFilesInfo.length === 0) {
                        return this.ui.showAlert('Ø§Ø®ØªØ± Ù…Ù„Ù JSON ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„.', 'error');
                    }
                } catch (validationError) {
                    return this.ui.showAlert('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©.', 'error');
                }
            
                this.ui.showScreen('progress');
                this.dom.translateBtn.disabled = true;
                this.state.translationCache.clear();
                this.state.startTime = Date.now();
                this.api.createAbortController();
                this.state.isTranslating = true;
            
                try {
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª...');
                    await this.fileHandler.readFilesFromInput();
                    this.state.translatedJsonData = JSON.parse(JSON.stringify(this.state.originalJsonData));
                    this.state.initialTranslatedJsonData = [];
            
                    const allJobs = [];
                    const parsedDataMap = new Map();
            
                    const processField = (htmlString, basePointer) => {
                        if (!htmlString || typeof htmlString !== 'string') return;
                        const { jobs, parsedBody } = this.utils.parseHtmlAndCreateJobs(htmlString, basePointer);
                        allJobs.push(...jobs);
                        const mapKey = JSON.stringify(basePointer);
                        parsedDataMap.set(mapKey, parsedBody);
                    };
                    
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙˆØªØ¬Ù‡ÙŠØ² Ø§Ù„Ù†ØµÙˆØµ...');
            
                    this.state.originalJsonData.forEach((file, fileIndex) => {
                        // Process statement field
                        processField(file.data.statement, { fileIndex, key: 'statement' });
                        
                        // Process parts
                        file.data.parts?.forEach((part, partIndex) => {
                            const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                            
                            // Process stem field
                            processField(part.stem, { fileIndex, partIndex, key: 'stem' });
            
                            // Process answer field
                            if (originalPart.answer) {
                                if (Array.isArray(originalPart.answer)) {
                                    originalPart.answer.forEach((answerItem, answerIndex) => {
                                        processField(answerItem, { fileIndex, partIndex, answerIndex, key: 'answer', isArray: true });
                                    });
                                } else if (typeof originalPart.answer === 'string') {
                                    processField(originalPart.answer, { fileIndex, partIndex, key: 'answer' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('key') && originalPart.answer.hasOwnProperty('value') && originalPart.answer.hasOwnProperty('unit')) {
                                    // Special case for a more complex object answer type
                                    processField(originalPart.answer.key, { fileIndex, partIndex, key: 'answer', subKey: 'key' });
                                    processField(originalPart.answer.value, { fileIndex, partIndex, key: 'answer', subKey: 'value' });
                                    // Translate unit directly using unitsMap instead of sending to AI
                                    const originalUnit = originalPart.answer.unit || '';
                                    const translatedUnit = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                                    this.state.translatedJsonData[fileIndex].data.parts[partIndex].answer.unit = translatedUnit;
                                }
                            }
                            
                            // Process choices
                            originalPart.choices?.forEach((choice, choiceIndex) => {
                                processField(choice.html_content, { fileIndex, partIndex, choiceIndex, key: 'choice' });
                            });
                            
                            // Process gap_text_keys
                            if (originalPart.gap_text_keys) {
                                originalPart.gap_text_keys.forEach((keyItem, keyIndex) => {
                                    processField(keyItem.value, { fileIndex, partIndex, key: 'gap_text_keys', keyIndex: keyIndex, subKey: 'value' });
                                });
                            }
                            
                            // Process ai.guidelines (for string type questions)
                            if (originalPart.ai && originalPart.ai.guidelines && Array.isArray(originalPart.ai.guidelines)) {
                                originalPart.ai.guidelines.forEach((guideline, guidelineIndex) => {
                                    // Translate student_answer
                                    if (guideline.student_answer && typeof guideline.student_answer === 'string') {
                                        processField(guideline.student_answer, { fileIndex, partIndex, key: 'ai_guideline', guidelineIndex, subKey: 'student_answer' });
                                    }
                                    // Translate comment
                                    if (guideline.comment && typeof guideline.comment === 'string') {
                                        processField(guideline.comment, { fileIndex, partIndex, key: 'ai_guideline', guidelineIndex, subKey: 'comment' });
                                    }
                                });
                            }
                        });
                    });
                    
                    const uniqueJobs = [];
                    const seen = new Set();
                    for (const job of allJobs) {
                        if (!seen.has(job.originalText)) {
                            seen.add(job.originalText);
                            uniqueJobs.push(job);
                        }
                    }
                    
                    // Check Translation Memory first
                    let tmHits = 0;
                    let jobsToTranslate = [];
                    
                    if (this.dom.useTmCheckbox.checked) {
                        this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©...');
                        const ctx = {
                            subject: this.state.selectedSubject,
                            grade: this.state.selectedGrade
                        };
                        uniqueJobs.forEach(job => {
                            const tmEntry = this.translationMemory.get(job.originalText);
                            if (tmEntry && tmEntry.translation) {
                                // Use cached translation and apply post-processing for current context
                                let processedTranslation = this.quality.postProcess(tmEntry.translation, ctx);
                                this.state.translationCache.set(job.originalText, processedTranslation);
                                tmHits++;
                            } else {
                                // Need to translate this
                                jobsToTranslate.push(job);
                            }
                        });
                        
                        if (tmHits > 0) {
                            console.log(`TM hits: ${tmHits}/${uniqueJobs.length}`);
                            this.ui.updateProgress(`ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ ${tmHits} ØªØ±Ø¬Ù…Ø© Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø©...`);
                        }
                    } else {
                        jobsToTranslate = uniqueJobs;
                    }
                    
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ·Ù„Ø­Ø§Øª Ø§Ù„Ù…Ø¹ØªÙ…Ø¯Ø©...');
                    const allTextsForGlossary = jobsToTranslate.map(j => j.originalText);
                    await this.remoteGlossary.fetchApproved(this.state.selectedSubject, this.state.selectedGrade, allTextsForGlossary);
            
                    jobsToTranslate.forEach(job => {
                        const { modifiedText, placeholders } = this.remoteGlossary.applyWithPlaceholders(job.originalText);
                        job.realOriginalText = job.originalText;
                        job.originalText = modifiedText;
                        job.placeholders = placeholders;
                    });
            
                    if (jobsToTranslate.length > 0) {
                        // ğŸ” Debug: Log translation context
                        console.log('ğŸš€ [Translation Start]', {
                            subject: this.state.selectedSubject,
                            grade: this.state.selectedGrade,
                            jobCount: jobsToTranslate.length,
                            isGradeSelected: this.state.selectedGrade !== 'None'
                        });
                        
                        this.ui.updateProgress(`Ø¬Ø§Ø±ÙŠ ØªØ±Ø¬Ù…Ø© ${jobsToTranslate.length} Ù†Øµ Ø¬Ø¯ÙŠØ¯...`);
                        const systemPrompt = this.subjects.buildSystemPrompt();
                        await this.api.translateInChunks(jobsToTranslate, apiKeyOrUrl, apiProvider, localModelName, systemPrompt);
                    }
            
                    this.ui.updateProgress('Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ±Ø¬Ù…...');
            
                    allJobs.forEach(job => {
                        const cacheKey = job.realOriginalText || job.originalText;
                        let translatedText = this.state.translationCache.get(cacheKey);
                        if (translatedText && job.domNode) {
                            translatedText = this.quality.cleanLatexArabic(translatedText);
                            job.domNode.nodeValue = translatedText;
                        }
                    });
            
                    for (const [mapKey, parsedBody] of parsedDataMap.entries()) {
                        const pointer = JSON.parse(mapKey);
                        const finalHtml = parsedBody.innerHTML;
                        let cleanedHtml = TranslatorApp.quality.cleanLatexArabic(finalHtml);
                        
                        // Process math-field tags for grade-specific conversions
                        const ctx = {
                            subject: this.state.selectedSubject,
                            grade: this.state.selectedGrade
                        };
                        
                        // Ensure RTL direction for Arabic content
                        cleanedHtml = TranslatorApp.quality.ensureRTLDirection(cleanedHtml, ctx);
                        cleanedHtml = this.quality.processMathFieldsForGrade(cleanedHtml, ctx);
                        
                        const { fileIndex, partIndex, choiceIndex, key, keyIndex, subKey, answerIndex, isArray } = pointer;
                        let target = this.state.translatedJsonData[fileIndex].data;
            
                        if (key === 'statement') {
                            target.statement = cleanedHtml;
                        } else if (key === 'stem') {
                            target.parts[partIndex].stem = cleanedHtml;
                        } else if (key === 'answer') {
                            if (isArray) { // Check if the original was an array
                                if (target.parts?.[partIndex]?.answer && target.parts[partIndex].answer.length > answerIndex) {
                                     target.parts[partIndex].answer[answerIndex] = cleanedHtml;
                                }
                            } else if (subKey === 'value') {
                                target.parts[partIndex].answer.value = cleanedHtml;
                            } else if (subKey === 'key') {
                                 target.parts[partIndex].answer.key = cleanedHtml;
                            } else if (subKey === 'unit') {
                                 target.parts[partIndex].answer.unit = cleanedHtml;
                            } else {
                                target.parts[partIndex].answer = cleanedHtml;
                            }
                        } else if (key === 'choice') {
                            target.parts[partIndex].choices[choiceIndex].html_content = cleanedHtml;
                        } else if (key === 'gap_text_keys' && subKey === 'value') {
                            if (target.parts[partIndex].gap_text_keys && target.parts[partIndex].gap_text_keys[keyIndex]) {
                                target.parts[partIndex].gap_text_keys[keyIndex].value = cleanedHtml;
                            }
                        } else if (key === 'ai_guideline') {
                            // Handle ai.guidelines translation
                            const guidelineIndex = pointer.guidelineIndex;
                            if (target.parts[partIndex].ai && target.parts[partIndex].ai.guidelines && target.parts[partIndex].ai.guidelines[guidelineIndex]) {
                                if (subKey === 'student_answer') {
                                    target.parts[partIndex].ai.guidelines[guidelineIndex].student_answer = cleanedHtml;
                                } else if (subKey === 'comment') {
                                    target.parts[partIndex].ai.guidelines[guidelineIndex].comment = cleanedHtml;
                                }
                            }
                        }
                    }
            
                    this.state.activeScreen = 'preview';
                    // Save initial translation for diff comparison
                    this.state.initialTranslatedJsonData = JSON.parse(JSON.stringify(this.state.translatedJsonData));
                    this.history.push(this.state.translatedJsonData);
                    
                    // Save Translation Memory to localStorage
                    if (this.dom.useTmCheckbox.checked) {
                        this.translationMemory.save();
                        this.translationMemory.updateUI();
                    }
                    
                    this.session.save();
                    this.ui.showScreen('preview');
                    this.preview.render();
                    const stats = this.statistics.calculate();
                    this.ui.renderStatistics(stats);
                    
                    // Show success message with TM stats
                    let successMessage = 'ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­';
                    if (this.dom.useTmCheckbox.checked && tmHits > 0) {
                        successMessage += ` (ØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… ${tmHits} ØªØ±Ø¬Ù…Ø© Ù…Ø­ÙÙˆØ¸Ø©)`;
                    }
                    this.ui.showAlert(successMessage, 'success');
            
                } catch (error) {
                    if (error?.name !== 'AbortError') {
                        console.error('Translation process failed:', error);
                        this.ui.showAlert(error.message, 'error');
                        this.ui.showScreen('setup');
                    }
                } finally {
                    this.dom.translateBtn.disabled = false;
                    this.state.isTranslating = false;
                }
            },

            statistics: {
                calculate() {
                    let totalTexts = 0, totalWords = 0;
                    const count = (text) => {
                        if (text && typeof text === 'string') {
                            totalTexts++;
                            const div = document.createElement('div'); div.innerHTML = text;
                            totalWords += (div.textContent || div.innerText || "").split(/\s+/).filter(Boolean).length;
                        }
                    };
                    TranslatorApp.state.originalJsonData.forEach(file => {
                        count(file.data.statement);
                        file.data.parts?.forEach(part => {
                            count(part.stem);
                            if (typeof part.answer === 'string') count(part.answer);
                            part.choices?.forEach(choice => count(choice.html_content));
                            part.gap_text_keys?.forEach(keyItem => count(keyItem.value));
                        });
                    });
                    const timeElapsed = TranslatorApp.state.startTime ? ((Date.now() - TranslatorApp.state.startTime) / 1000).toFixed(1) : 0;
                    return { totalFiles: TranslatorApp.state.selectedFilesInfo.length, totalTexts, totalWords, timeElapsed };
                }
            },

            ui: {
                showScreen(screen) {
                    try {
                        TranslatorApp.state.activeScreen = screen;
                        ['setupSection', 'progressContainer', 'previewSection', 'analyticsSection'].forEach(id => {
                            try {
                                TranslatorApp.dom[id]?.classList.add('hidden');
                            } catch (error) {
                                console.warn(`Error hiding ${id}:`, error);
                            }
                        });

                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.setupSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing setup section:', error);
                            }
                        }
                        if (screen === 'progress') {
                            try {
                                TranslatorApp.dom.progressContainer.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing progress container:', error);
                            }
                        }
                        if (screen === 'preview') {
                            try {
                                TranslatorApp.dom.previewSection.classList.remove('hidden');
                                TranslatorApp.dom.analyticsSection.classList.remove('hidden');
                            } catch (error) {
                                console.warn('Error showing preview section:', error);
                            }
                        }

                        // Reset any error states
                        if (screen === 'setup') {
                            try {
                                TranslatorApp.dom.translateBtn.disabled = false;
                                TranslatorApp.state.isTranslating = false;
                            } catch (error) {
                                console.warn('Error resetting translate button:', error);
                            }
                        }
                    } catch (error) {
                        console.error('Show screen error:', error);
                    }
                },
                updateProgress(text) {
                    try {
                        TranslatorApp.dom.progressText.textContent = text;
                    } catch (error) {
                        console.error('Update progress error:', error);
                    }
                },
                showAlert(message, type = 'error', duration = 5000) {
                    const colors = { error: 'bg-red-500', success: 'bg-green-500', info: 'bg-blue-500', warning: 'bg-yellow-500' };
                    const alertBox = document.createElement('div');
                    alertBox.className = `alert flex justify-between items-center text-white p-4 rounded-lg shadow-xl ${colors[type] || 'bg-gray-500'}`;

                    // Sanitize message to prevent XSS
                    const sanitizedMessage = TranslatorApp.security.sanitize(message);
                    alertBox.innerHTML = `<span>${sanitizedMessage}</span><button class="mr-2 text-xl font-bold" aria-label="Ø¥ØºÙ„Ø§Ù‚">&times;</button>`;

                    alertBox.querySelector('button').onclick = () => alertBox.remove();
                    TranslatorApp.dom.alertContainer.appendChild(alertBox);

                    // Auto-remove after duration
                    if (duration) {
                        setTimeout(() => {
                            alertBox.classList.add('fade-out');
                            alertBox.addEventListener('transitionend', () => alertBox.remove());
                        }, duration);
                    }

                    // Log to console for debugging
                    console.log(`[${type.toUpperCase()}] ${message}`);
                },
                renderFileList() {
                    try {
                        const { fileList } = TranslatorApp.dom;
                        fileList.innerHTML = '';
                        if (TranslatorApp.state.selectedFilesInfo.length === 0) return;
                        const ul = document.createElement('ul');
                        ul.className = 'my-4 space-y-2';
                        TranslatorApp.state.selectedFilesInfo.forEach((fileInfo, index) => {
                            const li = document.createElement('li');
                            li.className = 'flex justify-between items-center p-2 rounded-lg';
                            li.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 5%, var(--card-bg))';
                            li.innerHTML = `<span class="font-medium">${TranslatorApp.security.sanitize(fileInfo.name)}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-700 font-bold text-xl" aria-label="Ø¥Ø²Ø§Ù„Ø©">&times;</button>`;
                            ul.appendChild(li);
                        });
                        fileList.appendChild(ul);
                        fileList.querySelectorAll('.remove-file-btn').forEach(btn => {
                            btn.onclick = (e) => {
                                try {
                                    TranslatorApp.fileHandler.removeFile(parseInt(btn.dataset.index));
                                } catch (error) {
                                    console.error('Remove file error:', error);
                                    TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ù.', 'error');
                                }
                            };
                        });
                    } catch (error) {
                        console.error('Render file list error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª.', 'error');
                    }
                },
                showGlossaryModal(show) {
                    try {
                        TranslatorApp.dom.glossaryModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show glossary modal error:', error);
                    }
                },

                // --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                // (Ø¯Ø§Ù„Ø© Ù…Ø®ØµØµØ© Ù„Ø¥Ø¸Ù‡Ø§Ø± Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯)
                showConfirmModal(message, onConfirm) {
                    try {
                        const modal = document.getElementById('confirmModal');
                        const msgEl = document.getElementById('confirmMessage');
                        const okBtn = document.getElementById('confirmOkBtn');
                        const cancelBtn = document.getElementById('confirmCancelBtn');

                        if (!modal || !msgEl || !okBtn || !cancelBtn) {
                            console.error("Ø¹Ù†Ø§ØµØ± Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©.");
                            // ÙƒØ­Ù„ Ø§Ø­ØªÙŠØ§Ø·ÙŠØŒ Ù†ÙØ° Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ø§Ù„Ù€ modal
                            if (confirm(message)) { // Ø§Ø³ØªØ®Ø¯Ø§Ù… confirm ÙƒØ§Ø­ØªÙŠØ§Ø·ÙŠ Ø£Ø®ÙŠØ±
                                onConfirm();
                            }
                            return;
                        }

                        msgEl.textContent = message;

                        // Ø§Ø³ØªØ®Ø¯Ø§Ù… .cloneNode(true) Ù„Ø¥Ø²Ø§Ù„Ø© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø³Ø§Ø¨Ù‚ÙŠÙ† Ù‚Ø¨Ù„ Ø¥Ø¶Ø§ÙØ© Ø¬Ø¯Ø¯
                        const newOkBtn = okBtn.cloneNode(true);
                        okBtn.parentNode.replaceChild(newOkBtn, okBtn);

                        const newCancelBtn = cancelBtn.cloneNode(true);
                        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

                        newOkBtn.onclick = () => {
                            modal.classList.add('hidden');
                            if (onConfirm) onConfirm();
                        };

                        newCancelBtn.onclick = () => {
                            modal.classList.add('hidden');
                        };

                        modal.classList.remove('hidden');
                    } catch (e) {
                        console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¸Ù‡Ø§Ø± Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯:", e);
                        // ÙƒØ­Ù„ Ø§Ø­ØªÙŠØ§Ø·ÙŠØŒ Ù†ÙØ° Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù…Ø¨Ø§Ø´Ø±Ø©
                        if (confirm(message)) {
                            onConfirm();
                        }
                    }
                },
                // --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                showMappedIdsModal(show) {
                    try {
                        TranslatorApp.dom.mappedIdsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show mapped IDs modal error:', error);
                    }
                },
                showSubjectsModal(show) {
                    try {
                        TranslatorApp.dom.subjectsModal.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show subjects modal error:', error);
                    }
                },
                showModal(id, show) {
                    try {
                        const el = TranslatorApp.dom[id];
                        if (el) el.classList.toggle('hidden', !show);
                    } catch (error) {
                        console.error('Show modal error:', error);
                    }
                },
                renderStatistics(stats) {
                    try {
                        const { statsContainer } = TranslatorApp.dom;
                        statsContainer.innerHTML = '';
                        const map = {
                            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª': stats.totalFiles,
                            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù†ØµÙˆØµ': stats.totalTexts,
                            'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„Ù…Ø§Øª': stats.totalWords,
                            'Ø²Ù…Ù† Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ø«)': stats.timeElapsed
                        };
                        Object.entries(map).forEach(([label, value]) => {
                            const card = document.createElement('div');
                            card.className = 'p-4 rounded-lg';
                            card.style.backgroundColor = 'color-mix(in srgb, var (--primary-color) 10%, var (--card-bg))';
                            card.innerHTML = `<div class="text-2xl font-bold" style="color: var (--primary-color);">${value}</div><div class="text-sm" style="color: var (--secondary-text);">${label}</div>`;
                            statsContainer.appendChild(card);
                        });
                    } catch (error) {
                        console.error('Render statistics error:', error);
                    }
                },
                setSaveIndicator(state) {
                    try {
                        const el = TranslatorApp.dom.saveIndicator;
                        if (!el) return;

                        if (state === 'saving') {
                            el.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...';
                            el.classList.remove('saved', 'error');
                        }
                        else if (state === 'saved') {
                            el.textContent = 'âœ“ Ù…Ø­ÙÙˆØ¸';
                            el.classList.add('saved');
                            el.classList.remove('error');
                            setTimeout(() => {
                                el.textContent = 'â€”';
                                el.classList.remove('saved');
                            }, 2000);
                        }
                        else if (state === 'error') {
                            el.textContent = 'âœ— Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸';
                            el.classList.add('error');
                            el.classList.remove('saved');
                        }
                        else {
                            el.textContent = 'â€”';
                            el.classList.remove('saved', 'error');
                        }
                    } catch (error) {
                        console.error('Save indicator error:', error);
                    }
                }
            },

            preview: {
                dmp: new diff_match_patch(),


                processBlankTags(htmlString) {
                    try {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;
                        
                        let processed = htmlString;
                        
                        // Handle data-node-type="blank-line" tags (like in the JSON file)
                        processed = processed.replace(
                            /<span\s+data-node-type=["']blank-line["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                // Convert &nbsp; to actual space and create a blank slot
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                // Escape quotes in data-blank attribute
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle data-node-type="blank" tags
                        processed = processed.replace(
                            /<span\s+data-node-type=["']blank["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle any span with data-node-variation="space"
                        processed = processed.replace(
                            /<span[^>]*data-node-variation=["']space["'][^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // Handle any other blank-related attributes
                        processed = processed.replace(
                            /<span[^>]*data-blank[^>]*>(.*?)<\/span>/gi,
                            (match, content) => {
                                const blankContent = content.replace(/&nbsp;/g, ' ').trim() || '___';
                                const escapedBlank = blankContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<span class="blank-slot rtl-auto" data-blank="${escapedBlank}" dir="rtl">${blankContent}</span>`;
                            }
                        );
                        
                        // CRITICAL FIX: Handle underscore blanks (___) with proper spacing
                        processed = processed.replace(
                            /_{3,}/g,
                            (match) => {
                                return `<span class="blank-slot" data-blank="true" contenteditable="false" style="border-bottom: 2px solid #333; padding: 0 4px; margin: 0 2px; min-width: 20px; display: inline-block; background-color: #f0f0f0;">&nbsp;___&nbsp;</span>`;
                            }
                        );
                        
                        // Handle single underscore blanks with proper spacing
                        processed = processed.replace(
                            /\b_\b/g,
                            (match) => {
                                return `<span class="blank-slot" data-blank="true" contenteditable="false" style="border-bottom: 2px solid #333; padding: 0 4px; margin: 0 2px; min-width: 20px; display: inline-block; background-color: #f0f0f0;">&nbsp;_&nbsp;</span>`;
                            }
                        );
                        
                        // CRITICAL FIX: Preserve spaces around blanks
                        processed = processed.replace(
                            /(\s+)<span class="blank-slot[^>]*>([^<]*)<\/span>(\s+)/g,
                            (match, beforeSpace, blankContent, afterSpace) => {
                                return `${beforeSpace}<span class="blank-slot" data-blank="true" contenteditable="false" style="border-bottom: 2px solid #333; padding: 0 4px; margin: 0 2px; min-width: 20px; display: inline-block; background-color: #f0f0f0;">${blankContent}</span>${afterSpace}`;
                            }
                        );
                        
                        return processed;
                    } catch (error) {
                        console.error('Process blank tags error:', error);
                        return htmlString;
                    }
                },
                
                /* // <--- ØªØ¹Ø·ÙŠÙ„ Ø¯Ø§Ù„Ø© processMathFieldTags Ø§Ù„Ø«Ø§Ù†ÙŠØ©
                processMathFieldTags(htmlString) {
                    try {
                        if (!htmlString || typeof htmlString !== 'string') return htmlString;
                        
                        let processed = htmlString;
                        
                        // CRITICAL FIX 0: Clean nested math-field tags first using our new cleaner
                        processed = TranslatorApp.utils.cleanMathFieldTags(processed);
                        
                        // CRITICAL FIX 1: Handle math-field tags properly
                        // If a math-field has a value attribute, remove innerHTML (MathLive will render from value)
                        // If no value attribute, convert innerHTML to value attribute
                        const beforeCleanInner = processed;
                        processed = processed.replace(
                            /<math-field([^>]*?)>(.*?)<\/math-field>/gi,
                            (fullMatch, attributes, content) => {
                                // Check if value attribute exists
                                const hasValue = /value\s*=\s*["'][^"']*["']/.test(attributes);
                                
                                if (hasValue) {
                                    // Has value: remove content (MathLive renders from value)
                                    return `<math-field${attributes}></math-field>`;
                                } else if (content && content.trim()) {
                                    // No value but has content: move content to value attribute
                                    const cleanContent = content.trim()
                                        .replace(/&lt;/g, '<')
                                        .replace(/&gt;/g, '>')
                                        .replace(/&amp;/g, '&')
                                        .replace(/&quot;/g, '"');
                                    return `<math-field${attributes} value="${cleanContent}"></math-field>`;
                                } else {
                                    // No value and no content: keep as is (might be placeholder)
                                    return `<math-field${attributes}></math-field>`;
                                }
                            }
                        );
                        
                        if (beforeCleanInner !== processed) {
                            console.log('âœ¨ [MathField Fix] Processed math-field innerHTML and value attributes');
                        }
                        
                        // CRITICAL FIX 2: Clean up malformed math-field tags
                        // Fix broken tags like <math-fieldvalue= to <math-field value=
                        const beforeFix = processed;
                        
                        processed = processed
                            .replace(/<math-fieldvalue=/g, '<math-field value=')
                            .replace(/<math-fielddefault-mode=/g, '<math-field default-mode=')
                            .replace(/<math-fieldread-only/g, '<math-field read-only')
                            .replace(/<math-fielddir=/g, '<math-field dir=')
                            .replace(/<math-fieldvirtual-keyboard-mode=/g, '<math-field virtual-keyboard-mode=')
                            .replace(/<math-fielduse-shared-virtual-keyboard/g, '<math-field use-shared-virtual-keyboard');
                        
                        // EXTRA ROBUSTNESS: Fix broken tags written as text with spaces and the Unicode minus sign (âˆ’)
                        // Examples seen: "< math âˆ’ fieldvalue =", "< math - fielddefault-mode =", etc.
                        const minusOrHyphen = '[\\-\u2212\u2013\u2014]';
                        processed = processed
                            // < math - fieldvalue =  â†’  <math-field value=
                            .replace(new RegExp(`<\\s*math\\s*${minusOrHyphen}\\s*fieldvalue\\s*=`, 'gi'), '<math-field value=')
                            // < math - field value =  â†’  <math-field value=
                            .replace(new RegExp(`<\\s*math\\s*${minusOrHyphen}\\s*field\\s*value\\s*=`, 'gi'), '<math-field value=')
                            // < math - fielddefault-mode =  â†’  <math-field default-mode=
                            .replace(new RegExp(`<\\s*math\\s*${minusOrHyphen}\\s*fielddefault-mode\\s*=`, 'gi'), '<math-field default-mode=')
                            // < math - field read-only  â†’  <math-field read-only
                            .replace(new RegExp(`<\\s*math\\s*${minusOrHyphen}\\s*field\\s*read-only`, 'gi'), '<math-field read-only')
                            // < math - fielddir =  â†’  <math-field dir=
                            .replace(new RegExp(`<\\s*math\\s*${minusOrHyphen}\\s*fielddir\\s*=`, 'gi'), '<math-field dir=')
                            // Generic collapse: < math - field  â†’  <math-field
                            .replace(new RegExp(`<\\s*math\\s*${minusOrHyphen}\\s*field`, 'gi'), '<math-field');

                        if (beforeFix !== processed) {
                            console.log('ğŸ”§ [MathField Fix] Fixed malformed math-field tags');
                        }
                        
                        // CRITICAL FIX 3: Handle multiline math-field tags with /gs flag
                        processed = processed.replace(/<math-field([^>]*)>/gs, (match, attributes) => {
                            // Normalize whitespace and line breaks
                            const normalizedAttrs = attributes.replace(/\s+/g, ' ').trim();
                            
                            // Extract essential attributes only
                            const valueMatch = normalizedAttrs.match(/value="([^"]*)"/);
                            const modeMatch = normalizedAttrs.match(/default-mode="([^"]*)"/);
                            const localeMatch = normalizedAttrs.match(/locale="([^"]*)"/);
                            const readOnlyMatch = normalizedAttrs.match(/read-only/);
                            const dirMatch = normalizedAttrs.match(/dir="([^"]*)"/);
                            
                            // Build clean tag
                            let cleanAttrs = '';
                            if (valueMatch) cleanAttrs += ` value="${valueMatch[1]}"`;
                            if (modeMatch) cleanAttrs += ` default-mode="${modeMatch[1]}"`;
                            if (localeMatch) cleanAttrs += ` locale="${localeMatch[1]}"`;
                            if (readOnlyMatch) cleanAttrs += ` read-only`;
                            if (dirMatch) cleanAttrs += ` dir="${dirMatch[1]}"`;
                            
                            return `<math-field${cleanAttrs}>`;
                        });
                        
                        // Clean math-field tags - remove unnecessary attributes
                        processed = TranslatorApp.utils.cleanMathFieldTags(processed);
                        
                        // CRITICAL FIX 3: Remove ALL Lexical theme wrapper spans around math-field
                        // These wrappers prevent MathLive from rendering properly
                        
                        // Remove LexicalTheme__math (block mode)
                        processed = processed.replace(
                            /<span\s+class=["']LexicalTheme__math["'][^>]*>(<math-field[^>]*><\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove LexicalTheme__math--inline (inline mode)
                        processed = processed.replace(
                            /<span\s+class=["']LexicalTheme__math--inline["'][^>]*>(<math-field[^>]*><\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove merge wrapper spans
                        processed = processed.replace(
                            /<span\s+class=["']merge["'][^>]*>(<math-field[^>]*><\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove generic spans with data-node-type="math"
                        processed = processed.replace(
                            /<span[^>]*data-node-type=["']math["'][^>]*>(<math-field[^>]*><\/math-field>)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove ALL dir="ltr" spans FIRST - these are AI-generated and should be removed
                        // This is the most common issue, so handle it first
                        const beforeDirRemoval = processed;
                        processed = processed.replace(
                            /<span\s+dir=["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Debug: log if we removed any dir="ltr" spans
                        if (beforeDirRemoval !== processed) {
                            console.log('Removed dir="ltr" spans:', beforeDirRemoval, 'â†’', processed);
                        }
                        
                        // Also handle spans with dir="ltr" and other attributes
                        processed = processed.replace(
                            /<span[^>]*dir=["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove white-space: pre-wrap spans (they're just wrappers for text)
                        processed = processed.replace(
                            /<span[^>]*style=["'][^"']*white-space:\s*pre-wrap[^"']*["'][^>]*>([^<]+)<\/span>/gi,
                            '$1'
                        );
                        
                        // Remove LexicalTheme__paragraph wrapper
                        processed = processed.replace(
                            /<p\s+class=["']LexicalTheme__paragraph["'][^>]*>(.*?)<\/p>/gi,
                            '$1'
                        );
                        
                        // Fix malformed tags like "yspan>", "xspan>", "gspan>" - these are broken AI output
                        processed = processed.replace(
                            /(\w+)span>/gi,
                            '$1'
                        );
                        
                        // Fix any remaining broken span tags
                        processed = processed.replace(
                            /<span[^>]*>([^<]*)span>/gi,
                            '$1'
                        );
                        
                        // Additional fix for specific malformed patterns
                        processed = processed.replace(
                            /(\d+\s*\w+)span>/gi,
                            '$1'
                        );
                        
                        // Fix common malformed patterns like "8 gspan>"
                        processed = processed.replace(
                            /(\d+\s*[a-zA-Z]+)span>/gi,
                            '$1'
                        );
                        
                        // Fix any remaining "span>" at the end of words
                        processed = processed.replace(
                            /([a-zA-Z0-9]+)span>/gi,
                            '$1'
                        );
                        
                        // Remove any remaining empty or unnecessary spans
                        processed = processed.replace(
                            /<span[^>]*><\/span>/gi,
                            ''
                        );
                        
                        // Clean up any orphaned closing tags
                        processed = processed.replace(
                            /<\/span>/gi,
                            ''
                        );
                        
                        // Final cleanup: remove any remaining spans with dir="ltr" (multiple passes to be sure)
                        processed = processed.replace(
                            /<span[^>]*dir\s*=\s*["']ltr["'][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Handle edge cases where quotes might be different
                        processed = processed.replace(
                            /<span[^>]*dir\s*=\s*['"]ltr['"][^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // NUCLEAR OPTION: Remove ALL remaining spans completely (no exceptions)
                        // This ensures absolutely NO span tags appear anywhere
                        const beforeNuclear = processed;
                        processed = processed.replace(
                            /<span[^>]*>([^<]*)<\/span>/gi,
                            '$1'
                        );
                        
                        // Debug: log nuclear option results
                        if (beforeNuclear !== processed) {
                            console.log('NUCLEAR: Removed remaining spans:', beforeNuclear, 'â†’', processed);
                        }
                        
                        // Remove any remaining opening span tags
                        processed = processed.replace(
                            /<span[^>]*>/gi,
                            ''
                        );
                        
                        // Remove any remaining closing span tags
                        processed = processed.replace(
                            /<\/span>/gi,
                            ''
                        );
                        
                        // Handle existing math-field tags from JSON
                        // Convert them to proper format with all necessary attributes
                        processed = processed.replace(
                            /<math-field([^>]*)>(.*?)<\/math-field>/gi,
                            (match, attrs, content) => {
                                // Extract value attribute
                                const valueMatch = attrs.match(/value=["']([^"']*)["']/i);
                                let value = valueMatch ? valueMatch[1] : content.trim();
                                
                                // Clean up value - handle escaped characters and special cases
                                value = value.replace(/\\displaystyle\{([^}]+)\}/g, '$1')
                                           .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '\\frac{$1}{$2}')
                                           .replace(/â€‹/g, ''); // Remove zero-width spaces
                                
                                // Extract or set default-mode
                                const modeMatch = attrs.match(/default-mode=["']([^"']*)["']/i);
                                const mode = modeMatch ? modeMatch[1] : 'inline-math';
                                
                                // Check if read-only (from source)
                                const isReadOnly = attrs.includes('read-only');
                                const readOnlyAttr = isReadOnly ? ' read-only' : '';
                                
                                // Create proper math-field with all attributes
                                // IMPORTANT: The content inside math-field should be EMPTY
                                // All math content goes in the value attribute only
                                // Escape the value properly for HTML attribute
                                const escapedValue = value.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                                return `<math-field default-mode="${mode}" value="${escapedValue}"${readOnlyAttr} virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard dir="ltr"></math-field>`;
                            }
                        );
                        
                        return processed;
                    } catch (error) {
                        console.error('Process math field tags error:', error);
                        return htmlString;
                    }
                },
                */ // <--- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¹Ø·ÙŠÙ„

                /**
                 * Convert standalone LaTeX formulas (like \displaystyle{...}, \begin{align}...) to math-field tags
                 */
                convertLatexToMathField(htmlString) {
                    if (!htmlString || typeof htmlString !== 'string') return htmlString;
                    
                    let result = htmlString;
                    let conversionCount = 0;
                    
                    // 1. Convert \displaystyle{...} to math-field
                    result = result.replace(/\\displaystyle\{([^}]+)\}/g, (match, content) => {
                        conversionCount++;
                        const cleaned = content.trim();
                        console.log(`ğŸ“ [LaTeXâ†’MathField] Converting \\displaystyle{${cleaned}}`);
                        return `<math-field value="${cleaned}" read-only default-mode="inline-math" dir="rtl"></math-field>`;
                    });
                    
                    // 2. Convert \begin{align}...\end{align} to math-field
                    result = result.replace(/\\begin\{align\}([\s\S]*?)\\end\{align\}/g, (match, content) => {
                        conversionCount++;
                        const cleaned = content.trim();
                        const fullFormula = `\\begin{align}${cleaned}\\end{align}`;
                        console.log(`ğŸ“ [LaTeXâ†’MathField] Converting \\begin{align}...\\end{align}`);
                        return `<math-field value="${fullFormula}" read-only default-mode="math" dir="rtl"></math-field>`;
                    });
                    
                    // 3. Convert \begin{pmatrix}...\end{pmatrix} to math-field
                    result = result.replace(/\\begin\{pmatrix\}([\s\S]*?)\\end\{pmatrix\}/g, (match, content) => {
                        conversionCount++;
                        const cleaned = content.trim();
                        const fullFormula = `\\begin{pmatrix}${cleaned}\\end{pmatrix}`;
                        console.log(`ğŸ“ [LaTeXâ†’MathField] Converting \\begin{pmatrix}...\\end{pmatrix}`);
                        return `<math-field value="${fullFormula}" read-only default-mode="math" dir="rtl"></math-field>`;
                    });
                    
                    // 4. Convert \left\{...\right\} and similar to math-field
                    result = result.replace(/\\left[\[\(\{]([\s\S]*?)\\right[\]\)\}]/g, (match) => {
                        conversionCount++;
                        const cleaned = match.trim();
                        console.log(`ğŸ“ [LaTeXâ†’MathField] Converting \\left...\\right`);
                        return `<math-field value="${cleaned}" read-only default-mode="inline-math" dir="rtl"></math-field>`;
                    });
                    
                    if (conversionCount > 0) {
                        console.log(`ğŸ“ [LaTeXâ†’MathField] Total conversions: ${conversionCount}`);
                    }
                    
                    return result;
                },
                
                renderContentWithMath(htmlString) {
                    try {
                        if (typeof htmlString !== 'string' || !htmlString) {
                            return '<div class="content-root" dir="rtl">&nbsp;</div>';
                        }
                        // Debug: log problematic content
                        if (htmlString.includes('__LOCK') || htmlString.includes('LexicalTheme')) {
                            console.log('Problematic content detected:', htmlString.substring(0, 200));
                        }

                        // If content is just __LOCK__ placeholders, try to restore original content
                        if (htmlString.trim() === '__LOCK__' || htmlString.trim() === '__LOCK_I_LOCK__') {
                            // Try to find the original content from the original data
                            const fileIndex = parseInt(document.querySelector('.editable-preview-field')?.dataset.fileIndex || '0', 10);
                            const path = document.querySelector('.editable-preview-field')?.dataset.path || '';
                            if (fileIndex >= 0 && path && TranslatorApp.state.originalJsonData[fileIndex]) {
                                const keys = path.split('.');
                                let originalContent = TranslatorApp.state.originalJsonData[fileIndex].data;
                                for (let i = 0; i < keys.length; i++) {
                                    originalContent = originalContent ? originalContent[keys[i]] : '';
                                }
                                if (originalContent && typeof originalContent === 'string') {
                                    htmlString = originalContent;
                                }
                            }
                        }

                        // Handle empty or null content
                        if (!htmlString || htmlString.trim() === '') {
                            return '<div class="content-root" dir="rtl">&nbsp;</div>';
                        }

                        // 1) Keep any pre-existing <math-field> as-is to avoid double-wrapping
                        htmlString = htmlString.replace(/<math-field[\s\S]*?<\/math-field>/gi, (m) => `__MATHFIELD__${btoa(unescape(encodeURIComponent(m)))}__`);
                        const latexRegex = /(\$\$[\s\S]*?\$\$|\$[\s\S]*?\$)/g;
                        const parts = htmlString.split(latexRegex);
                        const content = parts.map(part => {
                            try {
                                if (!part) return '';
                                if (part.startsWith('$$') && part.endsWith('$$')) {
                                    const latex = part.slice(2, -2).replace(/"/g, '&quot;');
                                    return `<math-field default-mode="math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard virtual-keyboard-default-language="ar" locale="ar" dir="rtl"></math-field>`;
                                }
                                if (part.startsWith('$') && part.endsWith('$')) {
                                    const latex = part.slice(1, -1).replace(/"/g, '&quot;');
                                    return `<math-field default-mode="inline-math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard virtual-keyboard-default-language="ar" locale="ar" dir="rtl"></math-field>`;
                                }
                                // Inject editable math-fields for common chemical formulas in plain text
                                let injected = this.injectChemistryMathFields(part);
                                // Decorate blanks ___ to visible slots (preview-only)
                                injected = this.decorateBlanks(injected);
                                const sanitized = TranslatorApp.security.sanitize(injected)
                                    // normalize multiplication sign to match system rendering
                                    .replace(/\bx\b/g, 'Ã—');
                                const hasBlock = /<\s*(table|ul|ol|li|div|p|pre|code|thead|tbody|tr|td|th|img|audio)\b/i.test(sanitized);
                                return hasBlock ? sanitized : `<span>${sanitized}</span>`;
                            } catch (partError) {
                                console.warn('Error processing part:', partError);
                                return part || '';
                            }
                        }).join('');
                        // 2) Restore original math-field fragments
                        let restored = content.replace(/__MATHFIELD__([A-Za-z0-9+/=]+)__/g, (_, b64) => {
                            try { return decodeURIComponent(escape(atob(b64))); } catch { return ''; }
                        });
                        
                        // 2.5) âœ¨ NEW: Add dir="rtl", locale="ar", and lang="ar" to restored math-field tags
                        // This ensures math-fields from JSON also have RTL and Arabic locale in preview
                        
                        // Add dir="rtl" if not present
                        restored = restored.replace(/<math-field(?!\s+[^>]*\bdir=["']rtl["'])([^>]*)>/gi, '<math-field dir="rtl"$1>');
                        
                        // Change locale="en" to locale="ar" OR add if not present
                        restored = restored.replace(/<math-field([^>]*)\blocale=["']en["']([^>]*)>/gi, '<math-field$1locale="ar"$2>');
                        restored = restored.replace(/<math-field(?!\s+[^>]*\blocale=)([^>]*)>/gi, '<math-field locale="ar"$1>');
                        
                        // Change lang="en" to lang="ar" OR add if not present
                        restored = restored.replace(/<math-field([^>]*)\blang=["']en["']([^>]*)>/gi, '<math-field$1lang="ar"$2>');
                        restored = restored.replace(/<math-field(?!\s+[^>]*\blang=)([^>]*)>/gi, '<math-field lang="ar"$1>');

                        // 3) Apply smart text direction processing
                        let enhancedContent = TranslatorApp.utils.textDirection.enhancePreviewContent(restored);
                        
                        // 3.5) âœ¨ NEW: Add dir="rtl" to all <p> tags in preview
                        enhancedContent = enhancedContent.replace(/<p(?!\s+[^>]*\bdir=["']rtl["'])([^>]*)>/gi, '<p dir="rtl"$1>');

                        // 4) Determine the main direction for the container
                        const textContent = restored.replace(/<[^>]*>/g, ' ').trim();
                        const containerDirection = TranslatorApp.utils.textDirection.getDominantDirection(textContent);
                        const isMixed = TranslatorApp.utils.textDirection.isMixed(textContent);

                        // 5) Set appropriate attributes for the container
                        const dirAttr = isMixed ? 'auto' : containerDirection;
                        const bidiClass = isMixed ? 'mixed-content' : (containerDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');

                        return `<div class="content-root ${bidiClass}" dir="${dirAttr}">${enhancedContent}</div>`;
                    } catch (error) {
                        console.error('Render content with math error:', error);
                        return '<div class="content-root" dir="rtl">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰</div>';
                    }
                },
                    
                handleCopyEvent(e) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) return;
                
                    const range = selection.getRangeAt(0);
                    const clonedContent = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(clonedContent);
                
                    const mathFields = tempDiv.querySelectorAll('math-field');
                    mathFields.forEach(mf => {
                        const mode = mf.getAttribute('default-mode');
                        const value = mf.value;
                        const delimiter = (mode === 'math') ? '$$' : '$';
                        const latexString = `${delimiter}${value}${delimiter}`;
                        
                        const textNode = document.createTextNode(latexString);
                        mf.parentNode.replaceChild(textNode, mf);
                    });
                    const html = tempDiv.innerHTML;
                    const text = tempDiv.textContent || '';
                    
                    e.clipboardData.setData('text/html', html);
                    e.clipboardData.setData('text/plain', text);
                    e.preventDefault();
                    
                },

                handlePasteEvent(e) {
                    try {
                        e.preventDefault();
                        const pasteHtml = e.clipboardData.getData('text/html');
                        const pasteText = e.clipboardData.getData('text/plain');
                        let contentToInsert = '';
                        if (pasteHtml) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = pasteHtml;
                            contentToInsert = tempDiv.innerHTML;
                        } else {
                            contentToInsert = pasteText;
                        }
                        if (!contentToInsert) return;

                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        const processorDiv = document.createElement('div');
                        processorDiv.innerHTML = contentToInsert;
                        const walker = document.createTreeWalker(
                            processorDiv,
                            NodeFilter.SHOW_TEXT,
                            null,
                            false
                        );
                        let node;
                        const nodesToReplace = [];
                        
                        while ((node = walker.nextNode())) {
                            const textContent = node.textContent;
                            const latexRegex = /(\$\$[\s\S]*?\$\$|\$[^$]*\$)/g;
                            const parts = textContent.split(latexRegex);
                            
                            if (parts.length > 1) {
                                const fragment = document.createDocumentFragment();
                                parts.forEach(part => {
                                    if (part.startsWith('$$') && part.endsWith('$$')) {
                                        const latex = part.slice(2, -2);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'rtl');
                                        mf.setAttribute('locale', 'ar');
                                        fragment.appendChild(mf);
                                    } else if (part.startsWith('$') && part.endsWith('$')) {
                                        const latex = part.slice(1, -1);
                                        const mf = document.createElement('math-field');
                                        mf.setAttribute('default-mode', 'inline-math');
                                        mf.setAttribute('value', latex);
                                        mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                        mf.setAttribute('use-shared-virtual-keyboard', '');
                                        mf.setAttribute('dir', 'rtl');
                                        mf.setAttribute('locale', 'ar');
                                        fragment.appendChild(mf);
                                    } else if (part) {
                                        fragment.appendChild(document.createTextNode(part));
                                    }
                                });
                                nodesToReplace.push({ oldNode: node, newNode: fragment });
                            }
                        }
                        nodesToReplace.forEach(({ oldNode, newNode }) => {
                            oldNode.parentNode.replaceChild(newNode, oldNode);
                        });
                        const finalFragment = document.createDocumentFragment();
                        while (processorDiv.firstChild) {
                            finalFragment.appendChild(processorDiv.firstChild);
                        }
                        range.insertNode(finalFragment);
                        selection.collapseToEnd();
                        
                        const fieldContainer = e.target.closest('.editable-preview-field');
                        if (fieldContainer) {
                            this.handlePreviewFieldUpdate(fieldContainer);
                        }
                    } catch (error) {
                        console.error('Paste event error:', error);
                        TranslatorApp.ui.showAlert('Paste failed. Plain text copied instead.', 'error');
                        document.execCommand('insertText', false, e.clipboardData.getData('text/plain'));
                    }
                    
                },      

                // Convert plain chemical formulas (e.g., NaHCO3, H2SO4, Ca(OH)2) into inline math-fields
                injectChemistryMathFields(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        const escapeAttr = (s) => (s || '').replace(/"/g, '&quot;');
                        // Basic LaTeX conversion: element digits -> _{digits}, parenthesis digits -> _{digits}
                        const toLatex = (formula) => {
                            try {
                                let out = formula;
                                out = out.replace(/([A-Za-z][a-z]?)\s*(\d+)/g, '$1_{$2}');
                                out = out.replace(/\)(\d+)/g, ')_{$1}');
                                return out;
                            } catch (error) {
                                console.warn('LaTeX conversion error:', error);
                                return formula;
                            }
                        };
                        // Regex for typical chemical formula tokens
                        const chemRegex = /\b(?:[A-Z][a-z]?\d*)+(?:\([A-Za-z\d]+\)\d*)*\b/g;
                        return text.replace(chemRegex, (match) => {
                            try {
                                // Avoid converting if already inside an HTML tag like <span> or attributes
                                // Heuristic: skip if match is immediately preceded by '&' (entity) or within a tag
                                // Since we sanitize later and we run on plain text chunks, this is usually safe
                                const latex = escapeAttr(toLatex(match));
                                return `<math-field default-mode="inline-math" value="${latex}" virtual-keyboard-mode="onfocus" use-shared-virtual-keyboard virtual-keyboard-default-language="ar" locale="ar" dir="rtl"></math-field>`;
                            } catch (error) {
                                console.warn('Chemistry field injection error:', error);
                                return match;
                            }
                        });
                    } catch (error) {
                        console.error('Inject chemistry math fields error:', error);
                        return text;
                    }
                },

                decorateBlanks(text) {
                    try {
                        if (!text || typeof text !== 'string') return text;
                        // Replace sequences of 3+ underscores with a visual blank slot
                        // Also handle other common blank patterns like [___], (___), etc.
                        let decorated = text;

                        // Detect text direction for appropriate blank styling
                        const textDirection = TranslatorApp.utils.textDirection.getDominantDirection(text);
                        const isMixed = TranslatorApp.utils.textDirection.isMixed(text);
                        const directionClass = isMixed ? 'mixed-content' : (textDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');

                        // Handle underscores: ___, ____, _____ etc. (preserve surrounding spaces)
                        decorated = decorated.replace(/(\s*)_{3,}(\s*)/g, (m, spaceBefore, spaceAfter) => {
                            const underscores = m.trim();
                            return `${spaceBefore}<span class="blank-slot ${directionClass}" data-blank="${underscores}" dir="${isMixed ? 'auto' : textDirection}"></span>${spaceAfter}`;
                        });

                        // Handle brackets with underscores: [___], (___), {___}
                        decorated = decorated.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                            const underscores = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${underscores}" dir="${isMixed ? 'auto' : textDirection}">${underscores}</span>${close}`;
                        });

                        // Handle simple brackets with spaces: [   ], (   ), {   }
                        decorated = decorated.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                            const spaces = m.slice(1, -1);
                            return `${open}<span class="blank-slot ${directionClass}" data-blank="${spaces}" dir="${isMixed ? 'auto' : textDirection}">${spaces}</span>${close}`;
                        });

                        // Handle other common blank patterns
                        // Handle question marks: ???, ???? etc.
                        decorated = decorated.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'?'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dashes: ---, ---- etc.
                        decorated = decorated.replace(/-{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'-'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle dots: ..., .... etc.
                        decorated = decorated.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${directionClass}" data-blank="${'.'.repeat(m.length)}" dir="${isMixed ? 'auto' : textDirection}">${m}</span>`);

                        // Handle HTML content with blanks (preserve HTML structure)
                        if (decorated.includes('<') && decorated.includes('>')) {
                            // Create a temporary DOM element to process HTML content
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = decorated;

                            // Process text nodes within HTML
                            const walker = document.createTreeWalker(
                                tempDiv,
                                NodeFilter.SHOW_TEXT,
                                null,
                                false
                            );

                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                textNodes.push(node);
                            }

                            // Process each text node
                            textNodes.forEach(textNode => {
                                const originalText = textNode.textContent;
                                let processedText = originalText;

                                // Detect direction for this specific text node
                                const nodeDirection = TranslatorApp.utils.textDirection.getDominantDirection(originalText);
                                const nodeIsMixed = TranslatorApp.utils.textDirection.isMixed(originalText);
                                const nodeDirectionClass = nodeIsMixed ? 'mixed-content' : (nodeDirection === 'rtl' ? 'rtl-auto' : 'ltr-auto');
                                const nodeDir = nodeIsMixed ? 'auto' : nodeDirection;

                                // Apply blank decoration to text content with proper direction (preserve spaces)
                                processedText = processedText.replace(/(\s*)_{3,}(\s*)/g, (m, spaceBefore, spaceAfter) => {
                                    const underscores = m.trim();
                                    return `${spaceBefore}<span class="blank-slot ${nodeDirectionClass}" data-blank="${underscores}" dir="${nodeDir}"></span>${spaceAfter}`;
                                });
                                processedText = processedText.replace(/([\[\(\{])_{3,}([\]\)\}])/g, (m, open, close) => {
                                    const underscores = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${underscores}" dir="${nodeDir}">${underscores}</span>${close}`;
                                });
                                processedText = processedText.replace(/([\[\(\{])\s{3,}([\]\)\}])/g, (m, open, close) => {
                                    const spaces = m.slice(1, -1);
                                    return `${open}<span class="blank-slot ${nodeDirectionClass}" data-blank="${spaces}" dir="${nodeDir}">${spaces}</span>${close}`;
                                });
                                processedText = processedText.replace(/\?{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'?'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/-{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'-'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);
                                processedText = processedText.replace(/\.{3,}/g, (m) => `<span class="blank-slot ${nodeDirectionClass}" data-blank="${'.'.repeat(m.length)}" dir="${nodeDir}">${m}</span>`);

                                if (processedText !== originalText) {
                                    const wrapper = document.createElement('span');
                                    wrapper.innerHTML = processedText;
                                    // Apply direction to the wrapper as well
                                    TranslatorApp.utils.textDirection.applySmartDirection(wrapper, originalText);
                                    textNode.parentNode.replaceChild(wrapper, textNode);
                                }
                            });

                            decorated = tempDiv.innerHTML;
                        }

                        return decorated;
                    } catch (error) {
                        console.error('Decorate blanks error:', error);
                        return text;
                    }
                },

                handleUnitUpdate(fieldContainer, newUnitValue) {
                    try {
                        if (!fieldContainer) return;
                
                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data for unit update:', { path, fileIndex });
                            return;
                        }
                
                        const pathParts = path.split('.');
                        const parentPath = pathParts.slice(0, pathParts.length - 1);
                        let targetObject = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        for (const key of parentPath) {
                            targetObject = targetObject[key];
                        }
                
                        if (targetObject && typeof targetObject === 'object' && targetObject.hasOwnProperty('unit')) {
                            targetObject.unit = newUnitValue;
                        }
                        
                        this.updateDiff(fileIndex, path, newUnitValue);
                
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠØ§Ù‹';
                        }
                        
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Handle unit update error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« ÙˆØ­Ø¯Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©.', 'error');
                    }
                },
                // New helper function to get data by path
                getDataByPath(obj, path) {
                    return path.split('.').reduce((o, i) => (o ? o[i] : undefined), obj);
                },

                handlePreviewFieldUpdate(fieldContainer) {
                    try {
                        if (!fieldContainer) return;

                        const path = fieldContainer.dataset.path;
                        const fileIndex = parseInt(fieldContainer.dataset.fileIndex, 10);
                
                        if (!path || isNaN(fileIndex)) {
                            console.warn('Invalid field container data:', { path, fileIndex });
                            return;
                        }
                        let newContent = '';
                        const root = fieldContainer.querySelector('.content-root');
                        if (root) {
                            root.childNodes.forEach(node => {
                                if (node.nodeType === Node.TEXT_NODE) {
                                    newContent += node.textContent;
                                } else if (node.nodeType === Node.ELEMENT_NODE) {
                                    if (node.tagName === 'MATH-FIELD') {
                                        const value = node.value || ''; // Ø§Ù‚Ø±Ø£ Ø§Ù„Ù€ value Ø¯Ø§Ø¦Ù…Ù‹Ø§
                                        const delimiter = node.getAttribute('default-mode') === 'math' ? '$$' : '$';
                                        if (value.trim()) { // Ø£Ø¶Ù ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† ÙØ§Ø±ØºØ©
                                            // Ù†Ø¸Ù Ø§Ù„Ù‚ÙŠÙ…Ø© Ù…Ù† HTML Entities Ø´Ø§Ø¦Ø¹Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¶Ø§ÙØ©
                                            const cleanedValue = value.replace(/&amp;/g, '&')
                                                                    .replace(/&lt;/g, '<')
                                                                    .replace(/&gt;/g, '>')
                                                                    .replace(/&quot;/g, '"');
                                            newContent += `${delimiter}${cleanedValue}${delimiter}`;
                                        }
                                    } else if (node.classList && node.classList.contains('blank-slot')) {
                                        // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø´Ø±Ø·Ø© Ø§Ù„Ø³ÙÙ„ÙŠØ© Ù…Ù† blank slots
                                        newContent += '___'; // Ø£Ùˆ Ø§Ø³ØªØ±Ø¬Ø¹Ù‡Ø§ Ù…Ù† data-blank Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ù‡Ù…Ù‹Ø§
                                    } else {
                                        // Ù„Ø£ÙŠ Ø¹Ù†ØµØ± Ø¢Ø®Ø±ØŒ Ø®Ø° Ø§Ù„Ù€ HTML Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ (Ù…Ø«Ù„ <img>, <b>, etc.)
                                        newContent += node.outerHTML || '';
                                    }
                                }
                            });
                        }
                        
                        // Remove the visual blank slots from the final HTML before saving
                        // Handle both empty blank slots and those with content
                        newContent = newContent.replace(/<span class="blank-slot"[^>]*>(.*?)<\/span>/g, (match, content) => {
                            // If content is empty or just spaces, use ___
                            if (!content || content.trim() === '') {
                                return '___';
                            }
                            // If content has actual text, preserve it but convert to underscores
                            return content.replace(/\S/g, '_').replace(/_+/g, '___');
                        });
                        this.updateData(fileIndex, path, newContent);
                        this.updateDiff(fileIndex, path);
                        const statusEl = document.getElementById(`status-field-${fileIndex}-${path.replace(/\./g, '-')}`);
                        if (statusEl) {
                            statusEl.className = 'status-dot status-edited';
                            statusEl.title = 'ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠØ¯ÙˆÙŠØ§Ù‹';
                        }

                        // Push to history after update is complete
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                        
                        // Update quality indicators and word count for this field
                        const fieldId = fieldContainer.id;
                        setTimeout(() => {
                            this.updateQualityIndicators(fieldId, fileIndex, path);
                            this.updateWordCount(fieldId);
                            this.updateStats();
                            this.checkAndAlert(fieldId, fileIndex, path);
                        }, 100);

                    } catch (error) {
                        console.error('Handle preview field update error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©.', 'error');
                    }
                },

                render() {
                    try {
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '';
                        
                        // Get the mapped IDs from the input field once before the loop
                        let mappedIdsArray = [];
                        try {
                            if (TranslatorApp.dom.useMappedIdsCheckbox.checked && TranslatorApp.dom.mappedIdsInput.value.trim()) {
                                mappedIdsArray = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            }
                        } catch (e) {
                            console.error('Error parsing mapped IDs from input:', e);
                            TranslatorApp.ui.showAlert('Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (mapped_id) ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡Ø§ Ù…ØµÙÙˆÙØ© JSON ØµØ­ÙŠØ­Ø©.', 'error');
                        }
                
                        TranslatorApp.state.translatedJsonData.forEach((file, fileIndex) => {
                            try {
                                const fileAccordion = document.createElement('div');
                                fileAccordion.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                                // --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                                // Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª meta Ù„Ù„ÙÙ„ØªØ±Ø©
                                const partTypes = (file.data.parts || []).map(p => p.type).join(' ');
                                fileAccordion.setAttribute('data-file-name', file.name.toLowerCase());
                                fileAccordion.setAttribute('data-part-types', partTypes);
                                // --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                
                                const header = document.createElement('button');
                                header.className = 'accordion-header';
                                
                                const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id || file.name.replace('.json', '');
                                const currentMappedId = mappedIdsArray[fileIndex] || null;
                                const sourceId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.metadata?.source_id?.value || 
                                                TranslatorApp.state.originalJsonData[fileIndex]?.data?.source_id?.value || null;
                
                                header.innerHTML = `
                                    <div style="width: 100%;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Original ID:</span> 
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px; color: var(--primary-color); font-weight: 600;">${originalId}</span>
                                            </div>
                                            ${sourceId ? `
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Source ID:</span>
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px; color: var(--success-color); font-weight: 600;">${sourceId}</span>
                                            </div>
                                            ` : ''}
                                            ${currentMappedId ? `
                                            <div style="display: flex; align-items: center;">
                                                <span style="font-weight: normal; font-size: 0.9em; color: var(--secondary-text);">Translation ID:</span> 
                                                <span dir="ltr" style="font-family: monospace; margin-left: 8px;">${currentMappedId}</span>
                                            </div>
                                            ` : ''}
                                        </div>
                                        <div style="display: flex; gap: 20px; margin-top: 8px; font-size: 0.8em; color: var(--secondary-text);">
                                            <span><strong>Original ID:</strong> ${originalId}</span>
                                            ${sourceId ? `<span><strong>Source:</strong> ${sourceId}</span>` : ''}
                                            ${currentMappedId ? `<span><strong>Translation ID:</strong> ${currentMappedId}</span>` : ''}
                                        </div>
                                        <div class="file-progress-bar">
                                            <div class="file-progress-fill" id="file-progress-fill-${fileIndex}" style="width: 0%"></div>
                                        </div>
                                        <div class="text-xs text-center mt-1" style="color: var(--secondary-text);">
                                            <span id="file-progress-text-${fileIndex}">0 Ù…Ù† 0 Ø­Ù‚ÙˆÙ„</span>
                                        </div>
                                    </div>
                                `;
                
                                header.onclick = (e) => {
                                    const content = e.currentTarget.nextElementSibling;
                                    const accordionParent = e.currentTarget.closest('.preview-card');
                                    const isOpen = content.style.maxHeight && content.style.maxHeight !== '0px';
                                    
                                    if (isOpen) {
                                        content.style.maxHeight = null;
                                        accordionParent.style.boxShadow = null;
                                        accordionParent.style.transform = null;
                                        accordionParent.classList.remove('open');
                                    } else {
                                        content.style.maxHeight = content.scrollHeight + "px";
                                        accordionParent.style.boxShadow = '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)';
                                        accordionParent.style.transform = 'scale(1.01)';
                                        accordionParent.classList.add('open');
                                    }
                                };
                                
                                const content = document.createElement('div');
                                content.className = 'accordion-content';
                                content.innerHTML = this.renderFileContent(file.data, fileIndex, currentMappedId);
                
                                fileAccordion.appendChild(header);
                                fileAccordion.appendChild(content);
                                previewContainer.appendChild(fileAccordion);
                
                                this.generateInitialDiffs(fileIndex);
                            } catch (fileError) {
                                console.warn('Error rendering file:', fileError);
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'preview-card rounded-2xl shadow-lg overflow-hidden';
                                errorDiv.innerHTML = `<div class="p-4" style="color: var(--error-color);">Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ù: ${file.name}</div>`;
                                previewContainer.appendChild(errorDiv);
                            }
                        });
                        this.prepareInteractiveMathFields();
                        
                        // --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Ø¥Ø²Ø§Ù„Ø© Timeouts) ---
                        // Update stats and quality indicators after render
                            this.updateStats();
                            this.updateAllQualityIndicators();
                            this.updateAllWordCounts();
                            this.loadNotes();
                            
                        // CRITICAL FIX: Force MathLive re-initialization
                        // ÙŠØªÙ… Ø§Ù„Ø¢Ù† Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù‡Ø°Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© MutationObserverØŒ ÙˆÙ„ÙƒÙ† Ø§Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙŠØ¯ÙˆÙŠ ÙŠØ¶Ù…Ù† Ø§Ù„ØªØºØ·ÙŠØ©
                                this.prepareInteractiveMathFields();
                                
                        // (ØªÙ… Ø­Ø°Ù ÙƒØªÙ„ setTimeout Ø§Ù„Ù…ØªØ¯Ø§Ø®Ù„Ø©)
                        // --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ---
                    } catch (error) {
                        console.error('Preview render error:', error);
                        const { previewContainer } = TranslatorApp.dom;
                        previewContainer.innerHTML = '<div class="p-4" style="color: var(--error-color);">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©</div>';
                    }
                },
                
                updateStats() {
                    try {
                        let total = 0, completed = 0, edited = 0, warnings = 0;
                        
                        document.querySelectorAll('.status-dot').forEach(dot => {
                            total++;
                            if (dot.classList.contains('status-translated')) completed++;
                            if (dot.classList.contains('status-edited')) edited++;
                        });
                        
                        document.querySelectorAll('.field-error, .field-warning').forEach(() => warnings++);
                        
                        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
                        
                        if (TranslatorApp.dom.totalFieldsCount) TranslatorApp.dom.totalFieldsCount.textContent = total;
                        if (TranslatorApp.dom.completedFieldsCount) TranslatorApp.dom.completedFieldsCount.textContent = completed;
                        if (TranslatorApp.dom.editedFieldsCount) TranslatorApp.dom.editedFieldsCount.textContent = edited;
                        if (TranslatorApp.dom.warningsCount) TranslatorApp.dom.warningsCount.textContent = warnings;
                        if (TranslatorApp.dom.progressPercentage) TranslatorApp.dom.progressPercentage.textContent = `${percentage}%`;
                    } catch (error) {
                        console.error('Update stats error:', error);
                    }
                },
                
                updateAllQualityIndicators() {
                    try {
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                const fileIndex = parseInt(field.dataset.fileIndex);
                                const path = field.dataset.path;
                                this.updateQualityIndicators(fieldId, fileIndex, path);
                            }
                        });
                    } catch (error) {
                        console.error('Update all quality indicators error:', error);
                    }
                },
                
                updateQualityIndicators(fieldId, fileIndex, path) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const translatedText = field.textContent || '';
                        const originalText = this.getOriginalTextByPath(fileIndex, path);
                        
                        // Check numbers
                        const numbersCheck = document.getElementById(`numbers-check-${fieldId}`);
                        if (numbersCheck) {
                            const hasNumbers = TranslatorApp.quality.qa.checkNumbers(originalText, translatedText);
                            numbersCheck.classList.toggle('valid', hasNumbers.length === 0);
                            numbersCheck.classList.toggle('invalid', hasNumbers.length > 0);
                        }
                        
                        // Check HTML balance
                        const htmlCheck = document.getElementById(`html-check-${fieldId}`);
                        if (htmlCheck) {
                            const htmlErrors = TranslatorApp.quality.qa.checkHtmlBalance(translatedText);
                            htmlCheck.classList.toggle('valid', htmlErrors.length === 0);
                            htmlCheck.classList.toggle('invalid', htmlErrors.length > 0);
                        }
                        
                        // Check LaTeX
                        const latexCheck = document.getElementById(`latex-check-${fieldId}`);
                        if (latexCheck) {
                            const hasLatex = translatedText.includes('$') || translatedText.includes('\\');
                            const isValid = !translatedText.includes('\\alt{') && !translatedText.includes('\\prime');
                            latexCheck.classList.toggle('valid', !hasLatex || isValid);
                            latexCheck.classList.toggle('invalid', hasLatex && !isValid);
                        }
                        
                        // Check blanks
                        const blanksCheck = document.getElementById(`blanks-check-${fieldId}`);
                        if (blanksCheck) {
                            const originalBlanks = (originalText.match(/_{3,}/g) || []).length;
                            const translatedBlanks = (translatedText.match(/_{3,}/g) || []).length + 
                                                     (field.querySelectorAll('.blank-slot').length || 0);
                            blanksCheck.classList.toggle('valid', originalBlanks === translatedBlanks);
                            blanksCheck.classList.toggle('invalid', originalBlanks !== translatedBlanks);
                        }
                    } catch (error) {
                        console.error('Update quality indicators error:', error);
                    }
                },
                
                updateAllWordCounts() {
                    try {
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                this.updateWordCount(fieldId);
                            }
                        });
                    } catch (error) {
                        console.error('Update all word counts error:', error);
                    }
                },
                
                updateWordCount(fieldId) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const text = field.textContent || '';
                        const words = text.trim().split(/\s+/).filter(Boolean).length;
                        const chars = text.length;
                        
                        const wordCountEl = document.getElementById(`wordCount-${fieldId}`);
                        const charCountEl = document.getElementById(`charCount-${fieldId}`);
                        
                        if (wordCountEl) wordCountEl.textContent = words;
                        if (charCountEl) charCountEl.textContent = chars;
                    } catch (error) {
                        console.error('Update word count error:', error);
                    }
                },
                
                getOriginalTextByPath(fileIndex, path) {
                    try {
                        let data = TranslatorApp.state.originalJsonData[fileIndex]?.data;
                        const keys = path.split('.');
                        for (let key of keys) {
                            data = data?.[key];
                        }
                        return data || '';
                    } catch (error) {
                        return '';
                    }
                },
                
                validateAllFields() {
                    try {
                        let totalWarnings = 0;
                        document.querySelectorAll('[id^="field-"]').forEach(field => {
                            if (field.contentEditable === 'true') {
                                const fieldId = field.id;
                                const fileIndex = parseInt(field.dataset.fileIndex);
                                const path = field.dataset.path;
                                
                                this.updateQualityIndicators(fieldId, fileIndex, path);
                                this.updateWordCount(fieldId);
                                
                                const warnings = field.closest('.border').querySelectorAll('.quality-badge.invalid').length;
                                if (warnings > 0) {
                                    field.closest('.border').classList.add('field-warning');
                                    totalWarnings++;
                                }
                            }
                        });
                        
                        this.updateStats();
                        TranslatorApp.ui.showAlert(`Ø§Ù„ØªØ­Ù‚Ù‚ Ù…ÙƒØªÙ…Ù„ - ${totalWarnings} ØªØ­Ø°ÙŠØ±`, totalWarnings > 0 ? 'warning' : 'success');
                    } catch (error) {
                        console.error('Validate all fields error:', error);
                    }
                },
                
                checkAndAlert(fieldId, fileIndex, path) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (!field) return;
                        
                        const translatedText = field.textContent || '';
                        const originalText = this.getOriginalTextByPath(fileIndex, path);
                        
                        const alerts = [];
                        
                        // Check if field is empty
                        if (!translatedText.trim()) {
                            alerts.push('âš ï¸ Ø§Ù„Ø­Ù‚Ù„ ÙØ§Ø±Øº');
                        }
                        
                        // Check numbers mismatch
                        const numbersCheck = TranslatorApp.quality.qa.checkNumbers(originalText, translatedText);
                        if (numbersCheck.length > 0) {
                            alerts.push('ğŸ”¢ Ø§Ø®ØªÙ„Ø§Ù ÙÙŠ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…');
                        }
                        
                        // Check missing blanks
                        const originalBlanks = (originalText.match(/_{3,}/g) || []).length;
                        const translatedBlanks = (translatedText.match(/_{3,}/g) || []).length + 
                                                 (field.querySelectorAll('.blank-slot').length || 0);
                        if (originalBlanks !== translatedBlanks) {
                            alerts.push(`__ ÙØ±Ø§ØºØ§Øª Ù†Ø§Ù‚ØµØ© (${translatedBlanks}/${originalBlanks})`);
                        }
                        
                        // Check HTML balance
                        const htmlErrors = TranslatorApp.quality.qa.checkHtmlBalance(translatedText);
                        if (htmlErrors.length > 0) {
                            alerts.push('ğŸ·ï¸ HTML ØºÙŠØ± Ù…ØªÙˆØ§Ø²Ù†');
                        }
                        
                        // Check LaTeX errors
                        if (translatedText.includes('\\alt{') || translatedText.includes('\\prime')) {
                            alerts.push('ğŸ“ LaTeX Ø®Ø§Ø·Ø¦ (Ù†Øµ Ø¹Ø±Ø¨ÙŠ)');
                        }
                        
                        // Apply visual indicators
                        const fieldWrapper = field.closest('.border');
                        if (alerts.length > 0) {
                            fieldWrapper?.classList.add('field-error');
                            // Show subtle notification
                            console.warn(`Field ${fieldId}:`, alerts.join(', '));
                        } else {
                            fieldWrapper?.classList.remove('field-error', 'field-warning');
                            fieldWrapper?.classList.add('field-success');
                        }
                        
                    } catch (error) {
                        console.error('Check and alert error:', error);
                    }
                },
                renderReadOnlyField(label, originalValue, translatedValue) {
                    try {
                        if (originalValue === undefined || originalValue === null) return '';
                        const displayOriginalValue = Array.isArray(originalValue) ? originalValue.join(', ') : String(originalValue);
                        const displayTranslatedValue = Array.isArray(translatedValue) ? translatedValue.join(', ') : String(translatedValue);
                        
                        // This is a new check for numeric values to determine direction, but it's not applied correctly.
                        // const isNumeric = !isNaN(parseFloat(displayOriginalValue)) && isFinite(displayOriginalValue);
                        // const dirAttr = isNumeric ? 'ltr' : 'rtl'; 
                        
                        // Let's assume the original values are always English and force LTR for them.
                        const originalDir = 'ltr'; 
                
                        // CRITICAL FIX: Use renderContentWithMath for both original and translated content
                        // This ensures math-field tags and LaTeX are properly rendered
                        const renderedOriginal = TranslatorApp.preview.renderContentWithMath(displayOriginalValue);
                        const renderedTranslated = TranslatorApp.preview.renderContentWithMath(displayTranslatedValue);
                
                        return `
                            <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="${originalDir}" style="background-color: var(--bg-color); color: var(--secondary-text);">${renderedOriginal}</div>
                                    </div>
                                    <div>
                                        <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                        <div class="p-3 rounded-lg text-sm h-full" dir="rtl" style="background-color: var(--bg-color); color: var(--secondary-text);">${renderedTranslated}</div>
                                    </div>
                                </div>
                            </div>`;
                    } catch (error) {
                        console.error('Render read only field error:', error);
                        return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <h5 class="font-bold flex items-center mb-2">Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶</h5>
                            <div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰</div>
                        </div>`;
                    }
                },
                renderInputField(label, originalValue, translatedValue, originalUnit, translatedUnit, path, fileIndex) {
                    if (originalValue === undefined || originalValue === null) return '';
                
                    const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                    const statusId = `status-${fieldId}`;
                
                    // CRITICAL FIX: Enhanced unit translation with more comprehensive mapping
                    const unitsMap = {
                        ...TranslatorApp.quality.unitsMap,
                        'km': 'ÙƒÙ…', 'kilometer': 'ÙƒÙ…', 'kilometers': 'ÙƒÙ…',
                        'm': 'Ù…', 'meter': 'Ù…', 'meters': 'Ù…',
                        'cm': 'Ø³Ù…', 'centimeter': 'Ø³Ù…', 'centimeters': 'Ø³Ù…',
                        'mm': 'Ù…Ù…', 'millimeter': 'Ù…Ù…', 'millimeters': 'Ù…Ù…',
                        'kg': 'ÙƒØ¬Ù…', 'kilogram': 'ÙƒØ¬Ù…', 'kilograms': 'ÙƒØ¬Ù…',
                        'g': 'Ø¬Ù…', 'gram': 'Ø¬Ù…', 'grams': 'Ø¬Ù…',
                        'l': 'Ù„', 'liter': 'Ù„', 'liters': 'Ù„',
                        'ml': 'Ù…Ù„', 'milliliter': 'Ù…Ù„', 'milliliters': 'Ù…Ù„',
                        's': 'Ø«', 'second': 'Ø«', 'seconds': 'Ø«',
                        'min': 'Ø¯', 'minute': 'Ø¯', 'minutes': 'Ø¯',
                        'h': 'Ø³', 'hour': 'Ø³', 'hours': 'Ø³'
                    };
                    
                    const translatedUnitText = unitsMap[originalUnit.toLowerCase()] || originalUnit;
                
                    return `
                        <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                            <div class="flex justify-between items-center mb-2">
                                <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø©"></span></h5>
                                <div class="flex gap-2">
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">Ù†Ø³Ø® Ø§Ù„Ø£ØµÙ„ÙŠ</button>
                                    <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('diff-field-${fileIndex}-${path.replace(/\./g, '-')}').parentNode.classList.toggle('hidden')">Ø¹Ø±Ø¶/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</button>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                    <div class="original-text-readonly p-3 rounded-lg text-sm h-full flex items-center justify-end" dir="rtl" style="background-color: var(--bg-color); color: var(--secondary-text); overflow:auto;">
                                        <span style="font-family: monospace;">${TranslatorApp.security.sanitize(originalValue)}</span>
                                        <span class="mr-2">${TranslatorApp.security.sanitize(originalUnit)}</span>
                                    </div>
                                </div>
                                <div>
                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                    <div id="${fieldId}" 
                                        class="editable-preview-field flex items-center justify-end"
                                        data-path="${path}"
                                        data-file-index="${fileIndex}"
                                        dir="rtl">
                                        <span contenteditable="true" **dir="rtl"** class="flex-grow text-right">${TranslatorApp.security.sanitize(translatedValue)}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span contenteditable="true" dir="rtl" class="flex-shrink-0 mr-2 editable-unit">${TranslatorApp.security.sanitize(translatedUnitText)}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-4 hidden">
                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª (Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù…Ù‚Ø§Ø¨Ù„ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©)</p>
                                <div id="diff-field-${fileIndex}-${path.replace(/\./g, '-')}" class="diff-view"></div>
                            </div>
                        </div>
                    `;
                },
                        
                renderReadOnlyLTRField(label, value) {
                    if (value === undefined || value === null) return '';
                    const displayValue = Array.isArray(value) ? value.join(', ') : String(value);
                
                    return `
                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                        <h5 class="font-bold flex items-center mb-2">${TranslatorApp.security.sanitize(label)}</h5>
                        <div>
                            <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                            <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(displayValue)}</div>
                        </div>
                    </div>`;
                },

                renderFileContent(data, fileIndex, mappedId) {
                    try {
                        let html = '<div class="space-y-6">';
                
                        const originalId = TranslatorApp.state.originalJsonData[fileIndex]?.data?.id;
                
                        // Display both original and mapped IDs with labels
                        if (originalId) {
                            html += `<div class="p-4 bg-gray-100 rounded-lg shadow-inner mb-4 flex items-center justify-between">
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">original_id:</span> <span dir="ltr" style="font-family: monospace;">${originalId}</span>
                                </div>`;
                            
                            // Show mapped_id if it exists
                            if (mappedId) {
                                html += `
                                <div class="flex items-center text-sm font-semibold" style="color: var(--text-color);">
                                    <span class="ml-2">mapped_id:</span> <span dir="ltr" style="font-family: monospace;">${mappedId}</span>
                                </div>`;
                            }
                            html += `</div>`;
                        }
                
                        const renderField = (label, originalValue, translatedValue, path, editableDir = 'rtl') => {
                            try {
                                if (originalValue === undefined || originalValue === null || (Array.isArray(originalValue) && originalValue.length === 0)) {
                                    return '';
                                }
                                const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                                const diffId = `diff-${fieldId}`;
                                const statusId = `status-${fieldId}`;
                                
                                const displayOriginalValue = (Array.isArray(originalValue) ? originalValue.join('') : String(originalValue));
                                const displayTranslatedValue = (Array.isArray(translatedValue) ? translatedValue.join('') : String(translatedValue));
                                
                                const finalTranslatedValue = displayTranslatedValue || displayOriginalValue;
                                
                                return `
                                    <div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                        <div class="flex justify-between items-center mb-2">
                                            <h5 class="font-bold flex items-center">${TranslatorApp.security.sanitize(label)} <span id="${statusId}" class="status-dot status-translated" title="ØªÙ…Øª Ø§Ù„ØªØ±Ø¬Ù…Ø©"></span></h5>
                                            <div class="flex gap-2">
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="TranslatorApp.preview.copyOriginalText(this)">Ù†Ø³Ø® Ø§Ù„Ø£ØµÙ„ÙŠ</button>
                                                <button class="text-xs font-semibold py-1 px-2 rounded" onclick="document.getElementById('${diffId}').parentNode.classList.toggle('hidden')">Ø¹Ø±Ø¶/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</button>
                                            </div>
                                        </div>
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                                <div class="original-text-readonly p-3 rounded-lg text-sm h-full" style="background-color: var(--bg-color); overflow:auto;">
                                                    <div dir="ltr">${this.renderContentWithMath(displayOriginalValue)}</div>
                                                </div>
                                            </div>
                                            <div>
                                                <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                                <div id="${fieldId}" 
                                                     contenteditable="true"
                                                     class="editable-preview-field"
                                                     data-path="${path}"
                                                     data-file-index="${fileIndex}"
                                                     dir="${editableDir}"
                                                     style="unicode-bidi: embed;">
                                                     ${this.renderContentWithMath(finalTranslatedValue)}
                                                </div>
                                            </div>
                                        </div>
                                        <!-- Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙˆÙ…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø¬ÙˆØ¯Ø© -->
                                        <div class="flex justify-between items-center mt-3 pt-3 border-t" style="border-color: var(--card-border);">
                                            <div class="flex gap-3 text-xs" style="color: var(--secondary-text);">
                                                <span>Ø§Ù„ÙƒÙ„Ù…Ø§Øª: <span class="font-bold" id="wordCount-${fieldId}">-</span></span>
                                                <span>Ø§Ù„Ø£Ø­Ø±Ù: <span class="font-bold" id="charCount-${fieldId}">-</span></span>
                                            </div>
                                            <div class="flex gap-1" id="quality-indicators-${fieldId}">
                                                <span class="quality-badge" id="numbers-check-${fieldId}" title="ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…">ğŸ”¢</span>
                                                <span class="quality-badge" id="html-check-${fieldId}" title="ØªÙˆØ§Ø²Ù† HTML">ğŸ·ï¸</span>
                                                <span class="quality-badge" id="latex-check-${fieldId}" title="ØµØ­Ø© LaTeX">ğŸ“</span>
                                                <span class="quality-badge" id="blanks-check-${fieldId}" title="Blanks Ø³Ù„ÙŠÙ…Ø©">__</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© -->
                                        <div class="flex gap-1 mt-2">
                                            <button class="action-btn" title="Ù†Ø³Ø® Ø§Ù„ØªØ±Ø¬Ù…Ø©" onclick="TranslatorApp.preview.copyTranslation('${fieldId}')">ğŸ“‹</button>
                                            <button class="action-btn" title="Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ©" onclick="TranslatorApp.preview.restoreAI('${fieldId}', '${path}', ${fileIndex})">ğŸ¤–</button>
                                            <button class="action-btn" title="Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø©" onclick="TranslatorApp.preview.toggleNotes('${fieldId}')">ğŸ“</button>
                                        </div>
                                        
                                        <!-- Ù‚Ø³Ù… Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª -->
                                        <div id="notes-${fieldId}" class="hidden mt-2">
                                            <textarea class="w-full text-xs p-2 border rounded" 
                                                      placeholder="Ø§ÙƒØªØ¨ Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ù‡Ù†Ø§..." 
                                                      rows="2"
                                                      onchange="TranslatorApp.preview.saveNote('${fieldId}', this.value)"></textarea>
                                        </div>
                                        
                                        <div class="mt-4 hidden">
                                             <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª (Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù…Ù‚Ø§Ø¨Ù„ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©)</p>
                                             <p class="text-xs mb-2" style="color: var(--secondary-text);">ğŸ’¡ Ù‡Ø°Ø§ ÙŠÙ‚Ø§Ø±Ù† Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ© Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ù…Ø¹ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© (ÙƒÙ„Ø§Ù‡Ù…Ø§ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)</p>
                                            <div id="${diffId}" class="diff-view"></div>
                                        </div>
                                    </div>`;
                            } catch (fieldError) {
                                console.warn('Error rendering field:', fieldError);
                                return '';
                            }
                        };
                
                        html += renderField('Ø§Ù„Ø¨ÙŠØ§Ù† (Statement)', TranslatorApp.state.originalJsonData[fileIndex].data.statement, data.statement, 'statement');
                
                        data.parts?.forEach((part, partIndex) => {
                            try {
                                const originalPart = TranslatorApp.state.originalJsonData[fileIndex].data.parts[partIndex];
                                if (!originalPart) return;
                
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--secondary-text);">Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1} (Ø§Ù„Ù†ÙˆØ¹: ${part.type || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'})</h5>`;
                
                                // Check if stem exists and is not empty
                                if (originalPart.stem && originalPart.stem.trim()) {
                                    html += renderField('Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem)', originalPart.stem, part.stem, `parts.${partIndex}.stem`);
                                } else {
                                    html += `<div class="border rounded-lg p-4 bg-yellow-50" style="border-color: #f59e0b;">
                                        <p class="text-sm font-semibold text-yellow-700">âš ï¸ ØªØ­Ø°ÙŠØ±: Ø§Ù„Ø³Ø¤Ø§Ù„ (Stem) ÙØ§Ø±Øº ÙÙŠ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                    </div>`;
                                }
                
                                if (originalPart.answer) {
                                    if (part.type === 'input_box' && typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const originalUnit = originalPart.answer.unit || '';
                                        const translatedValue = part.answer.value;
                                        const translatedUnit = part.answer.unit || '';
                                        html += this.renderInputField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalValue, translatedValue, originalUnit, translatedUnit, `parts.${partIndex}.answer.value`, fileIndex);
                                    } else if (Array.isArray(originalPart.answer)) {
                                        html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'string') {
                                        html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalPart.answer, part.answer, `parts.${partIndex}.answer`);
                                    } else if (typeof originalPart.answer === 'object' && originalPart.answer.hasOwnProperty('value')) {
                                        const originalValue = originalPart.answer.value;
                                        const translatedValue = (part.answer && part.answer.value) || originalPart.answer.value;
                                        html += renderField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer)', originalValue, translatedValue, `parts.${partIndex}.answer.value`);
                                    } else {
                                        html += this.renderReadOnlyField('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Answer - ØºÙŠØ± Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ±Ø¬Ù…Ø©)', JSON.stringify(originalPart.answer));
                                    }
                                }
                
                                // Add choices section header for better organization
                                if (part.choices && part.choices.length > 0) {
                                    html += '<div class="mt-4 mb-2"><h6 class="font-semibold text-sm" style="color: var(--secondary-text);">Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª (Choices):</h6></div>';
                                    
                                    // CRITICAL FIX: Add note about choice order
                                    html += '<div class="mb-3 p-2 bg-blue-50 rounded text-xs" style="color: var(--secondary-text);">';
                                    html += 'ğŸ’¡ <strong>Ù…Ù„Ø§Ø­Ø¸Ø©:</strong> ØªØ±ØªÙŠØ¨ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL) ÙƒÙ…Ø§ Ù‡Ùˆ Ù…Ø·Ù„ÙˆØ¨ ÙÙŠ Ø§Ù„Ù…Ù†Ø§Ù‡Ø¬ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©';
                                    html += '</div>';
                                }
                                
                                part.choices?.forEach((choice, choiceIndex) => {
                                    const originalChoice = originalPart.choices[choiceIndex];
                                    const isCorrect = choice.is_correct || false;
                                    const correctBadge = isCorrect ? ' <span style="background-color: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: bold;">âœ“ ØµØ­ÙŠØ­</span>' : '';
                                    
                                    // CRITICAL FIX: Add visual indicator for correct answers
                                    const correctIndicator = isCorrect ? ' <span style="color: #10b981; font-weight: bold;">[Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©]</span>' : '';
                                    
                                    // CRITICAL FIX: Force RTL for Arabic choices to fix LTR issue
                                    html += renderField(`Ø®ÙŠØ§Ø± ${choiceIndex + 1}${correctBadge}${correctIndicator}`, originalChoice.html_content, choice.html_content, `parts.${partIndex}.choices.${choiceIndex}.html_content`, 'rtl');
                                });
                
                                if (originalPart.gap_text_keys) {
                                    const sortedOriginalKeys = [...originalPart.gap_text_keys].sort((a, b) => a.correct_order - b.correct_order);
                                    const translatedPart = data.parts[partIndex];
                                    const sortedTranslatedKeys = [...(translatedPart.gap_text_keys || [])].sort((a, b) => a.correct_order - b.correct_order);
                
                                    sortedOriginalKeys.forEach((originalKeyItem, index) => {
                                        const translatedKeyItem = sortedTranslatedKeys[index] || { value: '' };
                                        const path = `parts.${partIndex}.gap_text_keys.${originalPart.gap_text_keys.findIndex(item => item.value === originalKeyItem.value)}.value`;
                
                                        html += `<div class="border rounded-lg p-4" style="border-color: var(--card-border);">
                                            <div class="flex justify-between items-center mb-2">
                                                <h5 class="font-bold flex items-center">ÙƒÙ„Ù…Ø© Ø§Ù„ÙØ±Ø§Øº ${originalKeyItem.correct_order}</h5>
                                            </div>
                                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--secondary-text);">Ø§Ù„Ø£ØµÙ„ÙŠ</p>
                                                    <div class="p-3 rounded-lg text-sm h-full" dir="ltr" style="background-color: var(--bg-color); color: var(--secondary-text);">${TranslatorApp.security.sanitize(originalKeyItem.value)}</div>
                                                </div>
                                                <div>
                                                    <p class="text-sm font-semibold mb-1" style="color: var(--success-color);">Ø§Ù„Ù…ØªØ±Ø¬Ù… (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)</p>
                                                    <div id="field-${fileIndex}-${path.replace(/\./g, '-')}"
                                                        contenteditable="true"
                                                        class="editable-preview-field"
                                                        data-path="${path}"
                                                        data-file-index="${fileIndex}"
                                                        dir="rtl">
                                                        ${TranslatorApp.security.sanitize(translatedKeyItem.value)}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>`;
                                    });
                                }
                                
                                // Add ai.guidelines section for string type questions
                                if (originalPart.ai && originalPart.ai.guidelines && Array.isArray(originalPart.ai.guidelines) && originalPart.ai.guidelines.length > 0) {
                                    html += '<div class="mt-4 mb-2"><h6 class="font-semibold text-sm" style="color: var(--secondary-text);">Ø¥Ø±Ø´Ø§Ø¯Ø§Øª Ø§Ù„ØªØµØ­ÙŠØ­ (AI Guidelines):</h6></div>';
                                    
                                    originalPart.ai.guidelines.forEach((originalGuideline, guidelineIndex) => {
                                        const translatedGuideline = part.ai?.guidelines?.[guidelineIndex] || {};
                                        
                                        html += `<div class="border rounded-lg p-4 mb-3" style="border-color: var(--card-border); background-color: rgba(59, 130, 246, 0.05);">
                                            <div class="mb-2">
                                                <span class="text-xs font-semibold px-2 py-1 rounded" style="background-color: #3b82f6; color: white;">Ø¥Ø±Ø´Ø§Ø¯ ${guidelineIndex + 1}</span>
                                                ${originalGuideline.mark ? `<span class="text-xs font-semibold px-2 py-1 rounded ml-2" style="background-color: #10b981; color: white;">Ø§Ù„Ø¹Ù„Ø§Ù…Ø©: ${originalGuideline.mark}</span>` : ''}
                                            </div>`;
                                        
                                        // Render student_answer
                                        if (originalGuideline.student_answer && typeof originalGuideline.student_answer === 'string') {
                                            html += renderField('Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ (Student Answer)', 
                                                originalGuideline.student_answer, 
                                                translatedGuideline.student_answer || originalGuideline.student_answer, 
                                                `parts.${partIndex}.ai.guidelines.${guidelineIndex}.student_answer`);
                                        }
                                        
                                        // Render comment
                                        if (originalGuideline.comment && typeof originalGuideline.comment === 'string') {
                                            html += renderField('Ø§Ù„ØªØ¹Ù„ÙŠÙ‚ (Comment)', 
                                                originalGuideline.comment, 
                                                translatedGuideline.comment || originalGuideline.comment, 
                                                `parts.${partIndex}.ai.guidelines.${guidelineIndex}.comment`);
                                        }
                                        
                                        html += '</div>';
                                    });
                                }
                
                                html += '</div>';
                            } catch (partError) {
                                console.warn('Error rendering part:', partError);
                                html += '<div class="border-t pt-4 mt-4 space-y-4" style="border-color: var(--card-border);">';
                                html += `<h5 class="font-semibold text-md" style="color: var(--error-color);">Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø¬Ø²Ø¡ ${partIndex + 1}</h5>`;
                                html += '</div>';
                            }
                        });
                
                        html += '</div>';
                        return html;
                    } catch (error) {
                        console.error('Render file content error:', error);
                        return '<div class="space-y-6"><div class="border rounded-lg p-4" style="border-color: var(--card-border);"><h5 class="font-bold flex items-center mb-2" style="color: var(--error-color);">Ø®Ø·Ø£ ÙÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰</h5><div class="p-3 rounded-lg text-sm" style="background-color: var(--bg-color); color: var(--error-color);">ÙØ´Ù„ ÙÙŠ Ø¹Ø±Ø¶ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù</div></div></div>';
                    }
                },
                updateData(fileIndex, path, value) {
                    try {
                        const keys = path.split('.');
                        let current = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        const original = TranslatorApp.state.originalJsonData[fileIndex].data; // Keep original for reference
                        for (let i = 0; i < keys.length - 1; i++) {
                            current = current[keys[i]];
                        }
                        const lastKey = keys[keys.length - 1];
                
                        // Correctly handle the case for gap_text_keys
                        if (keys[keys.length - 2] === 'gap_text_keys') {
                            const keyIndex = parseInt(keys[keys.length - 1], 10);
                            if (current.gap_text_keys && current.gap_text_keys[keyIndex]) {
                                current.gap_text_keys[keyIndex].value = value;
                            }
                        } 
                        // Handle ai.guidelines paths (e.g., parts.0.ai.guidelines.0.student_answer)
                        else if (keys.includes('guidelines') && keys[keys.length - 2] && !isNaN(keys[keys.length - 2])) {
                            const guidelineIndex = parseInt(keys[keys.length - 2], 10);
                            const fieldName = keys[keys.length - 1]; // 'student_answer' or 'comment'
                            
                            // Navigate to the guidelines array
                            let guidelinesParent = TranslatorApp.state.translatedJsonData[fileIndex].data;
                            for (let i = 0; i < keys.length - 2; i++) {
                                guidelinesParent = guidelinesParent[keys[i]];
                            }
                            
                            if (guidelinesParent && guidelinesParent[guidelineIndex]) {
                                guidelinesParent[guidelineIndex][fieldName] = value;
                            }
                        } 
                        else {
                            // Otherwise, set the value directly
                            current[lastKey] = value;
                        }
                
                        TranslatorApp.history.push(TranslatorApp.state.translatedJsonData);
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Update data error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.', 'error');
                    }
                },

                generateInitialDiffs(fileIndex) {
                    try {
                        const originalData = TranslatorApp.state.originalJsonData[fileIndex].data;
                        const processPath = (path) => {
                            try {
                                if (originalData === undefined || originalData === null) return;
                                this.updateDiff(fileIndex, path);
                            } catch (error) {
                                console.warn(`Error processing path ${path}:`, error);
                            }
                        };
                        processPath('statement');
                        originalData.parts?.forEach((part, partIndex) => {
                            processPath(`parts.${partIndex}.stem`);
                            if (typeof part.answer === 'string') processPath(`parts.${partIndex}.answer`);
                            part.choices?.forEach((choice, choiceIndex) => {
                                processPath(`parts.${partIndex}.choices.${choiceIndex}.html_content`);
                            });
                            part.gap_text_keys?.forEach((keyItem, keyIndex) => {
                                processPath(`parts.${partIndex}.gap_text_keys.${keyIndex}.value`);
                            });
                            // Process ai.guidelines
                            part.ai?.guidelines?.forEach((guideline, guidelineIndex) => {
                                if (guideline.student_answer) processPath(`parts.${partIndex}.ai.guidelines.${guidelineIndex}.student_answer`);
                                if (guideline.comment) processPath(`parts.${partIndex}.ai.guidelines.${guidelineIndex}.comment`);
                            });
                        });
                    } catch (error) {
                        console.error('Generate initial diffs error:', error);
                    }
                },

                updateDiff(fileIndex, path) {
                    try {
                        const fieldId = `field-${fileIndex}-${path.replace(/\./g, '-')}`;
                        const diffId = `diff-${fieldId}`;
                        const diffContainer = document.getElementById(diffId);
                        if (!diffContainer) return;

                        const keys = path.split('.');
                        // Compare initial translation with current translation (both in Arabic)
                        let initialText = TranslatorApp.state.initialTranslatedJsonData[fileIndex]?.data;
                        let currentText = TranslatorApp.state.translatedJsonData[fileIndex].data;
                        
                        for (let i = 0; i < keys.length; i++) {
                            initialText = initialText ? initialText[keys[i]] : '';
                            currentText = currentText ? currentText[keys[i]] : '';
                        }

                        const cleanInitial = this.plainTextForDiff(initialText || '');
                        const cleanCurrent = this.plainTextForDiff(currentText || '');

                        diffContainer.innerHTML = this.createDiffHtml(cleanInitial, cleanCurrent);
                    } catch (error) {
                        console.error('Update diff error:', error);
                    }
                },

                prepareInteractiveMathFields() {
                    try {
                        const mathFields = TranslatorApp.dom.previewContainer.querySelectorAll('math-field');
                        console.log(`ğŸ”¢ [MathLive] Found ${mathFields.length} math-field elements to initialize`);
                        
                        // CRITICAL FIX: Wait for MathLive to be fully loaded
                        if (typeof window.MathfieldElement === 'undefined') {
                            console.warn('ğŸ”¢ [MathLive] MathfieldElement not loaded yet, retrying in 100ms...');
                            setTimeout(() => this.prepareInteractiveMathFields(), 100);
                            return;
                        }
                        
                        // CRITICAL FIX: Force MathLive to recognize custom elements
                        if (!customElements.get('math-field')) {
                            console.warn('ğŸ”¢ [MathLive] Custom element not registered, retrying...');
                            setTimeout(() => this.prepareInteractiveMathFields(), 200);
                            return;
                        }
                        
                        mathFields.forEach((mf, index) => {
                            console.log(`ğŸ”¢ [MathLive] Initializing math-field ${index + 1}:`, {
                                value: mf.value,
                                defaultMode: mf.getAttribute('default-mode'),
                                readOnly: mf.getAttribute('read-only'),
                                isInEditable: !!mf.closest('.editable-preview-field'),
                                isInOriginal: !!mf.closest('.original-text-readonly')
                            });
                            try {
                                // Check if this math-field is in an editable area
                                const isInEditableArea = mf.closest('.editable-preview-field');
                                const isInOriginal = mf.closest('.original-text-readonly');
                                
                                // CRITICAL FIX: Apply RTL direction and Arabic locale for translation area
                                if (isInEditableArea) {
                                    // Translation area (Arabic) - RTL direction
                                    mf.removeAttribute('read-only');
                                    mf.setAttribute('dir', 'rtl');
                                    mf.setAttribute('locale', 'ar');
                                    mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                    
                                    // âœ¨ CRITICAL: Force Arabic keyboard to be active by default
                                    if (typeof mf.setOptions === 'function') {
                                        mf.setOptions({
                                            locale: 'ar',
                                            virtualKeyboardMode: 'onfocus',
                                            virtualKeyboards: 'numeric functions symbols greek',
                                            customVirtualKeyboardLayers: {
                                                'arabic-math': {
                                                    label: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
                                                    tooltip: 'Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©'
                                                }
                                            }
                                        });
                                    }
                                    
                                    console.log('âœ… [RTL] Applied RTL direction for Arabic translation math-field');
                                } else if (isInOriginal) {
                                    // Original area (English) - LTR direction
                                    mf.setAttribute('read-only', 'true');
                                    mf.setAttribute('dir', 'ltr');
                                    mf.setAttribute('locale', 'en');
                                    mf.setAttribute('virtual-keyboard-default-language', 'en');
                                    console.log('âœ… [LTR] Applied LTR direction for English original math-field');
                                }
                                
                                // Force MathLive to recognize and render the element
                                if (mf.value && mf.value.trim()) {
                                    try {
                                        // CRITICAL FIX: Ensure MathLive processes the element
                                        if (mf.value && !mf.innerHTML.includes('math-field')) {
                                            // Force MathLive to render the value
                                            mf.setAttribute('value', mf.value);
                                            mf.dispatchEvent(new Event('input'));
                                            mf.dispatchEvent(new Event('change'));
                                        }
                                        
                                        // Mark as initialized
                                        mf.setAttribute('data-mathlive-initialized', 'true');
                                        
                                        // CRITICAL FIX: Force re-render if needed
                                        setTimeout(() => {
                                            if (mf.value && mf.innerHTML === mf.value) {
                                                console.warn('ğŸ”¢ [MathLive] Force re-rendering math-field');
                                                mf.innerHTML = '';
                                                mf.setAttribute('value', mf.value);
                                            }
                                        }, 50);
                                    } catch (err) {
                                        console.warn('MathLive rendering trigger error:', err);
                                    }
                                }
                                
                                mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                mf.setAttribute('use-shared-virtual-keyboard', '');
                                
                                // Add delete button only for editable math-fields
                                if (isInEditableArea && !mf.querySelector('.math-field-delete-btn')) {
                                    const deleteBtn = document.createElement('button');
                                    deleteBtn.className = 'math-field-delete-btn';
                                    deleteBtn.textContent = 'Ã—';
                                    deleteBtn.title = 'Ø­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©';
                                    deleteBtn.onclick = (event) => {
                                        event.stopPropagation();
                                        event.preventDefault();
                                        const fieldContainer = mf.closest('.editable-preview-field');
                                        mf.remove();
                                        if (fieldContainer) {
                                            TranslatorApp.preview.handlePreviewFieldUpdate(fieldContainer);
                                        }
                                    };
                                    mf.appendChild(deleteBtn);
                                }
                                
                                // Add copy button for original math-fields
                                if (isInOriginal && !mf.querySelector('.math-field-copy-btn')) {
                                    const copyBtn = document.createElement('button');
                                    copyBtn.className = 'math-field-copy-btn';
                                    copyBtn.textContent = 'ğŸ“‹';
                                    copyBtn.title = 'Ù†Ø³Ø® Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©';
                                    copyBtn.onclick = (event) => {
                                        event.stopPropagation();
                                        event.preventDefault();
                                        const value = mf.value || '';
                                        navigator.clipboard.writeText(`$${value}$`).then(() => {
                                            TranslatorApp.ui.showAlert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©', 'success', 1500);
                                        });
                                    };
                                    mf.appendChild(copyBtn);
                                }

                                // Enhanced language support for MathLive
                                mf.setAttribute('virtual-keyboard-layout', 'qwerty');
                                mf.setAttribute('virtual-keyboard-theme', 'material');

                                // Enable Arabic and English input
                                mf.setAttribute('virtual-keyboard-languages', 'ar,en');
                                mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                
                                // CRITICAL FIX: Enable right-click and long-press functionality
                                mf.setAttribute('virtual-keyboard-toggle', 'on');
                                mf.setAttribute('virtual-keyboard-mode', 'onfocus');
                                mf.setAttribute('use-shared-virtual-keyboard', '');
                                
                                // Add event listeners for right-click and long-press
                                mf.addEventListener('contextmenu', (e) => {
                                    e.preventDefault();
                                    try {
                                        mf.executeCommand('showVirtualKeyboard');
                                    } catch (err) {
                                        console.warn('MathLive keyboard context menu error:', err);
                                    }
                                });
                                
                                let longPressTimer;
                                mf.addEventListener('pointerdown', (e) => {
                                    longPressTimer = setTimeout(() => {
                                        try {
                                            mf.executeCommand('showVirtualKeyboard');
                                        } catch (err) {
                                            console.warn('MathLive keyboard long-press error:', err);
                                        }
                                    }, 500);
                                });
                                
                                mf.addEventListener('pointerup', () => {
                                    clearTimeout(longPressTimer);
                                });
                                
                                mf.addEventListener('pointerleave', () => {
                                    clearTimeout(longPressTimer);
                                });

                                // Set direction based on content
                                const currentValue = mf.value || '';
                                const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(currentValue);
                                const direction = hasArabic ? 'rtl' : 'ltr';
                                mf.setAttribute('dir', direction);

                                // Add language toggle functionality
                                mf.addEventListener('keydown', (e) => {
                                    try {
                                        // Alt + L to toggle language
                                        if (e.altKey && e.key === 'l') {
                                            e.preventDefault();
                                            const currentLang = mf.getAttribute('virtual-keyboard-default-language');
                                            const newLang = currentLang === 'ar' ? 'en' : 'ar';
                                            mf.setAttribute('virtual-keyboard-default-language', newLang);

                                            // Update direction
                                            mf.setAttribute('dir', newLang === 'ar' ? 'rtl' : 'ltr');

                                            // Show feedback
                                            const langText = newLang === 'ar' ? 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' : 'English';
                                            TranslatorApp.ui.showAlert(`ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ${langText}`, 'info', 1500);
                                        }
                                    } catch (langError) {
                                        console.warn('Language toggle error:', langError);
                                    }
                                });

                                mf.addEventListener('focus', () => {
                                    try {
                                        // âœ¨ CRITICAL: For Arabic translation area, always start with Arabic keyboard
                                        if (isInEditableArea) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                            mf.setAttribute('dir', 'rtl');
                                            
                                            // Force Arabic locale
                                            if (typeof mf.setOptions === 'function') {
                                                mf.setOptions({
                                                    locale: 'ar',
                                                    virtualKeyboardMode: 'onfocus'
                                                });
                                            }
                                        }
                                        
                                        if (typeof mf.executeCommand === 'function') {
                                            setTimeout(() => {
                                                try {
                                                    mf.executeCommand('showVirtualKeyboard');

                                                    // Set initial language based on content or area
                                                    if (isInEditableArea) {
                                                        // Always Arabic for translation area
                                                        mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                                        mf.setAttribute('dir', 'rtl');
                                                    } else {
                                                        // Original area: detect from content
                                                        const value = mf.value || '';
                                                        const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                                        if (hasArabic) {
                                                            mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                                            mf.setAttribute('dir', 'rtl');
                                                        } else {
                                                            mf.setAttribute('virtual-keyboard-default-language', 'en');
                                                            mf.setAttribute('dir', 'ltr');
                                                        }
                                                    }
                                                } catch (keyboardError) {
                                                    console.warn('MathLive keyboard error:', keyboardError);
                                                }
                                            }, 100);
                                        }
                                    } catch (focusError) {
                                        console.warn('MathLive focus error:', focusError);
                                    }
                                }, { once: false });

                                // Add input event to detect language changes
                                mf.addEventListener('input', (e) => {
                                    try {
                                        const value = e.target.value || '';
                                        const hasArabic = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/.test(value);
                                        const hasEnglish = /[a-zA-Z]/.test(value);

                                        // Auto-switch language based on input
                                        if (hasArabic && !hasEnglish) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'ar');
                                            mf.setAttribute('dir', 'rtl');
                                        } else if (hasEnglish && !hasArabic) {
                                            mf.setAttribute('virtual-keyboard-default-language', 'en');
                                            mf.setAttribute('dir', 'ltr');
                                        }
                                        // For mixed content, keep current setting
                                    } catch (inputError) {
                                        console.warn('MathLive input error:', inputError);
                                    }
                                });

                            } catch (fieldError) {
                                console.warn('MathLive field setup error:', fieldError);
                            }
                        });
                        
                        // CRITICAL: Explicitly tell MathLive to scan for new math-field elements
                        try {
                            console.log('ğŸ” [MathLive] Attempting explicit scan/render...');
                            
                            // Method 1: Try MathfieldElement.scan (newer API)
                            if (window.MathfieldElement && typeof window.MathfieldElement.scan === 'function') {
                                window.MathfieldElement.scan(TranslatorApp.dom.previewContainer);
                                console.log('âœ… [MathLive] MathfieldElement.scan() executed successfully');
                            } 
                            // Method 2: Try MathLive.renderMathInElement (older API)
                            else if (window.MathLive && typeof window.MathLive.renderMathInElement === 'function') {
                                window.MathLive.renderMathInElement(TranslatorApp.dom.previewContainer);
                                console.log('âœ… [MathLive] MathLive.renderMathInElement() executed successfully');
                            }
                            // Method 3: Try direct activation of each element
                            else {
                                console.log('âš ï¸ [MathLive] No scan method available, trying direct activation');
                                mathFields.forEach((mf, index) => {
                                    try {
                                        // Force re-render by updating value
                                        const currentValue = mf.getAttribute('value') || mf.value || '';
                                        if (currentValue) {
                                            mf.value = currentValue;
                                            console.log(`âœ… [MathLive] Manually activated math-field ${index + 1}`);
                                        }
                                    } catch (activationError) {
                                        console.warn(`âŒ [MathLive] Failed to activate math-field ${index + 1}:`, activationError);
                                    }
                                });
                            }
                        } catch (scanError) {
                            console.warn('âŒ [MathLive] Scan/render error:', scanError);
                        }
                    } catch (generalError) {
                        console.warn('MathLive general setup error:', generalError);
                    }
                },

                createDiffHtml(text1, text2) {
                    try {
                        const d = this.dmp.diff_main(text1, text2);
                        this.dmp.diff_cleanupSemantic(d);
                        return this.dmp.diff_prettyHtml(d);
                    } catch (error) {
                        console.error('Create diff HTML error:', error);
                        return `<div style="color: var (--error-color);">ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª</div>`;
                    }
                },

                plainTextForDiff(html) {
                    try {
                        const div = document.createElement('div');
                        div.innerHTML = html || '';
                        return div.textContent || div.innerText || '';
                    } catch (error) {
                        console.error('Plain text for diff error:', error);
                        return '';
                    }
                },

                // Helper functions for new features
                copyTranslation(fieldId) {
                    try {
                        const field = document.getElementById(fieldId);
                        if (field) {
                            const text = field.textContent || '';
                            navigator.clipboard.writeText(text).then(() => {
                                TranslatorApp.ui.showAlert('ØªÙ… Ù†Ø³Ø® Ø§Ù„ØªØ±Ø¬Ù…Ø©', 'success', 2000);
                            }).catch(err => {
                                console.error('Copy translation failed:', err);
                                TranslatorApp.ui.showAlert('ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®', 'error', 2000);
                            });
                        }
                    } catch (error) {
                        console.error('Copy translation error:', error);
                    }
                },
                
                restoreAI(fieldId, path, fileIndex) {
                    try {
                        const initialData = TranslatorApp.state.initialTranslatedJsonData[fileIndex];
                        if (!initialData) {
                            TranslatorApp.ui.showAlert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ±Ø¬Ù…Ø© Ø¢Ù„ÙŠØ© Ù…Ø­ÙÙˆØ¸Ø©', 'info', 3000);
                            return;
                        }
                        
                        const field = document.getElementById(fieldId);
                        if (field) {
                            // Get initial translation from saved data
                            let data = initialData.data;
                            const keys = path.split('.');
                            for (let key of keys) {
                                data = data[key];
                            }
                            field.innerHTML = TranslatorApp.preview.renderContentWithMath(data);
                            TranslatorApp.preview.handlePreviewFieldUpdate(field);
                            TranslatorApp.ui.showAlert('ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¢Ù„ÙŠØ©', 'success', 2000);
                        }
                    } catch (error) {
                        console.error('Restore AI error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ØªØ±Ø¬Ù…Ø©', 'error');
                    }
                },
                
                toggleNotes(fieldId) {
                    try {
                        const notesDiv = document.getElementById(`notes-${fieldId}`);
                        if (notesDiv) {
                            notesDiv.classList.toggle('hidden');
                        }
                    } catch (error) {
                        console.error('Toggle notes error:', error);
                    }
                },
                
                saveNote(fieldId, noteText) {
                    try {
                        const notes = JSON.parse(localStorage.getItem('translationNotes') || '{}');
                        notes[fieldId] = noteText;
                        localStorage.setItem('translationNotes', JSON.stringify(notes));
                        TranslatorApp.state.hasUnsavedChanges = true;
                    } catch (error) {
                        console.error('Save note error:', error);
                    }
                },
                
                loadNotes() {
                    try {
                        const notes = JSON.parse(localStorage.getItem('translationNotes') || '{}');
                        Object.keys(notes).forEach(fieldId => {
                            const textarea = document.querySelector(`#notes-${fieldId} textarea`);
                            if (textarea) {
                                textarea.value = notes[fieldId];
                            }
                        });
                    } catch (error) {
                        console.error('Load notes error:', error);
                    }
                },

                copyOriginalText(button) {
                    try {
                        const fieldContainer = button.closest('.border').querySelector('.original-text-readonly');
                        if (fieldContainer) {
                            // Ù†Ø³ØªØ®Ø¯Ù… innerHTML Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ØªÙ†Ø³ÙŠÙ‚ math-field ÙƒÙ€ $...$
                            const textToCopy = fieldContainer.innerHTML;

                            // ØªØ­ÙˆÙŠÙ„ math-field Ø¥Ù„Ù‰ LaTeX Ù‚Ø¨Ù„ Ø§Ù„Ù†Ø³Ø®
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = textToCopy;
                            tempDiv.querySelectorAll('math-field').forEach(mf => {
                                const mode = mf.getAttribute('default-mode');
                                const value = mf.value;
                                const delimiter = (mode === 'math') ? '$$' : '$';
                                mf.parentNode.replaceChild(document.createTextNode(`${delimiter}${value}${delimiter}`), mf);
                            });

                            const plainText = tempDiv.textContent || '';

                            navigator.clipboard.writeText(plainText).then(() => {
                                    TranslatorApp.ui.showAlert('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ!', 'success', 2000);
                            }).catch(err => {
                                console.error('Fallback: Oops, unable to copy', err);
                                TranslatorApp.ui.showAlert('ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ù†Øµ.', 'error', 2000);
                            });
                        } else {
                            TranslatorApp.ui.showAlert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ù†Ø³Ø®Ù‡.', 'error', 2000);
                        }
                    } catch (error) {
                        console.error('Copy original text error:', error);
                        TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ Ù†Ø³Ø® Ø§Ù„Ù†Øµ Ø§Ù„Ø£ØµÙ„ÙŠ.', 'error', 2000);
                    }
                },

                applyFilters() {
                    try {
                        const searchTerm = TranslatorApp.dom.searchPreview.value.toLowerCase();
                        const typeFilter = TranslatorApp.dom.filterByType?.value || 'all';
                        const statusFilter = TranslatorApp.dom.filterByStatus?.value || 'all';
                        const sortBy = TranslatorApp.dom.sortBy?.value || 'default'; // (Ø³Ù†Ù†ÙØ° Ø§Ù„ÙØ±Ø² Ù„Ø§Ø­Ù‚Ù‹Ø§)

                        const allAccordions = document.querySelectorAll('#previewContainer .preview-card');
                        let visibleCount = 0;

                        allAccordions.forEach(accordion => {
                            let show = true;

                            const fileName = accordion.getAttribute('data-file-name') || '';
                            const partTypes = accordion.getAttribute('data-part-types') || '';
                            const fullTextContent = accordion.textContent.toLowerCase();

                            // 1. ÙÙ„ØªØ± Ø§Ù„Ø¨Ø­Ø« (Search)
                            if (searchTerm && !fullTextContent.includes(searchTerm) && !fileName.includes(searchTerm)) {
                                show = false;
                            }

                            // 2. ÙÙ„ØªØ± Ø§Ù„Ù†ÙˆØ¹ (Type)
                            if (show && typeFilter !== 'all' && !partTypes.includes(typeFilter)) {
                                show = false;
                            }

                            // 3. ÙÙ„ØªØ± Ø§Ù„Ø­Ø§Ù„Ø© (Status)
                            if (show && statusFilter !== 'all') {
                                if (statusFilter === 'edited') {
                                    if (!accordion.querySelector('.status-edited')) show = false;
                                } else if (statusFilter === 'warnings') {
                                    if (!accordion.querySelector('.field-error, .field-warning')) show = false;
                                } else if (statusFilter === 'translated') {
                                    if (accordion.querySelector('.status-edited, .field-error, .field-warning')) show = false;
                                }
                            }

                            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥Ø¸Ù‡Ø§Ø±/Ø§Ù„Ø¥Ø®ÙØ§Ø¡
                            accordion.style.display = show ? '' : 'none';
                            if (show) visibleCount++;
                        });

                        console.log(`[Filter] ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±. ${visibleCount} Ù…Ù„ÙØ§Øª Ø¸Ø§Ù‡Ø±Ø©.`);
                        // (Ù…Ù†Ø·Ù‚ Ø§Ù„ÙØ±Ø² 'sortBy' ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØªÙ‡ Ù‡Ù†Ø§ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø¥Ø¹Ø§Ø¯Ø© ØªØ±ØªÙŠØ¨ Ø¹Ù†Ø§ØµØ± DOM)

                    } catch (error) {
                        console.error('Apply filters error:', error);
                        TranslatorApp.ui.showAlert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±', 'error');
                    }
                }
            },
            export: {
                exportAs(format) {
                    return this.toJson();
                },

                async toJson() {
                    const useMappedIds = TranslatorApp.dom.useMappedIdsCheckbox.checked;
                    let mappedIds = [];
                    let idCounter = 0;
                    
                    if (useMappedIds) {
                        try {
                            mappedIds = JSON.parse(TranslatorApp.dom.mappedIdsInput.value);
                            if (!Array.isArray(mappedIds)) throw new Error('not array');
                        } catch (e) {
                            return TranslatorApp.ui.showAlert('Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (mapped_id) ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡Ø§ Ù…ØµÙÙˆÙØ© JSON ØµØ­ÙŠØ­Ø©.', 'error');
                        }
                    }
                    
                    const selectedTranslator = TranslatorApp.state.selectedTranslator;
                    const sourceId = TranslatorApp.state.translators[selectedTranslator];
                    
                    const zip = new JSZip();
                    
                    // Helper function to add RTL direction to all math-field tags in content
                    const addRTLToMathFields = (content) => {
                        if (!content || typeof content !== 'string') return content;
                        
                        // Add dir="rtl", locale="ar", and lang="ar" to all <math-field> tags
                        let processed = content;
                        
                        // Pattern 1: math-field without dir attribute
                        processed = processed.replace(
                            /<math-field(?!\s+[^>]*\bdir=)([^>]*)>/gi,
                            (match, attrs) => {
                                // Add dir="rtl" if not present
                                return `<math-field dir="rtl"${attrs}>`;
                            }
                        );
                        
                        // Pattern 2: math-field with dir="ltr" - change to rtl
                        processed = processed.replace(
                            /<math-field([^>]*)\bdir="ltr"([^>]*)>/gi,
                            '<math-field$1dir="rtl"$2>'
                        );
                        
                        // Pattern 3: Add locale="ar" if not present
                        processed = processed.replace(
                            /<math-field(?!\s+[^>]*\blocale=)([^>]*)>/gi,
                            (match, attrs) => {
                                return `<math-field locale="ar"${attrs}>`;
                            }
                        );
                        
                        // Pattern 4: math-field with locale="en" - change to ar
                        processed = processed.replace(
                            /<math-field([^>]*)\blocale="en"([^>]*)>/gi,
                            '<math-field$1locale="ar"$2>'
                        );
                        
                        // Pattern 5: Add lang="ar" if not present
                        processed = processed.replace(
                            /<math-field(?!\s+[^>]*\blang=)([^>]*)>/gi,
                            (match, attrs) => {
                                return `<math-field lang="ar"${attrs}>`;
                            }
                        );
                        
                        // Pattern 6: math-field with lang="en" - change to ar
                        processed = processed.replace(
                            /<math-field([^>]*)\blang="en"([^>]*)>/gi,
                            '<math-field$1lang="ar"$2>'
                        );
                        
                        return processed;
                    };
                    
                    // âœ¨ NEW FEATURE: Add dir="rtl" to all <p> tags
                    const addRTLToParagraphs = (content) => {
                        if (!content || typeof content !== 'string') return content;
                        
                        let processed = content;
                        
                        // Add dir="rtl" to all <p> tags that don't have it
                        // Uses negative lookahead to avoid adding dir="rtl" if already present
                        processed = processed.replace(
                            /<p(?!\s+[^>]*\bdir=["']rtl["'])([^>]*)>/gi,
                            '<p dir="rtl"$1>'
                        );
                        
                        // Also handle <P> (uppercase) tags
                        processed = processed.replace(
                            /<P(?!\s+[^>]*\bdir=["']rtl["'])([^>]*)>/g,
                            '<P dir="rtl"$1>'
                        );
                        
                        return processed;
                    };
                    
                    // Combined processing function
                    const applyRTLToContent = (content) => {
                        if (!content || typeof content !== 'string') return content;
                        
                        // Apply RTL to both math-field and p tags
                        let processed = addRTLToMathFields(content);
                        processed = addRTLToParagraphs(processed);
                        
                        return processed;
                    };
                    
                    for (const translatedFile of TranslatorApp.state.translatedJsonData) {
                        const finalData = JSON.parse(JSON.stringify(translatedFile.data));
                        const originalId = TranslatorApp.state.originalJsonData.find(f => f.name === translatedFile.name)?.data?.id;
                    
                        // âœ¨ ENHANCED: Process all string fields to add RTL to both math-field AND <p> tags
                        // Process statement
                        if (finalData.statement) {
                            finalData.statement = applyRTLToContent(finalData.statement);
                        }
                        
                        // Process parts
                        if (finalData.parts && Array.isArray(finalData.parts)) {
                            finalData.parts.forEach(part => {
                                // Process stem
                                if (part.stem) {
                                    part.stem = applyRTLToContent(part.stem);
                                }
                                
                                // Process answer
                                if (typeof part.answer === 'string') {
                                    part.answer = applyRTLToContent(part.answer);
                                }
                                
                                // Process choices
                                if (part.choices && Array.isArray(part.choices)) {
                                    part.choices.forEach(choice => {
                                        if (choice.html_content) {
                                            choice.html_content = applyRTLToContent(choice.html_content);
                                        }
                                    });
                                }
                                
                                // Process gap_text_keys
                                if (part.gap_text_keys && Array.isArray(part.gap_text_keys)) {
                                    part.gap_text_keys.forEach(key => {
                                        if (key.value) {
                                            key.value = applyRTLToContent(key.value);
                                        }
                                    });
                                }
                                
                                // Process AI guidelines
                                if (part.ai && part.ai.guidelines && Array.isArray(part.ai.guidelines)) {
                                    part.ai.guidelines.forEach(guideline => {
                                        if (guideline.comment) {
                                            guideline.comment = applyRTLToContent(guideline.comment);
                                        }
                                        if (guideline.student_answer) {
                                            guideline.student_answer = applyRTLToContent(guideline.student_answer);
                                        }
                                    });
                                }
                            });
                        }
                    
                        finalData.metadata = finalData.metadata || {};
                        finalData.metadata.title = "";
                        finalData.metadata.language = 'ar';
                        finalData.metadata.dialect = ['modern_standard'];
                        finalData.metadata.country = 'eg';
                    
                        if (sourceId) {
                            finalData.metadata.source_id = {
                                "value": parseInt(sourceId),
                                "page_number": null
                            };
                        } else {
                            finalData.metadata.source_id = null;
                        }
                    
                        const stripHtml = (html) => {
                            if (!html) return "";
                            const doc = new DOMParser().parseFromString(html, 'text/html');
                            return doc.body.textContent || "";
                        };
                    
                        const cleanStatement = stripHtml(finalData.statement);
                        const cleanStem = finalData.parts?.[0]?.stem ? stripHtml(finalData.parts[0].stem) : '';
                        let description = (cleanStatement + ' ' + cleanStem).trim();
                        finalData.metadata.description = description;
                    
                        if (finalData.parts) {
                            finalData.parts.forEach((part) => {
                                if (part.type === 'input_box' && part.answer && part.answer.hasOwnProperty('value')) {
                                    const originalUnit = TranslatorApp.state.originalJsonData
                                        .find(f => f.name === translatedFile.name)?.data.parts
                                        .find(p => p.n === part.n)?.answer.unit || '';
                                    part.answer.unit = TranslatorApp.quality.unitsMap[originalUnit.toLowerCase()] || originalUnit;
                                }
                            });
                        }
                    
                        let fileNameToUse = translatedFile.name;
                        // Assign the mapped ID for both export and display
                        if (useMappedIds && idCounter < mappedIds.length) {
                            const newMappedId = mappedIds[idCounter];
                            finalData.metadata.mapped_id = newMappedId;
                            fileNameToUse = `${newMappedId}.json`;
                            idCounter++;
                        } else {
                            finalData.metadata.mapped_id = originalId; // Fallback to original ID for the mapped_id field
                        }
                    
                        zip.file(fileNameToUse, JSON.stringify(finalData, null, 2));
                        console.log(`âœ… [Export] Processed file: ${fileNameToUse} - RTL applied to all math-field and <p> tags`);
                    }
                    
                    console.log(`ğŸ‰ [Export] Total files processed: ${TranslatorApp.state.translatedJsonData.length} - All math-fields and paragraphs have RTL direction in exported JSON`);
                    
                    if (useMappedIds && idCounter < TranslatorApp.state.translatedJsonData.length) {
                        TranslatorApp.ui.showAlert(`ØªØ­Ø°ÙŠØ±: Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª (${idCounter}) Ø£Ù‚Ù„ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª (${TranslatorApp.state.translatedJsonData.length}).`, 'error');
                    }
                    
                    try {
                        const content = await zip.generateAsync({ type: "blob" });
                        const link = document.createElement("a");
                        link.href = URL.createObjectURL(content);
                        link.download = `translated_questions_${new Date().toISOString().replace(/[:.]/g, '-')}.zip`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                        TranslatorApp.ui.showAlert('ØªÙ… ØªØµØ¯ÙŠØ± Ù…Ù„ÙØ§Øª JSON Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                    } catch (e) {
                        console.error('ZIP creation error:', e);
                        TranslatorApp.ui.showAlert(`ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP: ${e.message}`, 'error');
                    }
                },
                annotator: {
                    canvas: null,
                    fabricCanvas: null,
                    currentImage: null,
                    open() {
                        try {
                            const images = TranslatorApp.dom.previewContainer.querySelectorAll('img');
                            if (!images.length) {
                                TranslatorApp.ui.showAlert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ± ÙÙŠ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©.', 'info');
                                return;
                            }

                            // Use the first image in view for simplicity
                            this.currentImage = images[0];
                            if (!this.currentImage || !this.currentImage.src) {
                                TranslatorApp.ui.showAlert('Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©.', 'error');
                                return;
                            }

                            TranslatorApp.ui.showModal('imageAnnotatorModal', true);
                            setTimeout(() => this.initCanvas(), 0);
                        } catch (error) {
                            console.error('Image annotator open error:', error);
                            TranslatorApp.ui.showAlert(`ÙØ´Ù„ ÙÙŠ ÙØªØ­ Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±: ${error.message}`, 'error');
                        }
                    },
                    close() {
                        try {
                            // Clean up Fabric.js canvas
                            if (this.fabricCanvas) {
                                this.fabricCanvas.dispose();
                                this.fabricCanvas = null;
                            }
                            this.currentImage = null;
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        } catch (error) {
                            console.error('Image annotator close error:', error);
                            TranslatorApp.ui.showModal('imageAnnotatorModal', false);
                        }
                    },
                    initCanvas() {
                        try {
                            const canvasEl = TranslatorApp.dom.imageAnnotatorCanvas;
                            const img = this.currentImage;
                            if (!canvasEl || !img) {
                                TranslatorApp.ui.showAlert('Ø¹Ù†Ø§ØµØ± Canvas Ø£Ùˆ Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©.', 'error');
                                return;
                            }

                            // Set canvas dimensions
                            canvasEl.width = img.naturalWidth || img.width || 800;
                            canvasEl.height = img.naturalHeight || img.height || 600;

                            // Initialize Fabric.js canvas
                            this.fabricCanvas = new fabric.Canvas(canvasEl, { selection: true });

                            // Load image into canvas
                            fabric.Image.fromURL(img.src, (oImg) => {
                                try {
                                    oImg.selectable = false;
                                    oImg.evented = false;
                                    oImg.scaleToWidth(canvasEl.width);
                                    this.fabricCanvas.add(oImg).sendToBack(oImg);
                                } catch (imgError) {
                                    console.error('Image loading error:', imgError);
                                    TranslatorApp.ui.showAlert('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­Ø±Ø±.', 'error');
                                }
                            }, { crossOrigin: 'anonymous' });

                            // Add helper text tool with RTL support
                            this.fabricCanvas.on('mouse:dblclick', (e) => {
                                try {
                                    const pointer = this.fabricCanvas.getPointer(e.e);
                                    const textbox = new fabric.Textbox('Ù†Øµ', {
                                        left: pointer.x,
                                        top: pointer.y,
                                        fontSize: 24,
                                        fill: '#111827',
                                        backgroundColor: 'rgba(255,255,255,0.7)'
                                    });
                                    this.fabricCanvas.add(textbox).setActiveObject(textbox);
                                } catch (textError) {
                                    console.error('Text tool error:', textError);
                                }
                            });
                        } catch (error) {
                            console.error('Canvas initialization error:', error);
                            TranslatorApp.ui.showAlert(`ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ±: ${error.message}`, 'error');
                        }
                    },
                    save() {
                        if (!this.fabricCanvas) {
                            TranslatorApp.ui.showAlert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø­ØªÙˆÙ‰ Ù„Ù„Ø­ÙØ¸.', 'error');
                            return;
                        }

                        try {
                            const dataUrl = this.fabricCanvas.toDataURL({ format: 'png', quality: 1 });
                            if (!dataUrl || dataUrl === 'data:,') {
                                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                            }

                            // Replace the image in preview with annotated version (non-destructive â€“ just in UI)
                            this.currentImage.src = dataUrl;
                            TranslatorApp.state.hasUnsavedChanges = true;
                            this.close();
                            TranslatorApp.ui.showAlert('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© (Ù…Ø­Ù„ÙŠØ§Ù‹).', 'success');
                        } catch (error) {
                            console.error('Image save error:', error);
                            TranslatorApp.ui.showAlert(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©: ${error.message}`, 'error');
                        }
                    }
                }
            },
            
            /**
             * Validate that all required fields are selected before enabling translation
             */
            validateTranslationRequirements() {
                try {
                    const subject = this.state.selectedSubject || this.dom.subjectSelect?.value || 'None';
                    const grade = this.state.selectedGrade || this.dom.gradeSelect?.value || 'None';
                    const translator = this.state.selectedTranslator || this.dom.translatorSelect?.value || '';
                    const hasFiles = this.state.selectedFilesInfo && this.state.selectedFilesInfo.length > 0;
                    
                    // Check if all required fields are filled
                    const isSubjectValid = subject && subject !== 'None';
                    const isGradeValid = grade && grade !== 'None';
                    const isTranslatorValid = translator && translator !== '';
                    const allValid = isSubjectValid && isGradeValid && isTranslatorValid && hasFiles;
                    
                    // Enable or disable the translate button
                    if (this.dom.translateBtn) {
                        this.dom.translateBtn.disabled = !allValid;
                        
                        // Update button appearance
                        if (!allValid) {
                            this.dom.translateBtn.style.opacity = '0.5';
                            this.dom.translateBtn.style.cursor = 'not-allowed';
                            
                            // Show helpful message
                            const missingFields = [];
                            if (!isSubjectValid) missingFields.push('Ø§Ù„Ù…Ø§Ø¯Ø©');
                            if (!isGradeValid) missingFields.push('Ø§Ù„ØµÙ');
                            if (!isTranslatorValid) missingFields.push('Ø§Ø³Ù… Ø§Ù„Ù…ØªØ±Ø¬Ù…');
                            if (!hasFiles) missingFields.push('Ø§Ù„Ù…Ù„ÙØ§Øª');
                            
                            this.dom.translateBtn.title = `ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø±: ${missingFields.join(' Ùˆ ')}`;
                        } else {
                            this.dom.translateBtn.style.opacity = '1';
                            this.dom.translateBtn.style.cursor = 'pointer';
                            this.dom.translateBtn.title = 'Ø§Ø¨Ø¯Ø£ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ø¬Ù…Ø© (Ctrl + Enter)';
                        }
                    }
                    
                    return allValid;
                } catch (error) {
                    console.error('Validate translation requirements error:', error);
                    return false;
                }
            }
        };


        document.addEventListener('DOMContentLoaded', () => TranslatorApp.init());

    </script>



    <script>
        // Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªÙ‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø²Ø± ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù„ØºØ© ÙˆØ¥Ø¶Ø§ÙØªÙ‡ Ø¥Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        function addLanguageToggleButton() {
            // Ø§Ø¨Ø­Ø« Ø¹Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ ÙÙŠ Ø§Ù„ØµÙØ­Ø©
            const keyboard = document.querySelector('.ML__keyboard');

            // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ø£Ùˆ ÙƒØ§Ù† Ø§Ù„Ø²Ø± Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù„Ø§ ØªÙØ¹Ù„ Ø´ÙŠØ¦Ù‹Ø§
            if (!keyboard || keyboard.querySelector('.lang-toggle-btn')) {
                return;
            }

            // Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù†ØµØ± Ø§Ù„Ø²Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
            const btn = document.createElement('button');

            // Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ Ø³ÙŠØ¸Ù‡Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø±
            btn.textContent = 'Ø¹Ø±Ø¨ÙŠ / EN';

            // ÙƒÙ„Ø§Ø³ CSS Ù„ØªÙ…ÙŠÙŠØ² Ø§Ù„Ø²Ø±
            btn.className = 'lang-toggle-btn';

            // ØªØµÙ…ÙŠÙ… Ø¨Ø³ÙŠØ· Ù„Ù„Ø²Ø± Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            btn.style.cssText = `
            position: absolute;
            top: 5px;
            right: 170px; /* ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ù„ÙŠÙƒÙˆÙ† Ù…Ù†Ø§Ø³Ø¨Ù‹Ø§ */
            padding: 5px 10px;
            font-size: 14px;
            font-weight: bold;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 6px;
            cursor: pointer;
            z-index: 100;
        `;

            // Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø±ØŒ Ù‚Ù… Ø¨ØªÙ†ÙÙŠØ° Ù†ÙØ³ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙŠ ÙƒØ§Ù† Ø§Ù„Ø§Ø®ØªØµØ§Ø± ÙŠÙ†ÙØ°Ù‡Ø§
            btn.onclick = () => TranslatorApp.utils.mathLive.toggleLanguage();

            // Ø£Ø¶Ù Ø§Ù„Ø²Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            keyboard.appendChild(btn);
        }

    </script>

    <!-- --- âš ï¸ Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ (Confirm Modal) --- -->
    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[100]">
        <div class="main-card rounded-2xl shadow-xl p-6 w-full max-w-sm transform transition-all" role="dialog" aria-labelledby="confirmTitle">
            <h3 id="confirmTitle" class="text-lg font-bold mb-4">Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ</h3>
            <p id="confirmMessage" class="text-sm mb-6" style="color: var(--secondary-text);">Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.</p>
            <div class="flex justify-end gap-3">
                <button id="confirmCancelBtn" class="px-4 py-2 rounded-lg" style="background-color: var(--input-bg); border: 1px solid var(--input-border);">
                    Ø¥Ù„ØºØ§Ø¡
                </button>
                <button id="confirmOkBtn" class="px-4 py-2 rounded-lg text-white" style="background-color: var(--error-color);">
                    ØªØ£ÙƒÙŠØ¯
                </button>
            </div>
        </div>
    </div>
    <!-- --- âš ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ --- -->

</body>

</html>
